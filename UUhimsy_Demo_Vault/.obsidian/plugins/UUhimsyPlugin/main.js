/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/node-osc/dist/lib/Message.js
var require_Message = __commonJS({
  "node_modules/node-osc/dist/lib/Message.js"(exports, module2) {
    "use strict";
    var typeTags = {
      s: "string",
      f: "float",
      i: "integer",
      b: "blob"
    };
    var Argument = class {
      constructor(type, value) {
        this.type = type;
        this.value = value;
      }
    };
    var Message2 = class {
      constructor(address, ...args) {
        this.oscType = "message";
        this.address = address;
        this.args = args;
      }
      append(arg) {
        let argOut;
        switch (typeof arg) {
          case "object":
            if (arg instanceof Array) {
              arg.forEach((a) => this.append(a));
            } else if (arg.type) {
              if (typeTags[arg.type])
                arg.type = typeTags[arg.type];
              this.args.push(arg);
            } else {
              throw new Error(`don't know how to encode object ${arg}`);
            }
            break;
          case "number":
            if (Math.floor(arg) === arg) {
              argOut = new Argument("integer", arg);
            } else {
              argOut = new Argument("float", arg);
            }
            break;
          case "string":
            argOut = new Argument("string", arg);
            break;
          case "boolean":
            argOut = new Argument("boolean", arg);
            break;
          default:
            throw new Error(`don't know how to encode ${arg}`);
        }
        if (argOut)
          this.args.push(argOut);
      }
    };
    module2.exports = Message2;
  }
});

// node_modules/node-osc/dist/lib/Bundle.js
var require_Bundle = __commonJS({
  "node_modules/node-osc/dist/lib/Bundle.js"(exports, module2) {
    "use strict";
    var Message2 = require_Message();
    function sanitize(element) {
      if (element instanceof Array)
        element = new Message2(element[0], ...element.slice(1));
      return element;
    }
    var Bundle = class {
      constructor(timetag, ...elements) {
        if (!(typeof timetag === "number")) {
          elements.unshift(timetag);
          timetag = 0;
        }
        this.timetag = timetag;
        this.elements = elements.map(sanitize);
      }
      append(element) {
        this.elements.push(sanitize(element));
      }
    };
    module2.exports = Bundle;
  }
});

// node_modules/binpack/index.js
var require_binpack = __commonJS({
  "node_modules/binpack/index.js"(exports, module2) {
    var sizeOfType = function(t) {
      if (t[0] === "U") {
        t = t.slice(1);
      }
      return {
        "Float32": 4,
        "Float64": 8,
        "Int8": 1,
        "Int16": 2,
        "Int32": 4,
        "Int64": 8
      }[t];
    };
    var endianConv = function(e, t) {
      if (t[t.length - 1] === "8")
        return "";
      if (e === "big") {
        return "BE";
      }
      return "LE";
    };
    var addBindings = function(binpackTypename, nodeTypename) {
      if (!(typeof nodeTypename !== "undefined" && nodeTypename !== null)) {
        nodeTypename = binpackTypename;
      }
      module2.exports["pack" + binpackTypename] = function(num, endian) {
        b = new Buffer(sizeOfType(binpackTypename));
        b["write" + nodeTypename + endianConv(endian, binpackTypename)](num, 0, true);
        return b;
      };
      module2.exports["unpack" + binpackTypename] = function(buff, endian) {
        return buff["read" + nodeTypename + endianConv(endian, binpackTypename)](0);
      };
    };
    var addIntBindings = function(n) {
      addBindings("Int" + n);
      addBindings("UInt" + n);
    };
    addIntBindings(8);
    addIntBindings(16);
    addIntBindings(32);
    twoToThe32 = Math.pow(2, 32);
    var read64 = function(unsigned) {
      return function(buff, endian) {
        var e = endianConv(endian, "");
        var u = unsigned ? "U" : "";
        var low, high;
        if (e === "LE") {
          low = buff.readUInt32LE(0);
          high = buff["read" + u + "Int32LE"](4);
        } else {
          low = buff.readUInt32BE(4);
          high = buff["read" + u + "Int32BE"](0);
        }
        return high * twoToThe32 + low;
      };
    };
    var write64 = function(unsigned) {
      return function(num, endian) {
        var e = endianConv(endian, "");
        var u = unsigned ? "U" : "";
        var b2 = new Buffer(8);
        var high = Math.floor(num / twoToThe32);
        var low = Math.floor(num - high * twoToThe32);
        if (e == "LE") {
          b2.writeUInt32LE(low, 0, true);
          b2["write" + u + "Int32LE"](high, 4, true);
        } else {
          b2.writeUInt32BE(low, 4, true);
          b2["write" + u + "Int32BE"](high, 0, true);
        }
        return b2;
      };
    };
    module2.exports.unpackInt64 = read64(false);
    module2.exports.unpackUInt64 = read64(true);
    module2.exports.packInt64 = write64(false);
    module2.exports.packUInt64 = write64(true);
    addBindings("Float32", "Float");
    addBindings("Float64", "Double");
  }
});

// node_modules/osc-min/lib/osc-utilities.js
var require_osc_utilities = __commonJS({
  "node_modules/osc-min/lib/osc-utilities.js"(exports) {
    (function() {
      var IsArray, StrictError, TWO_POW_32, UNIX_EPOCH, binpack, getArrayArg, isOscBundleBuffer, makeTimetag, mapBundleList, oscTypeCodes, padding, toOscTypeAndArgs, hasProp = {}.hasOwnProperty;
      binpack = require_binpack();
      exports.concat = function(buffers) {
        var buffer, copyTo, destBuffer, j, k, l, len, len1, len2, sumLength;
        if (!IsArray(buffers)) {
          throw new Error("concat must take an array of buffers");
        }
        for (j = 0, len = buffers.length; j < len; j++) {
          buffer = buffers[j];
          if (!Buffer.isBuffer(buffer)) {
            throw new Error("concat must take an array of buffers");
          }
        }
        sumLength = 0;
        for (k = 0, len1 = buffers.length; k < len1; k++) {
          buffer = buffers[k];
          sumLength += buffer.length;
        }
        destBuffer = new Buffer(sumLength);
        copyTo = 0;
        for (l = 0, len2 = buffers.length; l < len2; l++) {
          buffer = buffers[l];
          buffer.copy(destBuffer, copyTo);
          copyTo += buffer.length;
        }
        return destBuffer;
      };
      exports.toOscString = function(str, strict) {
        var i, j, nullIndex, ref;
        if (!(typeof str === "string")) {
          throw new Error("can't pack a non-string into an osc-string");
        }
        nullIndex = str.indexOf("\0");
        if (nullIndex !== -1 && strict) {
          throw StrictError("Can't pack an osc-string that contains NULL characters");
        }
        if (nullIndex !== -1) {
          str = str.slice(0, nullIndex);
        }
        for (i = j = 0, ref = padding(str); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          str += "\0";
        }
        return new Buffer(str);
      };
      exports.splitOscString = function(buffer, strict) {
        var i, j, nullIndex, rawStr, ref, ref1, rest, splitPoint, str;
        if (!Buffer.isBuffer(buffer)) {
          throw StrictError("Can't split something that isn't a buffer");
        }
        rawStr = buffer.toString("utf8");
        nullIndex = rawStr.indexOf("\0");
        if (nullIndex === -1) {
          if (strict) {
            throw new Error("All osc-strings must contain a null character");
          }
          return {
            string: rawStr,
            rest: new Buffer(0)
          };
        }
        str = rawStr.slice(0, nullIndex);
        splitPoint = Buffer.byteLength(str) + padding(str);
        if (strict && splitPoint > buffer.length) {
          throw StrictError("Not enough padding for osc-string");
        }
        if (strict) {
          for (i = j = ref = Buffer.byteLength(str), ref1 = splitPoint; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
            if (buffer[i] !== 0) {
              throw StrictError("Not enough or incorrect padding for osc-string");
            }
          }
        }
        rest = buffer.slice(splitPoint, buffer.length);
        return {
          string: str,
          rest
        };
      };
      exports.splitInteger = function(buffer, type) {
        var bytes, num, rest, value;
        if (type == null) {
          type = "Int32";
        }
        bytes = binpack["pack" + type](0).length;
        if (buffer.length < bytes) {
          throw new Error("buffer is not big enough for integer type");
        }
        num = 0;
        value = binpack["unpack" + type](buffer.slice(0, bytes), "big");
        rest = buffer.slice(bytes, buffer.length);
        return {
          integer: value,
          rest
        };
      };
      exports.splitTimetag = function(buffer) {
        var a, b2, bytes, c, d, fractional, rest, seconds, type;
        type = "UInt32";
        bytes = binpack["pack" + type](0).length;
        if (buffer.length < bytes * 2) {
          throw new Error("buffer is not big enough to contain a timetag");
        }
        a = 0;
        b2 = bytes;
        seconds = binpack["unpack" + type](buffer.slice(a, b2), "big");
        c = bytes;
        d = bytes + bytes;
        fractional = binpack["unpack" + type](buffer.slice(c, d), "big");
        rest = buffer.slice(d, buffer.length);
        return {
          timetag: [seconds, fractional],
          rest
        };
      };
      UNIX_EPOCH = 2208988800;
      TWO_POW_32 = 4294967296;
      exports.dateToTimetag = function(date) {
        return exports.timestampToTimetag(date.getTime() / 1e3);
      };
      exports.timestampToTimetag = function(secs) {
        var fracSeconds, wholeSecs;
        wholeSecs = Math.floor(secs);
        fracSeconds = secs - wholeSecs;
        return makeTimetag(wholeSecs, fracSeconds);
      };
      exports.timetagToTimestamp = function(timetag) {
        var seconds;
        seconds = timetag[0] + exports.ntpToFractionalSeconds(timetag[1]);
        return seconds - UNIX_EPOCH;
      };
      makeTimetag = function(unixseconds, fracSeconds) {
        var ntpFracs, ntpSecs;
        ntpSecs = unixseconds + UNIX_EPOCH;
        ntpFracs = Math.round(TWO_POW_32 * fracSeconds);
        return [ntpSecs, ntpFracs];
      };
      exports.timetagToDate = function(timetag) {
        var date, dd, fracs, fractional, seconds;
        seconds = timetag[0], fractional = timetag[1];
        seconds = seconds - UNIX_EPOCH;
        fracs = exports.ntpToFractionalSeconds(fractional);
        date = new Date();
        date.setTime(seconds * 1e3 + fracs * 1e3);
        dd = new Date();
        dd.setUTCFullYear(date.getUTCFullYear());
        dd.setUTCMonth(date.getUTCMonth());
        dd.setUTCDate(date.getUTCDate());
        dd.setUTCHours(date.getUTCHours());
        dd.setUTCMinutes(date.getUTCMinutes());
        dd.setUTCSeconds(date.getUTCSeconds());
        dd.setUTCMilliseconds(fracs * 1e3);
        return dd;
      };
      exports.deltaTimetag = function(seconds, now) {
        var n;
        n = (now != null ? now : new Date()) / 1e3;
        return exports.timestampToTimetag(n + seconds);
      };
      exports.ntpToFractionalSeconds = function(fracSeconds) {
        return parseFloat(fracSeconds) / TWO_POW_32;
      };
      exports.toTimetagBuffer = function(timetag) {
        var high, low, type;
        if (typeof timetag === "number") {
          timetag = exports.timestampToTimetag(timetag);
        } else if (typeof timetag === "object" && "getTime" in timetag) {
          timetag = exports.dateToTimetag(timetag);
        } else if (timetag.length !== 2) {
          throw new Error("Invalid timetag" + timetag);
        }
        type = "UInt32";
        high = binpack["pack" + type](timetag[0], "big");
        low = binpack["pack" + type](timetag[1], "big");
        return exports.concat([high, low]);
      };
      exports.toIntegerBuffer = function(number, type) {
        if (type == null) {
          type = "Int32";
        }
        if (typeof number !== "number") {
          throw new Error("cannot pack a non-number into an integer buffer");
        }
        return binpack["pack" + type](number, "big");
      };
      oscTypeCodes = {
        s: {
          representation: "string",
          split: function(buffer, strict) {
            var split;
            split = exports.splitOscString(buffer, strict);
            return {
              value: split.string,
              rest: split.rest
            };
          },
          toArg: function(value, strict) {
            if (typeof value !== "string") {
              throw new Error("expected string");
            }
            return exports.toOscString(value, strict);
          }
        },
        i: {
          representation: "integer",
          split: function(buffer, strict) {
            var split;
            split = exports.splitInteger(buffer);
            return {
              value: split.integer,
              rest: split.rest
            };
          },
          toArg: function(value, strict) {
            if (typeof value !== "number") {
              throw new Error("expected number");
            }
            return exports.toIntegerBuffer(value);
          }
        },
        t: {
          representation: "timetag",
          split: function(buffer, strict) {
            var split;
            split = exports.splitTimetag(buffer);
            return {
              value: split.timetag,
              rest: split.rest
            };
          },
          toArg: function(value, strict) {
            return exports.toTimetagBuffer(value);
          }
        },
        f: {
          representation: "float",
          split: function(buffer, strict) {
            return {
              value: binpack.unpackFloat32(buffer.slice(0, 4), "big"),
              rest: buffer.slice(4, buffer.length)
            };
          },
          toArg: function(value, strict) {
            if (typeof value !== "number") {
              throw new Error("expected number");
            }
            return binpack.packFloat32(value, "big");
          }
        },
        d: {
          representation: "double",
          split: function(buffer, strict) {
            return {
              value: binpack.unpackFloat64(buffer.slice(0, 8), "big"),
              rest: buffer.slice(8, buffer.length)
            };
          },
          toArg: function(value, strict) {
            if (typeof value !== "number") {
              throw new Error("expected number");
            }
            return binpack.packFloat64(value, "big");
          }
        },
        b: {
          representation: "blob",
          split: function(buffer, strict) {
            var length, ref;
            ref = exports.splitInteger(buffer), length = ref.integer, buffer = ref.rest;
            return {
              value: buffer.slice(0, length),
              rest: buffer.slice(length, buffer.length)
            };
          },
          toArg: function(value, strict) {
            var size;
            if (!Buffer.isBuffer(value)) {
              throw new Error("expected node.js Buffer");
            }
            size = exports.toIntegerBuffer(value.length);
            return exports.concat([size, value]);
          }
        },
        T: {
          representation: "true",
          split: function(buffer, strict) {
            return {
              rest: buffer,
              value: true
            };
          },
          toArg: function(value, strict) {
            if (!value && strict) {
              throw new Error("true must be true");
            }
            return new Buffer(0);
          }
        },
        F: {
          representation: "false",
          split: function(buffer, strict) {
            return {
              rest: buffer,
              value: false
            };
          },
          toArg: function(value, strict) {
            if (value && strict) {
              throw new Error("false must be false");
            }
            return new Buffer(0);
          }
        },
        N: {
          representation: "null",
          split: function(buffer, strict) {
            return {
              rest: buffer,
              value: null
            };
          },
          toArg: function(value, strict) {
            if (value && strict) {
              throw new Error("null must be false");
            }
            return new Buffer(0);
          }
        },
        I: {
          representation: "bang",
          split: function(buffer, strict) {
            return {
              rest: buffer,
              value: "bang"
            };
          },
          toArg: function(value, strict) {
            return new Buffer(0);
          }
        }
      };
      exports.oscTypeCodeToTypeString = function(code) {
        var ref;
        return (ref = oscTypeCodes[code]) != null ? ref.representation : void 0;
      };
      exports.typeStringToOscTypeCode = function(rep) {
        var code, str;
        for (code in oscTypeCodes) {
          if (!hasProp.call(oscTypeCodes, code))
            continue;
          str = oscTypeCodes[code].representation;
          if (str === rep) {
            return code;
          }
        }
        return null;
      };
      exports.argToTypeCode = function(arg, strict) {
        var code, value;
        if ((arg != null ? arg.type : void 0) != null && typeof arg.type === "string" && (code = exports.typeStringToOscTypeCode(arg.type)) != null) {
          return code;
        }
        value = (arg != null ? arg.value : void 0) != null ? arg.value : arg;
        if (strict && value == null) {
          throw new Error("Argument has no value");
        }
        if (typeof value === "string") {
          return "s";
        }
        if (typeof value === "number") {
          return "f";
        }
        if (Buffer.isBuffer(value)) {
          return "b";
        }
        if (typeof value === "boolean") {
          if (value) {
            return "T";
          } else {
            return "F";
          }
        }
        if (value === null) {
          return "N";
        }
        throw new Error("I don't know what type this is supposed to be.");
      };
      exports.splitOscArgument = function(buffer, type, strict) {
        var osctype;
        osctype = exports.typeStringToOscTypeCode(type);
        if (osctype != null) {
          return oscTypeCodes[osctype].split(buffer, strict);
        } else {
          throw new Error("I don't understand how I'm supposed to unpack " + type);
        }
      };
      exports.toOscArgument = function(value, type, strict) {
        var osctype;
        osctype = exports.typeStringToOscTypeCode(type);
        if (osctype != null) {
          return oscTypeCodes[osctype].toArg(value, strict);
        } else {
          throw new Error("I don't know how to pack " + type);
        }
      };
      exports.fromOscMessage = function(buffer, strict) {
        var address, arg, args, arrayStack, built, j, len, ref, ref1, type, typeString, types;
        ref = exports.splitOscString(buffer, strict), address = ref.string, buffer = ref.rest;
        if (strict && address[0] !== "/") {
          throw StrictError("addresses must start with /");
        }
        if (!buffer.length) {
          return {
            address,
            args: []
          };
        }
        ref1 = exports.splitOscString(buffer, strict), types = ref1.string, buffer = ref1.rest;
        if (types[0] !== ",") {
          if (strict) {
            throw StrictError("Argument lists must begin with ,");
          }
          return {
            address,
            args: []
          };
        }
        types = types.slice(1, +types.length + 1 || 9e9);
        args = [];
        arrayStack = [args];
        for (j = 0, len = types.length; j < len; j++) {
          type = types[j];
          if (type === "[") {
            arrayStack.push([]);
            continue;
          }
          if (type === "]") {
            if (arrayStack.length <= 1) {
              if (strict) {
                throw new StrictError("Mismatched ']' character.");
              }
            } else {
              built = arrayStack.pop();
              arrayStack[arrayStack.length - 1].push({
                type: "array",
                value: built
              });
            }
            continue;
          }
          typeString = exports.oscTypeCodeToTypeString(type);
          if (typeString == null) {
            throw new Error("I don't understand the argument code " + type);
          }
          arg = exports.splitOscArgument(buffer, typeString, strict);
          if (arg != null) {
            buffer = arg.rest;
          }
          arrayStack[arrayStack.length - 1].push({
            type: typeString,
            value: arg != null ? arg.value : void 0
          });
        }
        if (arrayStack.length !== 1 && strict) {
          throw new StrictError("Mismatched '[' character");
        }
        return {
          address,
          args,
          oscType: "message"
        };
      };
      exports.fromOscBundle = function(buffer, strict) {
        var bundleTag, convertedElems, ref, ref1, timetag;
        ref = exports.splitOscString(buffer, strict), bundleTag = ref.string, buffer = ref.rest;
        if (bundleTag !== "#bundle") {
          throw new Error("osc-bundles must begin with #bundle");
        }
        ref1 = exports.splitTimetag(buffer), timetag = ref1.timetag, buffer = ref1.rest;
        convertedElems = mapBundleList(buffer, function(buffer2) {
          return exports.fromOscPacket(buffer2, strict);
        });
        return {
          timetag,
          elements: convertedElems,
          oscType: "bundle"
        };
      };
      exports.fromOscPacket = function(buffer, strict) {
        if (isOscBundleBuffer(buffer, strict)) {
          return exports.fromOscBundle(buffer, strict);
        } else {
          return exports.fromOscMessage(buffer, strict);
        }
      };
      getArrayArg = function(arg) {
        if (IsArray(arg)) {
          return arg;
        } else if ((arg != null ? arg.type : void 0) === "array" && IsArray(arg != null ? arg.value : void 0)) {
          return arg.value;
        } else if (arg != null && arg.type == null && IsArray(arg.value)) {
          return arg.value;
        } else {
          return null;
        }
      };
      toOscTypeAndArgs = function(argList, strict) {
        var arg, buff, j, len, oscargs, osctype, ref, thisArgs, thisType, typeCode, value;
        osctype = "";
        oscargs = [];
        for (j = 0, len = argList.length; j < len; j++) {
          arg = argList[j];
          if (getArrayArg(arg) != null) {
            ref = toOscTypeAndArgs(getArrayArg(arg), strict), thisType = ref[0], thisArgs = ref[1];
            osctype += "[" + thisType + "]";
            oscargs = oscargs.concat(thisArgs);
            continue;
          }
          typeCode = exports.argToTypeCode(arg, strict);
          if (typeCode != null) {
            value = arg != null ? arg.value : void 0;
            if (value === void 0) {
              value = arg;
            }
            buff = exports.toOscArgument(value, exports.oscTypeCodeToTypeString(typeCode), strict);
            if (buff != null) {
              oscargs.push(buff);
              osctype += typeCode;
            }
          }
        }
        return [osctype, oscargs];
      };
      exports.toOscMessage = function(message, strict) {
        var address, allArgs, args, old_arg, oscaddr, oscargs, osctype, ref;
        address = (message != null ? message.address : void 0) != null ? message.address : message;
        if (typeof address !== "string") {
          throw new Error("message must contain an address");
        }
        args = message != null ? message.args : void 0;
        if (args === void 0) {
          args = [];
        }
        if (!IsArray(args)) {
          old_arg = args;
          args = [];
          args[0] = old_arg;
        }
        oscaddr = exports.toOscString(address, strict);
        ref = toOscTypeAndArgs(args, strict), osctype = ref[0], oscargs = ref[1];
        osctype = "," + osctype;
        allArgs = exports.concat(oscargs);
        osctype = exports.toOscString(osctype);
        return exports.concat([oscaddr, osctype, allArgs]);
      };
      exports.toOscBundle = function(bundle, strict) {
        var allElems, buff, e, elem, elements, elemstr, j, len, oscBundleTag, oscElems, oscTimeTag, ref, ref1, size, timetag;
        if (strict && (bundle != null ? bundle.timetag : void 0) == null) {
          throw StrictError("bundles must have timetags.");
        }
        timetag = (ref = bundle != null ? bundle.timetag : void 0) != null ? ref : new Date();
        elements = (ref1 = bundle != null ? bundle.elements : void 0) != null ? ref1 : [];
        if (!IsArray(elements)) {
          elemstr = elements;
          elements = [];
          elements.push(elemstr);
        }
        oscBundleTag = exports.toOscString("#bundle");
        oscTimeTag = exports.toTimetagBuffer(timetag);
        oscElems = [];
        for (j = 0, len = elements.length; j < len; j++) {
          elem = elements[j];
          try {
            buff = exports.toOscPacket(elem, strict);
            size = exports.toIntegerBuffer(buff.length);
            oscElems.push(exports.concat([size, buff]));
          } catch (error) {
            e = error;
            null;
          }
        }
        allElems = exports.concat(oscElems);
        return exports.concat([oscBundleTag, oscTimeTag, allElems]);
      };
      exports.toOscPacket = function(bundleOrMessage, strict) {
        if ((bundleOrMessage != null ? bundleOrMessage.oscType : void 0) != null) {
          if (bundleOrMessage.oscType === "bundle") {
            return exports.toOscBundle(bundleOrMessage, strict);
          }
          return exports.toOscMessage(bundleOrMessage, strict);
        }
        if ((bundleOrMessage != null ? bundleOrMessage.timetag : void 0) != null || (bundleOrMessage != null ? bundleOrMessage.elements : void 0) != null) {
          return exports.toOscBundle(bundleOrMessage, strict);
        }
        return exports.toOscMessage(bundleOrMessage, strict);
      };
      exports.applyMessageTranformerToBundle = function(transform) {
        return function(buffer) {
          var bundleTagBuffer, copyIndex, elem, elems, j, k, len, len1, lengthBuff, outBuffer, ref, string, timetagBuffer, totalLength;
          ref = exports.splitOscString(buffer), string = ref.string, buffer = ref.rest;
          if (string !== "#bundle") {
            throw new Error("osc-bundles must begin with #bundle");
          }
          bundleTagBuffer = exports.toOscString(string);
          timetagBuffer = buffer.slice(0, 8);
          buffer = buffer.slice(8, buffer.length);
          elems = mapBundleList(buffer, function(buffer2) {
            return exports.applyTransform(buffer2, transform, exports.applyMessageTranformerToBundle(transform));
          });
          totalLength = bundleTagBuffer.length + timetagBuffer.length;
          for (j = 0, len = elems.length; j < len; j++) {
            elem = elems[j];
            totalLength += 4 + elem.length;
          }
          outBuffer = new Buffer(totalLength);
          bundleTagBuffer.copy(outBuffer, 0);
          timetagBuffer.copy(outBuffer, bundleTagBuffer.length);
          copyIndex = bundleTagBuffer.length + timetagBuffer.length;
          for (k = 0, len1 = elems.length; k < len1; k++) {
            elem = elems[k];
            lengthBuff = exports.toIntegerBuffer(elem.length);
            lengthBuff.copy(outBuffer, copyIndex);
            copyIndex += 4;
            elem.copy(outBuffer, copyIndex);
            copyIndex += elem.length;
          }
          return outBuffer;
        };
      };
      exports.applyTransform = function(buffer, mTransform, bundleTransform) {
        if (bundleTransform == null) {
          bundleTransform = exports.applyMessageTranformerToBundle(mTransform);
        }
        if (isOscBundleBuffer(buffer)) {
          return bundleTransform(buffer);
        } else {
          return mTransform(buffer);
        }
      };
      exports.addressTransform = function(transform) {
        return function(buffer) {
          var ref, rest, string;
          ref = exports.splitOscString(buffer), string = ref.string, rest = ref.rest;
          string = transform(string);
          return exports.concat([exports.toOscString(string), rest]);
        };
      };
      exports.messageTransform = function(transform) {
        return function(buffer) {
          var message;
          message = exports.fromOscMessage(buffer);
          return exports.toOscMessage(transform(message));
        };
      };
      IsArray = Array.isArray;
      StrictError = function(str) {
        return new Error("Strict Error: " + str);
      };
      padding = function(str) {
        var bufflength;
        bufflength = Buffer.byteLength(str);
        return 4 - bufflength % 4;
      };
      isOscBundleBuffer = function(buffer, strict) {
        var string;
        string = exports.splitOscString(buffer, strict).string;
        return string === "#bundle";
      };
      mapBundleList = function(buffer, func) {
        var e, elem, elems, j, len, nonNullElems, size, thisElemBuffer;
        elems = function() {
          var ref, results;
          results = [];
          while (buffer.length) {
            ref = exports.splitInteger(buffer), size = ref.integer, buffer = ref.rest;
            if (size > buffer.length) {
              throw new Error("Invalid bundle list: size of element is bigger than buffer");
            }
            thisElemBuffer = buffer.slice(0, size);
            buffer = buffer.slice(size, buffer.length);
            try {
              results.push(func(thisElemBuffer));
            } catch (error) {
              e = error;
              results.push(null);
            }
          }
          return results;
        }();
        nonNullElems = [];
        for (j = 0, len = elems.length; j < len; j++) {
          elem = elems[j];
          if (elem != null) {
            nonNullElems.push(elem);
          }
        }
        return nonNullElems;
      };
    }).call(exports);
  }
});

// node_modules/osc-min/lib/index.js
var require_lib = __commonJS({
  "node_modules/osc-min/lib/index.js"(exports) {
    (function() {
      var utils, coffee;
      utils = require_osc_utilities();
      exports.fromBuffer = function(buffer, strict) {
        if (buffer instanceof ArrayBuffer) {
          buffer = new Buffer(new Uint8Array(buffer));
        } else if (buffer instanceof Uint8Array) {
          buffer = new Buffer(buffer);
        }
        return utils.fromOscPacket(buffer, strict);
      };
      exports.toBuffer = function(object, strict, opt) {
        if (typeof object === "string")
          return utils.toOscPacket({ "address": object, "args": strict }, opt);
        return utils.toOscPacket(object, strict);
      };
      exports.applyAddressTransform = function(buffer, transform) {
        return utils.applyTransform(buffer, utils.addressTransform(transform));
      };
      exports.applyMessageTransform = function(buffer, transform) {
        return utils.applyTransform(buffer, utils.messageTransform(transform));
      };
      exports.timetagToDate = utils.timetagToDate;
      exports.dateToTimetag = utils.dateToTimetag;
      exports.timetagToTimestamp = utils.timetagToTimestamp;
      exports.timestampToTimetag = utils.timestampToTimetag;
    }).call(exports);
  }
});

// node_modules/node-osc/dist/lib/internal/decode.js
var require_decode = __commonJS({
  "node_modules/node-osc/dist/lib/internal/decode.js"(exports, module2) {
    "use strict";
    var oscMin = require_lib();
    function sanitizeMessage(decoded) {
      const message = [];
      message.push(decoded.address);
      decoded.args.forEach((arg) => {
        message.push(arg.value);
      });
      return message;
    }
    function sanitizeBundle(decoded) {
      decoded.elements = decoded.elements.map((element) => {
        if (element.oscType === "bundle")
          return sanitizeBundle(element);
        else if (element.oscType === "message")
          return sanitizeMessage(element);
      });
      return decoded;
    }
    function decode(data) {
      const decoded = oscMin.fromBuffer(data);
      if (decoded.oscType === "bundle") {
        return sanitizeBundle(decoded);
      } else if (decoded.oscType === "message") {
        return sanitizeMessage(decoded);
      } else {
        throw new Error("Malformed Packet");
      }
    }
    module2.exports = decode;
  }
});

// node_modules/node-osc/dist/lib/Server.js
var require_Server = __commonJS({
  "node_modules/node-osc/dist/lib/Server.js"(exports, module2) {
    "use strict";
    var node_dgram = require("dgram");
    var node_events = require("events");
    var decode = require_decode();
    var Server2 = class extends node_events.EventEmitter {
      constructor(port, host = "127.0.0.1", cb) {
        super();
        if (typeof host === "function") {
          cb = host;
          host = "127.0.0.1";
        }
        if (!cb)
          cb = () => {
          };
        let decoded;
        this.port = port;
        this.host = host;
        this._sock = node_dgram.createSocket({
          type: "udp4",
          reuseAddr: true
        });
        this._sock.bind(port, host);
        this._sock.on("listening", () => {
          this.emit("listening");
          cb();
        });
        this._sock.on("message", (msg, rinfo) => {
          try {
            decoded = decode(msg);
          } catch (e) {
            const error = new Error(`can't decode incoming message: ${e.message}`);
            this.emit("error", error, rinfo);
            return;
          }
          if (decoded.elements) {
            this.emit("bundle", decoded, rinfo);
          } else if (decoded) {
            this.emit("message", decoded, rinfo);
            this.emit(decoded[0], decoded, rinfo);
          }
        });
      }
      close(cb) {
        this._sock.close(cb);
      }
    };
    module2.exports = Server2;
  }
});

// node_modules/node-osc/dist/lib/Client.js
var require_Client = __commonJS({
  "node_modules/node-osc/dist/lib/Client.js"(exports, module2) {
    "use strict";
    var node_dgram = require("dgram");
    var oscMin = require_lib();
    var Message2 = require_Message();
    var { toBuffer } = oscMin;
    var Client2 = class {
      constructor(host, port) {
        this.host = host;
        this.port = port;
        this._sock = node_dgram.createSocket({
          type: "udp4",
          reuseAddr: true
        });
      }
      close(cb) {
        this._sock.close(cb);
      }
      send(...args) {
        let message = args[0];
        let callback;
        if (typeof args[args.length - 1] === "function") {
          callback = args.pop();
        } else {
          callback = () => {
          };
        }
        if (message instanceof Array) {
          message = {
            address: message[0],
            args: message.splice(1)
          };
        }
        let mes;
        let buf;
        try {
          switch (typeof message) {
            case "object":
              buf = toBuffer(message);
              this._sock.send(buf, 0, buf.length, this.port, this.host, callback);
              break;
            case "string":
              mes = new Message2(args[0]);
              for (let i = 1; i < args.length; i++) {
                mes.append(args[i]);
              }
              buf = toBuffer(mes);
              this._sock.send(buf, 0, buf.length, this.port, this.host, callback);
              break;
            default:
              throw new TypeError("That Message Just Doesn't Seem Right");
          }
        } catch (e) {
          if (e.code !== "ERR_SOCKET_DGRAM_NOT_RUNNING")
            throw e;
          const error = new ReferenceError("Cannot send message on closed socket.");
          error.code = e.code;
          callback(error);
        }
      }
    };
    module2.exports = Client2;
  }
});

// node_modules/node-osc/dist/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/node-osc/dist/lib/index.js"(exports) {
    "use strict";
    var Message2 = require_Message();
    var Bundle = require_Bundle();
    var Server2 = require_Server();
    var Client2 = require_Client();
    exports.Message = Message2;
    exports.Bundle = Bundle;
    exports.Server = Server2;
    exports.Client = Client2;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util = require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter;
    }
  }
});

// node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/ws/lib/constants.js"(exports, module2) {
    "use strict";
    var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
    var hasBlob = typeof Blob !== "undefined";
    if (hasBlob)
      BINARY_TYPES.push("blob");
    module2.exports = {
      BINARY_TYPES,
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      hasBlob,
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports, module2) {
    "use strict";
    var { isUtf8 } = require("buffer");
    var { hasBlob } = require_constants();
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    function isBlob(value) {
      return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
    }
    module2.exports = {
      isBlob,
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var DEFER_EVENT = 6;
    var Receiver = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n,
            buf.length - n
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n,
              buf.length - n
            );
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);
        if (!this._errored)
          cb();
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @param {Function} cb Callback
       * @private
       */
      getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          const error = this.createError(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
          cb(error);
          return;
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          const error = this.createError(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
          cb(error);
          return;
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (!this._fragmented) {
            const error = this.createError(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            const error = this.createError(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            const error = this.createError(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
            cb(error);
            return;
          }
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            const error = this.createError(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
            cb(error);
            return;
          }
        } else {
          const error = this.createError(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
          cb(error);
          return;
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            const error = this.createError(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
            cb(error);
            return;
          }
        } else if (this._masked) {
          const error = this.createError(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
          cb(error);
          return;
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          const error = this.createError(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
          cb(error);
          return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
      }
      /**
       * Payload length has been read.
       *
       * @param {Function} cb Callback
       * @private
       */
      haveLength(cb) {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
            cb(error);
            return;
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) {
          this.controlMessage(data, cb);
          return;
        }
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        this.dataMessage(cb);
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              const error = this.createError(
                RangeError,
                "Max payload size exceeded",
                false,
                1009,
                "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
              );
              cb(error);
              return;
            }
            this._fragments.push(buf);
          }
          this.dataMessage(cb);
          if (this._state === GET_INFO)
            this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @param {Function} cb Callback
       * @private
       */
      dataMessage(cb) {
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else if (this._binaryType === "blob") {
            data = new Blob(fragments);
          } else {
            data = fragments;
          }
          if (this._allowSynchronousEvents) {
            this.emit("message", data, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", data, true);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        } else {
          const buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(
              Error,
              "invalid UTF-8 sequence",
              true,
              1007,
              "WS_ERR_INVALID_UTF8"
            );
            cb(error);
            return;
          }
          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit("message", buf, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", buf, false);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        }
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data, cb) {
        if (this._opcode === 8) {
          if (data.length === 0) {
            this._loop = false;
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              const error = this.createError(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
              cb(error);
              return;
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              const error = this.createError(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
              cb(error);
              return;
            }
            this._loop = false;
            this.emit("conclude", code, buf);
            this.end();
          }
          this._state = GET_INFO;
          return;
        }
        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit(this._opcode === 9 ? "ping" : "pong", data);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
      /**
       * Builds an error object.
       *
       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
       * @param {String} message The error message
       * @param {Boolean} prefix Specifies whether or not to add a default prefix to
       *     `message`
       * @param {Number} statusCode The status code
       * @param {String} errorCode The exposed error code
       * @return {(Error|RangeError)} The error
       * @private
       */
      createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        const err = new ErrorCtor(
          prefix ? `Invalid WebSocket frame: ${message}` : message
        );
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
      }
    };
    module2.exports = Receiver;
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports, module2) {
    "use strict";
    var { Duplex } = require("stream");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants();
    var { isBlob, isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var RANDOM_POOL_SIZE = 8 * 1024;
    var randomPool;
    var randomPoolPointer = RANDOM_POOL_SIZE;
    var DEFAULT = 0;
    var DEFLATING = 1;
    var GET_BLOB_DATA = 2;
    var Sender = class {
      /**
       * Creates a Sender instance.
       *
       * @param {Duplex} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._queue = [];
        this._state = DEFAULT;
        this.onerror = NOOP;
        this[kWebSocket] = void 0;
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              if (randomPool === void 0) {
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }
              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }
            mask[0] = randomPool[randomPoolPointer++];
            mask[1] = randomPool[randomPoolPointer++];
            mask[2] = randomPool[randomPoolPointer++];
            mask[3] = randomPool[randomPoolPointer++];
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask)
          return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking)
          return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        const opts = {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
          } else {
            this.getBlobData(data, this._compress, opts, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      }
      /**
       * Gets the contents of a blob as binary data.
       *
       * @param {Blob} blob The blob
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     the data
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      getBlobData(blob, compress, options, cb) {
        this._bufferedBytes += options[kByteLength];
        this._state = GET_BLOB_DATA;
        blob.arrayBuffer().then((arrayBuffer) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while the blob was being read"
            );
            process.nextTick(callCallbacks, this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          const data = toBuffer(arrayBuffer);
          if (!compress) {
            this._state = DEFAULT;
            this.sendFrame(Sender.frame(data, options), cb);
            this.dequeue();
          } else {
            this.dispatch(data, compress, options, cb);
          }
        }).catch((err) => {
          process.nextTick(onError, this, err, cb);
        });
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._state = DEFLATING;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            callCallbacks(this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._state = DEFAULT;
          options.readOnly = false;
          this.sendFrame(Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (this._state === DEFAULT && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
    function callCallbacks(sender, err, cb) {
      if (typeof cb === "function")
        cb(err);
      for (let i = 0; i < sender._queue.length; i++) {
        const params = sender._queue[i];
        const callback = params[params.length - 1];
        if (typeof callback === "function")
          callback(err);
      }
    }
    function onError(sender, err, cb) {
      callCallbacks(sender, err, cb);
      sender.onerror(err);
    }
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values))
                values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Duplex, Readable } = require("stream");
    var { URL } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var { isBlob } = require_validation();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket = class extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._errorEmitted = false;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._autoPong = options.autoPong;
          this._isServer = true;
        }
      }
      /**
       * For historical reasons, the custom "nodebuffer" type is used by the default
       * instead of "blob".
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver({
          allowSynchronousEvents: options.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        const sender = new Sender(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._sender = sender;
        this._socket = socket;
        receiver[kWebSocket] = this;
        sender[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        sender.onerror = senderOnError;
        if (socket.setTimeout)
          socket.setTimeout(0);
        if (socket.setNoDelay)
          socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        setCloseTimer(this);
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain)
          this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute])
              return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function")
            return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket.prototype.addEventListener = addEventListener;
    WebSocket.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        allowSynchronousEvents: true,
        autoPong: true,
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      websocket._autoPong = opts.autoPong;
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL) {
        parsedUrl = address;
      } else {
        try {
          parsedUrl = new URL(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
      }
      if (parsedUrl.protocol === "http:") {
        parsedUrl.protocol = "ws:";
      } else if (parsedUrl.protocol === "https:") {
        parsedUrl.protocol = "wss:";
      }
      websocket._url = parsedUrl.href;
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https.request : http.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost)
              delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted])
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL(location, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket.CONNECTING)
          return;
        req = websocket._req = null;
        const upgrade = res.headers.upgrade;
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          allowSynchronousEvents: opts.allowSynchronousEvents,
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket.CLOSING;
      websocket._errorEmitted = true;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = isBlob(data) ? data.size : toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused)
        websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      if (websocket._autoPong)
        websocket.pong(data, !this._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function senderOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket.readyState === WebSocket.CLOSED)
        return;
      if (websocket.readyState === WebSocket.OPEN) {
        websocket._readyState = WebSocket.CLOSING;
        setCloseTimer(websocket);
      }
      this._socket.end();
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function setCloseTimer(websocket) {
      websocket._closeTimer = setTimeout(
        websocket._socket.destroy.bind(websocket._socket),
        closeTimeout
      );
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/ws/lib/stream.js"(exports, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data))
          ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused)
          ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/ws/lib/subprotocol.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse };
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http = require("http");
    var { Duplex } = require("stream");
    var { createHash } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket = require_websocket();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Boolean} [options.autoPong=true] Specifies whether or not to
       *     automatically send a pong in response to a ping
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          allowSynchronousEvents: true,
          autoPong: true,
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const upgrade = req.headers.upgrade;
        const version = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (key === void 0 || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version !== 8 && version !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null, void 0, this.options);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message);
      }
    }
  }
});

// node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/ws/index.js"(exports, module2) {
    "use strict";
    var WebSocket = require_websocket();
    WebSocket.createWebSocketStream = require_stream();
    WebSocket.Server = require_websocket_server();
    WebSocket.Receiver = require_receiver();
    WebSocket.Sender = require_sender();
    WebSocket.WebSocket = WebSocket;
    WebSocket.WebSocketServer = WebSocket.Server;
    module2.exports = WebSocket;
  }
});

// node_modules/isomorphic-ws/node.js
var require_node2 = __commonJS({
  "node_modules/isomorphic-ws/node.js"(exports, module2) {
    "use strict";
    module2.exports = require_ws();
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports, module2) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module2.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof global !== "undefined" && global.crypto) {
          crypto = global.crypto;
        }
        if (!crypto && typeof require === "function") {
          try {
            crypto = require("crypto");
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/crypto-js/sha256.js"(exports, module2) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module2.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n2) {
            var sqrtN = Math2.sqrt(n2);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n2 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n2) {
            return (n2 - (n2 | 0)) * 4294967296 | 0;
          }
          var n = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
              nPrime++;
            }
            n++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H2 = this._hash.words;
            var a = H2[0];
            var b2 = H2[1];
            var c = H2[2];
            var d = H2[3];
            var e = H2[4];
            var f = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f ^ ~e & g;
              var maj = a & b2 ^ a & c ^ b2 & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K[i] + W[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f;
              f = e;
              e = d + t1 | 0;
              d = c;
              c = b2;
              b2 = a;
              a = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b2 | 0;
            H2[2] = H2[2] + c | 0;
            H2[3] = H2[3] + d | 0;
            H2[4] = H2[4] + e | 0;
            H2[5] = H2[5] + f | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  }
});

// node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "node_modules/crypto-js/enc-base64.js"(exports, module2) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module2.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64 = C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  }
});

// node_modules/obs-websocket-js/dist/chunk-RL7MGYX4.cjs
var require_chunk_RL7MGYX4 = __commonJS({
  "node_modules/obs-websocket-js/dist/chunk-RL7MGYX4.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _class;
    var WebSocketOpCode = /* @__PURE__ */ ((WebSocketOpCode2) => {
      WebSocketOpCode2[WebSocketOpCode2["Hello"] = 0] = "Hello";
      WebSocketOpCode2[WebSocketOpCode2["Identify"] = 1] = "Identify";
      WebSocketOpCode2[WebSocketOpCode2["Identified"] = 2] = "Identified";
      WebSocketOpCode2[WebSocketOpCode2["Reidentify"] = 3] = "Reidentify";
      WebSocketOpCode2[WebSocketOpCode2["Event"] = 5] = "Event";
      WebSocketOpCode2[WebSocketOpCode2["Request"] = 6] = "Request";
      WebSocketOpCode2[WebSocketOpCode2["RequestResponse"] = 7] = "RequestResponse";
      WebSocketOpCode2[WebSocketOpCode2["RequestBatch"] = 8] = "RequestBatch";
      WebSocketOpCode2[WebSocketOpCode2["RequestBatchResponse"] = 9] = "RequestBatchResponse";
      return WebSocketOpCode2;
    })(WebSocketOpCode || {});
    var EventSubscription = /* @__PURE__ */ ((EventSubscription2) => {
      EventSubscription2[EventSubscription2["None"] = 0] = "None";
      EventSubscription2[EventSubscription2["General"] = 1] = "General";
      EventSubscription2[EventSubscription2["Config"] = 2] = "Config";
      EventSubscription2[EventSubscription2["Scenes"] = 4] = "Scenes";
      EventSubscription2[EventSubscription2["Inputs"] = 8] = "Inputs";
      EventSubscription2[EventSubscription2["Transitions"] = 16] = "Transitions";
      EventSubscription2[EventSubscription2["Filters"] = 32] = "Filters";
      EventSubscription2[EventSubscription2["Outputs"] = 64] = "Outputs";
      EventSubscription2[EventSubscription2["SceneItems"] = 128] = "SceneItems";
      EventSubscription2[EventSubscription2["MediaInputs"] = 256] = "MediaInputs";
      EventSubscription2[EventSubscription2["Vendors"] = 512] = "Vendors";
      EventSubscription2[EventSubscription2["Ui"] = 1024] = "Ui";
      EventSubscription2[EventSubscription2["All"] = 2047] = "All";
      EventSubscription2[EventSubscription2["InputVolumeMeters"] = 65536] = "InputVolumeMeters";
      EventSubscription2[EventSubscription2["InputActiveStateChanged"] = 131072] = "InputActiveStateChanged";
      EventSubscription2[EventSubscription2["InputShowStateChanged"] = 262144] = "InputShowStateChanged";
      EventSubscription2[EventSubscription2["SceneItemTransformChanged"] = 524288] = "SceneItemTransformChanged";
      return EventSubscription2;
    })(EventSubscription || {});
    var RequestBatchExecutionType = /* @__PURE__ */ ((RequestBatchExecutionType2) => {
      RequestBatchExecutionType2[RequestBatchExecutionType2["None"] = -1] = "None";
      RequestBatchExecutionType2[RequestBatchExecutionType2["SerialRealtime"] = 0] = "SerialRealtime";
      RequestBatchExecutionType2[RequestBatchExecutionType2["SerialFrame"] = 1] = "SerialFrame";
      RequestBatchExecutionType2[RequestBatchExecutionType2["Parallel"] = 2] = "Parallel";
      return RequestBatchExecutionType2;
    })(RequestBatchExecutionType || {});
    var _debug = require_src();
    var _debug2 = _interopRequireDefault(_debug);
    var _eventemitter3 = require_eventemitter3();
    var _isomorphicws = require_node2();
    var _isomorphicws2 = _interopRequireDefault(_isomorphicws);
    var _sha256js = require_sha256();
    var _sha256js2 = _interopRequireDefault(_sha256js);
    var _encbase64js = require_enc_base64();
    var _encbase64js2 = _interopRequireDefault(_encbase64js);
    function authenticationHashing_default(salt, challenge, msg) {
      const hash = _encbase64js2.default.stringify(_sha256js2.default.call(void 0, msg + salt));
      return _encbase64js2.default.stringify(_sha256js2.default.call(void 0, hash + challenge));
    }
    var debug = _debug2.default.call(void 0, "obs-websocket-js");
    var OBSWebSocketError = class extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
      }
    };
    var BaseOBSWebSocket = (_class = class _BaseOBSWebSocket extends _eventemitter3.EventEmitter {
      constructor(...args) {
        super(...args);
        _class.prototype.__init.call(this);
        _class.prototype.__init2.call(this);
      }
      static __initStatic() {
        this.requestCounter = 1;
      }
      static generateMessageId() {
        return String(_BaseOBSWebSocket.requestCounter++);
      }
      __init() {
        this._identified = false;
      }
      __init2() {
        this.internalListeners = new (0, _eventemitter3.EventEmitter)();
      }
      get identified() {
        return this._identified;
      }
      /**
       * Connect to an obs-websocket server
       * @param url Websocket server to connect to (including ws:// or wss:// protocol)
       * @param password Password
       * @param identificationParams Data for Identify event
       * @returns Hello & Identified messages data (combined)
       */
      async connect(url = "ws://127.0.0.1:4455", password, identificationParams = {}) {
        if (this.socket) {
          await this.disconnect();
        }
        try {
          const connectionClosedPromise = this.internalEventPromise("ConnectionClosed");
          const connectionErrorPromise = this.internalEventPromise("ConnectionError");
          return await Promise.race([
            (async () => {
              const hello = await this.createConnection(url);
              this.emit("Hello", hello);
              return this.identify(hello, password, identificationParams);
            })(),
            // Choose the best promise for connection error/close
            // In browser connection close has close code + reason,
            // while in node error event has these
            new Promise((resolve, reject) => {
              void connectionErrorPromise.then((e) => {
                if (e.message) {
                  reject(e);
                }
              });
              void connectionClosedPromise.then((e) => {
                reject(e);
              });
            })
          ]);
        } catch (error) {
          await this.disconnect();
          throw error;
        }
      }
      /**
       * Disconnect from obs-websocket server
       */
      async disconnect() {
        if (!this.socket || this.socket.readyState === _isomorphicws2.default.CLOSED) {
          return;
        }
        const connectionClosedPromise = this.internalEventPromise("ConnectionClosed");
        this.socket.close();
        await connectionClosedPromise;
      }
      /**
       * Update session parameters
       * @param data Reidentify data
       * @returns Identified message data
       */
      async reidentify(data) {
        const identifiedPromise = this.internalEventPromise(`op:${2}`);
        await this.message(3, data);
        return identifiedPromise;
      }
      /**
       * Send a request to obs-websocket
       * @param requestType Request name
       * @param requestData Request data
       * @returns Request response
       */
      async call(requestType, requestData) {
        const requestId = _BaseOBSWebSocket.generateMessageId();
        const responsePromise = this.internalEventPromise(`res:${requestId}`);
        await this.message(6, {
          requestId,
          requestType,
          requestData
        });
        const { requestStatus, responseData } = await responsePromise;
        if (!requestStatus.result) {
          throw new OBSWebSocketError(requestStatus.code, requestStatus.comment);
        }
        return responseData;
      }
      /**
       * Send a batch request to obs-websocket
       * @param requests Array of Request objects (type and data)
       * @param options A set of options for how the batch will be executed
       * @param options.executionType The mode of execution obs-websocket will run the batch in
       * @param options.haltOnFailure Whether obs-websocket should stop executing the batch if one request fails
       * @returns RequestBatch response
       */
      async callBatch(requests, options = {}) {
        const requestId = _BaseOBSWebSocket.generateMessageId();
        const responsePromise = this.internalEventPromise(`res:${requestId}`);
        await this.message(8, {
          requestId,
          requests,
          ...options
        });
        const { results } = await responsePromise;
        return results;
      }
      /**
       * Cleanup from socket disconnection
       */
      cleanup() {
        if (!this.socket) {
          return;
        }
        this.socket.onopen = null;
        this.socket.onmessage = null;
        this.socket.onerror = null;
        this.socket.onclose = null;
        this.socket = void 0;
        this._identified = false;
        this.internalListeners.removeAllListeners();
      }
      /**
       * Create connection to specified obs-websocket server
       *
       * @private
       * @param url Websocket address
       * @returns Promise for hello data
       */
      async createConnection(url) {
        var _a;
        const connectionOpenedPromise = this.internalEventPromise("ConnectionOpened");
        const helloPromise = this.internalEventPromise(`op:${0}`);
        this.socket = new (0, _isomorphicws2.default)(url, this.protocol);
        this.socket.onopen = this.onOpen.bind(this);
        this.socket.onmessage = this.onMessage.bind(this);
        this.socket.onerror = this.onError.bind(this);
        this.socket.onclose = this.onClose.bind(this);
        await connectionOpenedPromise;
        const protocol = (_a = this.socket) == null ? void 0 : _a.protocol;
        if (!protocol) {
          throw new OBSWebSocketError(-1, "Server sent no subprotocol");
        }
        if (protocol !== this.protocol) {
          throw new OBSWebSocketError(-1, "Server sent an invalid subprotocol");
        }
        return helloPromise;
      }
      /**
       * Send identify message
       *
       * @private
       * @param hello Hello message data
       * @param password Password
       * @param identificationParams Identification params
       * @returns Hello & Identified messages data (combined)
       */
      async identify({
        authentication,
        rpcVersion,
        ...helloRest
      }, password, identificationParams = {}) {
        const data = {
          rpcVersion,
          ...identificationParams
        };
        if (authentication && password) {
          data.authentication = authenticationHashing_default(authentication.salt, authentication.challenge, password);
        }
        const identifiedPromise = this.internalEventPromise(`op:${2}`);
        await this.message(1, data);
        const identified = await identifiedPromise;
        this._identified = true;
        this.emit("Identified", identified);
        return {
          rpcVersion,
          ...helloRest,
          ...identified
        };
      }
      /**
       * Send message to obs-websocket
       *
       * @private
       * @param op WebSocketOpCode
       * @param d Message data
       */
      async message(op, d) {
        if (!this.socket) {
          throw new Error("Not connected");
        }
        if (!this.identified && op !== 1) {
          throw new Error("Socket not identified");
        }
        const encoded = await this.encodeMessage({
          op,
          d
        });
        this.socket.send(encoded);
      }
      /**
       * Create a promise to listen for an event on internal listener
       * (will be cleaned up on disconnect)
       *
       * @private
       * @param event Event to listen to
       * @returns Event data
       */
      async internalEventPromise(event) {
        return new Promise((resolve) => {
          this.internalListeners.once(event, resolve);
        });
      }
      /**
       * Websocket open event listener
       *
       * @private
       * @param e Event
       */
      onOpen(e) {
        debug("socket.open");
        this.emit("ConnectionOpened");
        this.internalListeners.emit("ConnectionOpened", e);
      }
      /**
       * Websocket message event listener
       *
       * @private
       * @param e Event
       */
      async onMessage(e) {
        try {
          const { op, d } = await this.decodeMessage(e.data);
          debug("socket.message: %d %j", op, d);
          if (op === void 0 || d === void 0) {
            return;
          }
          switch (op) {
            case 5: {
              const { eventType, eventData } = d;
              this.emit(eventType, eventData);
              return;
            }
            case 7:
            case 9: {
              const { requestId } = d;
              this.internalListeners.emit(`res:${requestId}`, d);
              return;
            }
            default:
              this.internalListeners.emit(`op:${op}`, d);
          }
        } catch (error) {
          debug("error handling message: %o", error);
        }
      }
      /**
       * Websocket error event listener
       *
       * @private
       * @param e ErrorEvent
       */
      onError(e) {
        debug("socket.error: %o", e);
        const error = new OBSWebSocketError(-1, e.message);
        this.emit("ConnectionError", error);
        this.internalListeners.emit("ConnectionError", error);
      }
      /**
       * Websocket close event listener
       *
       * @private
       * @param e Event
       */
      onClose(e) {
        debug("socket.close: %s (%d)", e.reason, e.code);
        const error = new OBSWebSocketError(e.code, e.reason);
        this.emit("ConnectionClosed", error);
        this.internalListeners.emit("ConnectionClosed", error);
        this.cleanup();
      }
    }, _class.__initStatic(), _class);
    if (typeof exports !== "undefined") {
      Object.defineProperty(exports, "__esModule", { value: true });
    }
    exports.WebSocketOpCode = WebSocketOpCode;
    exports.EventSubscription = EventSubscription;
    exports.RequestBatchExecutionType = RequestBatchExecutionType;
    exports.OBSWebSocketError = OBSWebSocketError;
    exports.BaseOBSWebSocket = BaseOBSWebSocket;
  }
});

// node_modules/@msgpack/msgpack/dist/utils/int.js
var require_int = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/int.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUint64 = exports.getInt64 = exports.setInt64 = exports.setUint64 = exports.UINT32_MAX = void 0;
    exports.UINT32_MAX = 4294967295;
    function setUint64(view, offset, value) {
      const high = value / 4294967296;
      const low = value;
      view.setUint32(offset, high);
      view.setUint32(offset + 4, low);
    }
    exports.setUint64 = setUint64;
    function setInt64(view, offset, value) {
      const high = Math.floor(value / 4294967296);
      const low = value;
      view.setUint32(offset, high);
      view.setUint32(offset + 4, low);
    }
    exports.setInt64 = setInt64;
    function getInt64(view, offset) {
      const high = view.getInt32(offset);
      const low = view.getUint32(offset + 4);
      return high * 4294967296 + low;
    }
    exports.getInt64 = getInt64;
    function getUint64(view, offset) {
      const high = view.getUint32(offset);
      const low = view.getUint32(offset + 4);
      return high * 4294967296 + low;
    }
    exports.getUint64 = getUint64;
  }
});

// node_modules/@msgpack/msgpack/dist/utils/utf8.js
var require_utf8 = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/utf8.js"(exports) {
    "use strict";
    var _a;
    var _b;
    var _c;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utf8DecodeTD = exports.TEXT_DECODER_THRESHOLD = exports.utf8DecodeJs = exports.utf8EncodeTE = exports.TEXT_ENCODER_THRESHOLD = exports.utf8EncodeJs = exports.utf8Count = void 0;
    var int_1 = require_int();
    var TEXT_ENCODING_AVAILABLE = (typeof process === "undefined" || ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a["TEXT_ENCODING"]) !== "never") && typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined";
    function utf8Count(str) {
      const strLength = str.length;
      let byteLength = 0;
      let pos = 0;
      while (pos < strLength) {
        let value = str.charCodeAt(pos++);
        if ((value & 4294967168) === 0) {
          byteLength++;
          continue;
        } else if ((value & 4294965248) === 0) {
          byteLength += 2;
        } else {
          if (value >= 55296 && value <= 56319) {
            if (pos < strLength) {
              const extra = str.charCodeAt(pos);
              if ((extra & 64512) === 56320) {
                ++pos;
                value = ((value & 1023) << 10) + (extra & 1023) + 65536;
              }
            }
          }
          if ((value & 4294901760) === 0) {
            byteLength += 3;
          } else {
            byteLength += 4;
          }
        }
      }
      return byteLength;
    }
    exports.utf8Count = utf8Count;
    function utf8EncodeJs(str, output, outputOffset) {
      const strLength = str.length;
      let offset = outputOffset;
      let pos = 0;
      while (pos < strLength) {
        let value = str.charCodeAt(pos++);
        if ((value & 4294967168) === 0) {
          output[offset++] = value;
          continue;
        } else if ((value & 4294965248) === 0) {
          output[offset++] = value >> 6 & 31 | 192;
        } else {
          if (value >= 55296 && value <= 56319) {
            if (pos < strLength) {
              const extra = str.charCodeAt(pos);
              if ((extra & 64512) === 56320) {
                ++pos;
                value = ((value & 1023) << 10) + (extra & 1023) + 65536;
              }
            }
          }
          if ((value & 4294901760) === 0) {
            output[offset++] = value >> 12 & 15 | 224;
            output[offset++] = value >> 6 & 63 | 128;
          } else {
            output[offset++] = value >> 18 & 7 | 240;
            output[offset++] = value >> 12 & 63 | 128;
            output[offset++] = value >> 6 & 63 | 128;
          }
        }
        output[offset++] = value & 63 | 128;
      }
    }
    exports.utf8EncodeJs = utf8EncodeJs;
    var sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : void 0;
    exports.TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? int_1.UINT32_MAX : typeof process !== "undefined" && ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b["TEXT_ENCODING"]) !== "force" ? 200 : 0;
    function utf8EncodeTEencode(str, output, outputOffset) {
      output.set(sharedTextEncoder.encode(str), outputOffset);
    }
    function utf8EncodeTEencodeInto(str, output, outputOffset) {
      sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
    }
    exports.utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;
    var CHUNK_SIZE = 4096;
    function utf8DecodeJs(bytes, inputOffset, byteLength) {
      let offset = inputOffset;
      const end = offset + byteLength;
      const units = [];
      let result = "";
      while (offset < end) {
        const byte1 = bytes[offset++];
        if ((byte1 & 128) === 0) {
          units.push(byte1);
        } else if ((byte1 & 224) === 192) {
          const byte2 = bytes[offset++] & 63;
          units.push((byte1 & 31) << 6 | byte2);
        } else if ((byte1 & 240) === 224) {
          const byte2 = bytes[offset++] & 63;
          const byte3 = bytes[offset++] & 63;
          units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
        } else if ((byte1 & 248) === 240) {
          const byte2 = bytes[offset++] & 63;
          const byte3 = bytes[offset++] & 63;
          const byte4 = bytes[offset++] & 63;
          let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
          if (unit > 65535) {
            unit -= 65536;
            units.push(unit >>> 10 & 1023 | 55296);
            unit = 56320 | unit & 1023;
          }
          units.push(unit);
        } else {
          units.push(byte1);
        }
        if (units.length >= CHUNK_SIZE) {
          result += String.fromCharCode(...units);
          units.length = 0;
        }
      }
      if (units.length > 0) {
        result += String.fromCharCode(...units);
      }
      return result;
    }
    exports.utf8DecodeJs = utf8DecodeJs;
    var sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;
    exports.TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? int_1.UINT32_MAX : typeof process !== "undefined" && ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c["TEXT_DECODER"]) !== "force" ? 200 : 0;
    function utf8DecodeTD(bytes, inputOffset, byteLength) {
      const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
      return sharedTextDecoder.decode(stringBytes);
    }
    exports.utf8DecodeTD = utf8DecodeTD;
  }
});

// node_modules/@msgpack/msgpack/dist/ExtData.js
var require_ExtData = __commonJS({
  "node_modules/@msgpack/msgpack/dist/ExtData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtData = void 0;
    var ExtData = class {
      constructor(type, data) {
        this.type = type;
        this.data = data;
      }
    };
    exports.ExtData = ExtData;
  }
});

// node_modules/@msgpack/msgpack/dist/DecodeError.js
var require_DecodeError = __commonJS({
  "node_modules/@msgpack/msgpack/dist/DecodeError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecodeError = void 0;
    var DecodeError = class extends Error {
      constructor(message) {
        super(message);
        const proto = Object.create(DecodeError.prototype);
        Object.setPrototypeOf(this, proto);
        Object.defineProperty(this, "name", {
          configurable: true,
          enumerable: false,
          value: DecodeError.name
        });
      }
    };
    exports.DecodeError = DecodeError;
  }
});

// node_modules/@msgpack/msgpack/dist/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/@msgpack/msgpack/dist/timestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timestampExtension = exports.decodeTimestampExtension = exports.decodeTimestampToTimeSpec = exports.encodeTimestampExtension = exports.encodeDateToTimeSpec = exports.encodeTimeSpecToTimestamp = exports.EXT_TIMESTAMP = void 0;
    var DecodeError_1 = require_DecodeError();
    var int_1 = require_int();
    exports.EXT_TIMESTAMP = -1;
    var TIMESTAMP32_MAX_SEC = 4294967296 - 1;
    var TIMESTAMP64_MAX_SEC = 17179869184 - 1;
    function encodeTimeSpecToTimestamp({ sec, nsec }) {
      if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
          const rv = new Uint8Array(4);
          const view = new DataView(rv.buffer);
          view.setUint32(0, sec);
          return rv;
        } else {
          const secHigh = sec / 4294967296;
          const secLow = sec & 4294967295;
          const rv = new Uint8Array(8);
          const view = new DataView(rv.buffer);
          view.setUint32(0, nsec << 2 | secHigh & 3);
          view.setUint32(4, secLow);
          return rv;
        }
      } else {
        const rv = new Uint8Array(12);
        const view = new DataView(rv.buffer);
        view.setUint32(0, nsec);
        (0, int_1.setInt64)(view, 4, sec);
        return rv;
      }
    }
    exports.encodeTimeSpecToTimestamp = encodeTimeSpecToTimestamp;
    function encodeDateToTimeSpec(date) {
      const msec = date.getTime();
      const sec = Math.floor(msec / 1e3);
      const nsec = (msec - sec * 1e3) * 1e6;
      const nsecInSec = Math.floor(nsec / 1e9);
      return {
        sec: sec + nsecInSec,
        nsec: nsec - nsecInSec * 1e9
      };
    }
    exports.encodeDateToTimeSpec = encodeDateToTimeSpec;
    function encodeTimestampExtension(object) {
      if (object instanceof Date) {
        const timeSpec = encodeDateToTimeSpec(object);
        return encodeTimeSpecToTimestamp(timeSpec);
      } else {
        return null;
      }
    }
    exports.encodeTimestampExtension = encodeTimestampExtension;
    function decodeTimestampToTimeSpec(data) {
      const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
      switch (data.byteLength) {
        case 4: {
          const sec = view.getUint32(0);
          const nsec = 0;
          return { sec, nsec };
        }
        case 8: {
          const nsec30AndSecHigh2 = view.getUint32(0);
          const secLow32 = view.getUint32(4);
          const sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
          const nsec = nsec30AndSecHigh2 >>> 2;
          return { sec, nsec };
        }
        case 12: {
          const sec = (0, int_1.getInt64)(view, 4);
          const nsec = view.getUint32(0);
          return { sec, nsec };
        }
        default:
          throw new DecodeError_1.DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);
      }
    }
    exports.decodeTimestampToTimeSpec = decodeTimestampToTimeSpec;
    function decodeTimestampExtension(data) {
      const timeSpec = decodeTimestampToTimeSpec(data);
      return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
    }
    exports.decodeTimestampExtension = decodeTimestampExtension;
    exports.timestampExtension = {
      type: exports.EXT_TIMESTAMP,
      encode: encodeTimestampExtension,
      decode: decodeTimestampExtension
    };
  }
});

// node_modules/@msgpack/msgpack/dist/ExtensionCodec.js
var require_ExtensionCodec = __commonJS({
  "node_modules/@msgpack/msgpack/dist/ExtensionCodec.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtensionCodec = void 0;
    var ExtData_1 = require_ExtData();
    var timestamp_1 = require_timestamp();
    var ExtensionCodec = class {
      constructor() {
        this.builtInEncoders = [];
        this.builtInDecoders = [];
        this.encoders = [];
        this.decoders = [];
        this.register(timestamp_1.timestampExtension);
      }
      register({ type, encode, decode }) {
        if (type >= 0) {
          this.encoders[type] = encode;
          this.decoders[type] = decode;
        } else {
          const index = 1 + type;
          this.builtInEncoders[index] = encode;
          this.builtInDecoders[index] = decode;
        }
      }
      tryToEncode(object, context) {
        for (let i = 0; i < this.builtInEncoders.length; i++) {
          const encodeExt = this.builtInEncoders[i];
          if (encodeExt != null) {
            const data = encodeExt(object, context);
            if (data != null) {
              const type = -1 - i;
              return new ExtData_1.ExtData(type, data);
            }
          }
        }
        for (let i = 0; i < this.encoders.length; i++) {
          const encodeExt = this.encoders[i];
          if (encodeExt != null) {
            const data = encodeExt(object, context);
            if (data != null) {
              const type = i;
              return new ExtData_1.ExtData(type, data);
            }
          }
        }
        if (object instanceof ExtData_1.ExtData) {
          return object;
        }
        return null;
      }
      decode(data, type, context) {
        const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
        if (decodeExt) {
          return decodeExt(data, type, context);
        } else {
          return new ExtData_1.ExtData(type, data);
        }
      }
    };
    exports.ExtensionCodec = ExtensionCodec;
    ExtensionCodec.defaultCodec = new ExtensionCodec();
  }
});

// node_modules/@msgpack/msgpack/dist/utils/typedArrays.js
var require_typedArrays = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/typedArrays.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDataView = exports.ensureUint8Array = void 0;
    function ensureUint8Array(buffer) {
      if (buffer instanceof Uint8Array) {
        return buffer;
      } else if (ArrayBuffer.isView(buffer)) {
        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      } else if (buffer instanceof ArrayBuffer) {
        return new Uint8Array(buffer);
      } else {
        return Uint8Array.from(buffer);
      }
    }
    exports.ensureUint8Array = ensureUint8Array;
    function createDataView(buffer) {
      if (buffer instanceof ArrayBuffer) {
        return new DataView(buffer);
      }
      const bufferView = ensureUint8Array(buffer);
      return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
    }
    exports.createDataView = createDataView;
  }
});

// node_modules/@msgpack/msgpack/dist/Encoder.js
var require_Encoder = __commonJS({
  "node_modules/@msgpack/msgpack/dist/Encoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Encoder = exports.DEFAULT_INITIAL_BUFFER_SIZE = exports.DEFAULT_MAX_DEPTH = void 0;
    var utf8_1 = require_utf8();
    var ExtensionCodec_1 = require_ExtensionCodec();
    var int_1 = require_int();
    var typedArrays_1 = require_typedArrays();
    exports.DEFAULT_MAX_DEPTH = 100;
    exports.DEFAULT_INITIAL_BUFFER_SIZE = 2048;
    var Encoder = class {
      constructor(extensionCodec = ExtensionCodec_1.ExtensionCodec.defaultCodec, context = void 0, maxDepth = exports.DEFAULT_MAX_DEPTH, initialBufferSize = exports.DEFAULT_INITIAL_BUFFER_SIZE, sortKeys = false, forceFloat32 = false, ignoreUndefined = false, forceIntegerToFloat = false) {
        this.extensionCodec = extensionCodec;
        this.context = context;
        this.maxDepth = maxDepth;
        this.initialBufferSize = initialBufferSize;
        this.sortKeys = sortKeys;
        this.forceFloat32 = forceFloat32;
        this.ignoreUndefined = ignoreUndefined;
        this.forceIntegerToFloat = forceIntegerToFloat;
        this.pos = 0;
        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
        this.bytes = new Uint8Array(this.view.buffer);
      }
      reinitializeState() {
        this.pos = 0;
      }
      /**
       * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.
       *
       * @returns Encodes the object and returns a shared reference the encoder's internal buffer.
       */
      encodeSharedRef(object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.subarray(0, this.pos);
      }
      /**
       * @returns Encodes the object and returns a copy of the encoder's internal buffer.
       */
      encode(object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.slice(0, this.pos);
      }
      doEncode(object, depth) {
        if (depth > this.maxDepth) {
          throw new Error(`Too deep objects in depth ${depth}`);
        }
        if (object == null) {
          this.encodeNil();
        } else if (typeof object === "boolean") {
          this.encodeBoolean(object);
        } else if (typeof object === "number") {
          this.encodeNumber(object);
        } else if (typeof object === "string") {
          this.encodeString(object);
        } else {
          this.encodeObject(object, depth);
        }
      }
      ensureBufferSizeToWrite(sizeToWrite) {
        const requiredSize = this.pos + sizeToWrite;
        if (this.view.byteLength < requiredSize) {
          this.resizeBuffer(requiredSize * 2);
        }
      }
      resizeBuffer(newSize) {
        const newBuffer = new ArrayBuffer(newSize);
        const newBytes = new Uint8Array(newBuffer);
        const newView = new DataView(newBuffer);
        newBytes.set(this.bytes);
        this.view = newView;
        this.bytes = newBytes;
      }
      encodeNil() {
        this.writeU8(192);
      }
      encodeBoolean(object) {
        if (object === false) {
          this.writeU8(194);
        } else {
          this.writeU8(195);
        }
      }
      encodeNumber(object) {
        if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {
          if (object >= 0) {
            if (object < 128) {
              this.writeU8(object);
            } else if (object < 256) {
              this.writeU8(204);
              this.writeU8(object);
            } else if (object < 65536) {
              this.writeU8(205);
              this.writeU16(object);
            } else if (object < 4294967296) {
              this.writeU8(206);
              this.writeU32(object);
            } else {
              this.writeU8(207);
              this.writeU64(object);
            }
          } else {
            if (object >= -32) {
              this.writeU8(224 | object + 32);
            } else if (object >= -128) {
              this.writeU8(208);
              this.writeI8(object);
            } else if (object >= -32768) {
              this.writeU8(209);
              this.writeI16(object);
            } else if (object >= -2147483648) {
              this.writeU8(210);
              this.writeI32(object);
            } else {
              this.writeU8(211);
              this.writeI64(object);
            }
          }
        } else {
          if (this.forceFloat32) {
            this.writeU8(202);
            this.writeF32(object);
          } else {
            this.writeU8(203);
            this.writeF64(object);
          }
        }
      }
      writeStringHeader(byteLength) {
        if (byteLength < 32) {
          this.writeU8(160 + byteLength);
        } else if (byteLength < 256) {
          this.writeU8(217);
          this.writeU8(byteLength);
        } else if (byteLength < 65536) {
          this.writeU8(218);
          this.writeU16(byteLength);
        } else if (byteLength < 4294967296) {
          this.writeU8(219);
          this.writeU32(byteLength);
        } else {
          throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);
        }
      }
      encodeString(object) {
        const maxHeaderSize = 1 + 4;
        const strLength = object.length;
        if (strLength > utf8_1.TEXT_ENCODER_THRESHOLD) {
          const byteLength = (0, utf8_1.utf8Count)(object);
          this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
          this.writeStringHeader(byteLength);
          (0, utf8_1.utf8EncodeTE)(object, this.bytes, this.pos);
          this.pos += byteLength;
        } else {
          const byteLength = (0, utf8_1.utf8Count)(object);
          this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
          this.writeStringHeader(byteLength);
          (0, utf8_1.utf8EncodeJs)(object, this.bytes, this.pos);
          this.pos += byteLength;
        }
      }
      encodeObject(object, depth) {
        const ext = this.extensionCodec.tryToEncode(object, this.context);
        if (ext != null) {
          this.encodeExtension(ext);
        } else if (Array.isArray(object)) {
          this.encodeArray(object, depth);
        } else if (ArrayBuffer.isView(object)) {
          this.encodeBinary(object);
        } else if (typeof object === "object") {
          this.encodeMap(object, depth);
        } else {
          throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);
        }
      }
      encodeBinary(object) {
        const size = object.byteLength;
        if (size < 256) {
          this.writeU8(196);
          this.writeU8(size);
        } else if (size < 65536) {
          this.writeU8(197);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(198);
          this.writeU32(size);
        } else {
          throw new Error(`Too large binary: ${size}`);
        }
        const bytes = (0, typedArrays_1.ensureUint8Array)(object);
        this.writeU8a(bytes);
      }
      encodeArray(object, depth) {
        const size = object.length;
        if (size < 16) {
          this.writeU8(144 + size);
        } else if (size < 65536) {
          this.writeU8(220);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(221);
          this.writeU32(size);
        } else {
          throw new Error(`Too large array: ${size}`);
        }
        for (const item of object) {
          this.doEncode(item, depth + 1);
        }
      }
      countWithoutUndefined(object, keys) {
        let count = 0;
        for (const key of keys) {
          if (object[key] !== void 0) {
            count++;
          }
        }
        return count;
      }
      encodeMap(object, depth) {
        const keys = Object.keys(object);
        if (this.sortKeys) {
          keys.sort();
        }
        const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;
        if (size < 16) {
          this.writeU8(128 + size);
        } else if (size < 65536) {
          this.writeU8(222);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(223);
          this.writeU32(size);
        } else {
          throw new Error(`Too large map object: ${size}`);
        }
        for (const key of keys) {
          const value = object[key];
          if (!(this.ignoreUndefined && value === void 0)) {
            this.encodeString(key);
            this.doEncode(value, depth + 1);
          }
        }
      }
      encodeExtension(ext) {
        const size = ext.data.length;
        if (size === 1) {
          this.writeU8(212);
        } else if (size === 2) {
          this.writeU8(213);
        } else if (size === 4) {
          this.writeU8(214);
        } else if (size === 8) {
          this.writeU8(215);
        } else if (size === 16) {
          this.writeU8(216);
        } else if (size < 256) {
          this.writeU8(199);
          this.writeU8(size);
        } else if (size < 65536) {
          this.writeU8(200);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(201);
          this.writeU32(size);
        } else {
          throw new Error(`Too large extension object: ${size}`);
        }
        this.writeI8(ext.type);
        this.writeU8a(ext.data);
      }
      writeU8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setUint8(this.pos, value);
        this.pos++;
      }
      writeU8a(values) {
        const size = values.length;
        this.ensureBufferSizeToWrite(size);
        this.bytes.set(values, this.pos);
        this.pos += size;
      }
      writeI8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setInt8(this.pos, value);
        this.pos++;
      }
      writeU16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setUint16(this.pos, value);
        this.pos += 2;
      }
      writeI16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setInt16(this.pos, value);
        this.pos += 2;
      }
      writeU32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setUint32(this.pos, value);
        this.pos += 4;
      }
      writeI32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setInt32(this.pos, value);
        this.pos += 4;
      }
      writeF32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setFloat32(this.pos, value);
        this.pos += 4;
      }
      writeF64(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setFloat64(this.pos, value);
        this.pos += 8;
      }
      writeU64(value) {
        this.ensureBufferSizeToWrite(8);
        (0, int_1.setUint64)(this.view, this.pos, value);
        this.pos += 8;
      }
      writeI64(value) {
        this.ensureBufferSizeToWrite(8);
        (0, int_1.setInt64)(this.view, this.pos, value);
        this.pos += 8;
      }
    };
    exports.Encoder = Encoder;
  }
});

// node_modules/@msgpack/msgpack/dist/encode.js
var require_encode = __commonJS({
  "node_modules/@msgpack/msgpack/dist/encode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = void 0;
    var Encoder_1 = require_Encoder();
    var defaultEncodeOptions = {};
    function encode(value, options = defaultEncodeOptions) {
      const encoder = new Encoder_1.Encoder(options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);
      return encoder.encodeSharedRef(value);
    }
    exports.encode = encode;
  }
});

// node_modules/@msgpack/msgpack/dist/utils/prettyByte.js
var require_prettyByte = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/prettyByte.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prettyByte = void 0;
    function prettyByte(byte) {
      return `${byte < 0 ? "-" : ""}0x${Math.abs(byte).toString(16).padStart(2, "0")}`;
    }
    exports.prettyByte = prettyByte;
  }
});

// node_modules/@msgpack/msgpack/dist/CachedKeyDecoder.js
var require_CachedKeyDecoder = __commonJS({
  "node_modules/@msgpack/msgpack/dist/CachedKeyDecoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CachedKeyDecoder = void 0;
    var utf8_1 = require_utf8();
    var DEFAULT_MAX_KEY_LENGTH = 16;
    var DEFAULT_MAX_LENGTH_PER_KEY = 16;
    var CachedKeyDecoder = class {
      constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {
        this.maxKeyLength = maxKeyLength;
        this.maxLengthPerKey = maxLengthPerKey;
        this.hit = 0;
        this.miss = 0;
        this.caches = [];
        for (let i = 0; i < this.maxKeyLength; i++) {
          this.caches.push([]);
        }
      }
      canBeCached(byteLength) {
        return byteLength > 0 && byteLength <= this.maxKeyLength;
      }
      find(bytes, inputOffset, byteLength) {
        const records = this.caches[byteLength - 1];
        FIND_CHUNK:
          for (const record of records) {
            const recordBytes = record.bytes;
            for (let j = 0; j < byteLength; j++) {
              if (recordBytes[j] !== bytes[inputOffset + j]) {
                continue FIND_CHUNK;
              }
            }
            return record.str;
          }
        return null;
      }
      store(bytes, value) {
        const records = this.caches[bytes.length - 1];
        const record = { bytes, str: value };
        if (records.length >= this.maxLengthPerKey) {
          records[Math.random() * records.length | 0] = record;
        } else {
          records.push(record);
        }
      }
      decode(bytes, inputOffset, byteLength) {
        const cachedValue = this.find(bytes, inputOffset, byteLength);
        if (cachedValue != null) {
          this.hit++;
          return cachedValue;
        }
        this.miss++;
        const str = (0, utf8_1.utf8DecodeJs)(bytes, inputOffset, byteLength);
        const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
        this.store(slicedCopyOfBytes, str);
        return str;
      }
    };
    exports.CachedKeyDecoder = CachedKeyDecoder;
  }
});

// node_modules/@msgpack/msgpack/dist/Decoder.js
var require_Decoder = __commonJS({
  "node_modules/@msgpack/msgpack/dist/Decoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Decoder = exports.DataViewIndexOutOfBoundsError = void 0;
    var prettyByte_1 = require_prettyByte();
    var ExtensionCodec_1 = require_ExtensionCodec();
    var int_1 = require_int();
    var utf8_1 = require_utf8();
    var typedArrays_1 = require_typedArrays();
    var CachedKeyDecoder_1 = require_CachedKeyDecoder();
    var DecodeError_1 = require_DecodeError();
    var isValidMapKeyType = (key) => {
      const keyType = typeof key;
      return keyType === "string" || keyType === "number";
    };
    var HEAD_BYTE_REQUIRED = -1;
    var EMPTY_VIEW = new DataView(new ArrayBuffer(0));
    var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
    exports.DataViewIndexOutOfBoundsError = (() => {
      try {
        EMPTY_VIEW.getInt8(0);
      } catch (e) {
        return e.constructor;
      }
      throw new Error("never reached");
    })();
    var MORE_DATA = new exports.DataViewIndexOutOfBoundsError("Insufficient data");
    var sharedCachedKeyDecoder = new CachedKeyDecoder_1.CachedKeyDecoder();
    var Decoder = class {
      constructor(extensionCodec = ExtensionCodec_1.ExtensionCodec.defaultCodec, context = void 0, maxStrLength = int_1.UINT32_MAX, maxBinLength = int_1.UINT32_MAX, maxArrayLength = int_1.UINT32_MAX, maxMapLength = int_1.UINT32_MAX, maxExtLength = int_1.UINT32_MAX, keyDecoder = sharedCachedKeyDecoder) {
        this.extensionCodec = extensionCodec;
        this.context = context;
        this.maxStrLength = maxStrLength;
        this.maxBinLength = maxBinLength;
        this.maxArrayLength = maxArrayLength;
        this.maxMapLength = maxMapLength;
        this.maxExtLength = maxExtLength;
        this.keyDecoder = keyDecoder;
        this.totalPos = 0;
        this.pos = 0;
        this.view = EMPTY_VIEW;
        this.bytes = EMPTY_BYTES;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack = [];
      }
      reinitializeState() {
        this.totalPos = 0;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack.length = 0;
      }
      setBuffer(buffer) {
        this.bytes = (0, typedArrays_1.ensureUint8Array)(buffer);
        this.view = (0, typedArrays_1.createDataView)(this.bytes);
        this.pos = 0;
      }
      appendBuffer(buffer) {
        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
          this.setBuffer(buffer);
        } else {
          const remainingData = this.bytes.subarray(this.pos);
          const newData = (0, typedArrays_1.ensureUint8Array)(buffer);
          const newBuffer = new Uint8Array(remainingData.length + newData.length);
          newBuffer.set(remainingData);
          newBuffer.set(newData, remainingData.length);
          this.setBuffer(newBuffer);
        }
      }
      hasRemaining(size) {
        return this.view.byteLength - this.pos >= size;
      }
      createExtraByteError(posToShow) {
        const { view, pos } = this;
        return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);
      }
      /**
       * @throws {@link DecodeError}
       * @throws {@link RangeError}
       */
      decode(buffer) {
        this.reinitializeState();
        this.setBuffer(buffer);
        const object = this.doDecodeSync();
        if (this.hasRemaining(1)) {
          throw this.createExtraByteError(this.pos);
        }
        return object;
      }
      *decodeMulti(buffer) {
        this.reinitializeState();
        this.setBuffer(buffer);
        while (this.hasRemaining(1)) {
          yield this.doDecodeSync();
        }
      }
      async decodeAsync(stream) {
        let decoded = false;
        let object;
        for await (const buffer of stream) {
          if (decoded) {
            throw this.createExtraByteError(this.totalPos);
          }
          this.appendBuffer(buffer);
          try {
            object = this.doDecodeSync();
            decoded = true;
          } catch (e) {
            if (!(e instanceof exports.DataViewIndexOutOfBoundsError)) {
              throw e;
            }
          }
          this.totalPos += this.pos;
        }
        if (decoded) {
          if (this.hasRemaining(1)) {
            throw this.createExtraByteError(this.totalPos);
          }
          return object;
        }
        const { headByte, pos, totalPos } = this;
        throw new RangeError(`Insufficient data in parsing ${(0, prettyByte_1.prettyByte)(headByte)} at ${totalPos} (${pos} in the current buffer)`);
      }
      decodeArrayStream(stream) {
        return this.decodeMultiAsync(stream, true);
      }
      decodeStream(stream) {
        return this.decodeMultiAsync(stream, false);
      }
      async *decodeMultiAsync(stream, isArray) {
        let isArrayHeaderRequired = isArray;
        let arrayItemsLeft = -1;
        for await (const buffer of stream) {
          if (isArray && arrayItemsLeft === 0) {
            throw this.createExtraByteError(this.totalPos);
          }
          this.appendBuffer(buffer);
          if (isArrayHeaderRequired) {
            arrayItemsLeft = this.readArraySize();
            isArrayHeaderRequired = false;
            this.complete();
          }
          try {
            while (true) {
              yield this.doDecodeSync();
              if (--arrayItemsLeft === 0) {
                break;
              }
            }
          } catch (e) {
            if (!(e instanceof exports.DataViewIndexOutOfBoundsError)) {
              throw e;
            }
          }
          this.totalPos += this.pos;
        }
      }
      doDecodeSync() {
        DECODE:
          while (true) {
            const headByte = this.readHeadByte();
            let object;
            if (headByte >= 224) {
              object = headByte - 256;
            } else if (headByte < 192) {
              if (headByte < 128) {
                object = headByte;
              } else if (headByte < 144) {
                const size = headByte - 128;
                if (size !== 0) {
                  this.pushMapState(size);
                  this.complete();
                  continue DECODE;
                } else {
                  object = {};
                }
              } else if (headByte < 160) {
                const size = headByte - 144;
                if (size !== 0) {
                  this.pushArrayState(size);
                  this.complete();
                  continue DECODE;
                } else {
                  object = [];
                }
              } else {
                const byteLength = headByte - 160;
                object = this.decodeUtf8String(byteLength, 0);
              }
            } else if (headByte === 192) {
              object = null;
            } else if (headByte === 194) {
              object = false;
            } else if (headByte === 195) {
              object = true;
            } else if (headByte === 202) {
              object = this.readF32();
            } else if (headByte === 203) {
              object = this.readF64();
            } else if (headByte === 204) {
              object = this.readU8();
            } else if (headByte === 205) {
              object = this.readU16();
            } else if (headByte === 206) {
              object = this.readU32();
            } else if (headByte === 207) {
              object = this.readU64();
            } else if (headByte === 208) {
              object = this.readI8();
            } else if (headByte === 209) {
              object = this.readI16();
            } else if (headByte === 210) {
              object = this.readI32();
            } else if (headByte === 211) {
              object = this.readI64();
            } else if (headByte === 217) {
              const byteLength = this.lookU8();
              object = this.decodeUtf8String(byteLength, 1);
            } else if (headByte === 218) {
              const byteLength = this.lookU16();
              object = this.decodeUtf8String(byteLength, 2);
            } else if (headByte === 219) {
              const byteLength = this.lookU32();
              object = this.decodeUtf8String(byteLength, 4);
            } else if (headByte === 220) {
              const size = this.readU16();
              if (size !== 0) {
                this.pushArrayState(size);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else if (headByte === 221) {
              const size = this.readU32();
              if (size !== 0) {
                this.pushArrayState(size);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else if (headByte === 222) {
              const size = this.readU16();
              if (size !== 0) {
                this.pushMapState(size);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte === 223) {
              const size = this.readU32();
              if (size !== 0) {
                this.pushMapState(size);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte === 196) {
              const size = this.lookU8();
              object = this.decodeBinary(size, 1);
            } else if (headByte === 197) {
              const size = this.lookU16();
              object = this.decodeBinary(size, 2);
            } else if (headByte === 198) {
              const size = this.lookU32();
              object = this.decodeBinary(size, 4);
            } else if (headByte === 212) {
              object = this.decodeExtension(1, 0);
            } else if (headByte === 213) {
              object = this.decodeExtension(2, 0);
            } else if (headByte === 214) {
              object = this.decodeExtension(4, 0);
            } else if (headByte === 215) {
              object = this.decodeExtension(8, 0);
            } else if (headByte === 216) {
              object = this.decodeExtension(16, 0);
            } else if (headByte === 199) {
              const size = this.lookU8();
              object = this.decodeExtension(size, 1);
            } else if (headByte === 200) {
              const size = this.lookU16();
              object = this.decodeExtension(size, 2);
            } else if (headByte === 201) {
              const size = this.lookU32();
              object = this.decodeExtension(size, 4);
            } else {
              throw new DecodeError_1.DecodeError(`Unrecognized type byte: ${(0, prettyByte_1.prettyByte)(headByte)}`);
            }
            this.complete();
            const stack = this.stack;
            while (stack.length > 0) {
              const state = stack[stack.length - 1];
              if (state.type === 0) {
                state.array[state.position] = object;
                state.position++;
                if (state.position === state.size) {
                  stack.pop();
                  object = state.array;
                } else {
                  continue DECODE;
                }
              } else if (state.type === 1) {
                if (!isValidMapKeyType(object)) {
                  throw new DecodeError_1.DecodeError("The type of key must be string or number but " + typeof object);
                }
                if (object === "__proto__") {
                  throw new DecodeError_1.DecodeError("The key __proto__ is not allowed");
                }
                state.key = object;
                state.type = 2;
                continue DECODE;
              } else {
                state.map[state.key] = object;
                state.readCount++;
                if (state.readCount === state.size) {
                  stack.pop();
                  object = state.map;
                } else {
                  state.key = null;
                  state.type = 1;
                  continue DECODE;
                }
              }
            }
            return object;
          }
      }
      readHeadByte() {
        if (this.headByte === HEAD_BYTE_REQUIRED) {
          this.headByte = this.readU8();
        }
        return this.headByte;
      }
      complete() {
        this.headByte = HEAD_BYTE_REQUIRED;
      }
      readArraySize() {
        const headByte = this.readHeadByte();
        switch (headByte) {
          case 220:
            return this.readU16();
          case 221:
            return this.readU32();
          default: {
            if (headByte < 160) {
              return headByte - 144;
            } else {
              throw new DecodeError_1.DecodeError(`Unrecognized array type byte: ${(0, prettyByte_1.prettyByte)(headByte)}`);
            }
          }
        }
      }
      pushMapState(size) {
        if (size > this.maxMapLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);
        }
        this.stack.push({
          type: 1,
          size,
          key: null,
          readCount: 0,
          map: {}
        });
      }
      pushArrayState(size) {
        if (size > this.maxArrayLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);
        }
        this.stack.push({
          type: 0,
          size,
          array: new Array(size),
          position: 0
        });
      }
      decodeUtf8String(byteLength, headerOffset) {
        var _a;
        if (byteLength > this.maxStrLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);
        }
        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
          throw MORE_DATA;
        }
        const offset = this.pos + headerOffset;
        let object;
        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {
          object = this.keyDecoder.decode(this.bytes, offset, byteLength);
        } else if (byteLength > utf8_1.TEXT_DECODER_THRESHOLD) {
          object = (0, utf8_1.utf8DecodeTD)(this.bytes, offset, byteLength);
        } else {
          object = (0, utf8_1.utf8DecodeJs)(this.bytes, offset, byteLength);
        }
        this.pos += headerOffset + byteLength;
        return object;
      }
      stateIsMapKey() {
        if (this.stack.length > 0) {
          const state = this.stack[this.stack.length - 1];
          return state.type === 1;
        }
        return false;
      }
      decodeBinary(byteLength, headOffset) {
        if (byteLength > this.maxBinLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);
        }
        if (!this.hasRemaining(byteLength + headOffset)) {
          throw MORE_DATA;
        }
        const offset = this.pos + headOffset;
        const object = this.bytes.subarray(offset, offset + byteLength);
        this.pos += headOffset + byteLength;
        return object;
      }
      decodeExtension(size, headOffset) {
        if (size > this.maxExtLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);
        }
        const extType = this.view.getInt8(this.pos + headOffset);
        const data = this.decodeBinary(
          size,
          headOffset + 1
          /* extType */
        );
        return this.extensionCodec.decode(data, extType, this.context);
      }
      lookU8() {
        return this.view.getUint8(this.pos);
      }
      lookU16() {
        return this.view.getUint16(this.pos);
      }
      lookU32() {
        return this.view.getUint32(this.pos);
      }
      readU8() {
        const value = this.view.getUint8(this.pos);
        this.pos++;
        return value;
      }
      readI8() {
        const value = this.view.getInt8(this.pos);
        this.pos++;
        return value;
      }
      readU16() {
        const value = this.view.getUint16(this.pos);
        this.pos += 2;
        return value;
      }
      readI16() {
        const value = this.view.getInt16(this.pos);
        this.pos += 2;
        return value;
      }
      readU32() {
        const value = this.view.getUint32(this.pos);
        this.pos += 4;
        return value;
      }
      readI32() {
        const value = this.view.getInt32(this.pos);
        this.pos += 4;
        return value;
      }
      readU64() {
        const value = (0, int_1.getUint64)(this.view, this.pos);
        this.pos += 8;
        return value;
      }
      readI64() {
        const value = (0, int_1.getInt64)(this.view, this.pos);
        this.pos += 8;
        return value;
      }
      readF32() {
        const value = this.view.getFloat32(this.pos);
        this.pos += 4;
        return value;
      }
      readF64() {
        const value = this.view.getFloat64(this.pos);
        this.pos += 8;
        return value;
      }
    };
    exports.Decoder = Decoder;
  }
});

// node_modules/@msgpack/msgpack/dist/decode.js
var require_decode2 = __commonJS({
  "node_modules/@msgpack/msgpack/dist/decode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeMulti = exports.decode = exports.defaultDecodeOptions = void 0;
    var Decoder_1 = require_Decoder();
    exports.defaultDecodeOptions = {};
    function decode(buffer, options = exports.defaultDecodeOptions) {
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decode(buffer);
    }
    exports.decode = decode;
    function decodeMulti(buffer, options = exports.defaultDecodeOptions) {
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeMulti(buffer);
    }
    exports.decodeMulti = decodeMulti;
  }
});

// node_modules/@msgpack/msgpack/dist/utils/stream.js
var require_stream2 = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ensureAsyncIterable = exports.asyncIterableFromStream = exports.isAsyncIterable = void 0;
    function isAsyncIterable(object) {
      return object[Symbol.asyncIterator] != null;
    }
    exports.isAsyncIterable = isAsyncIterable;
    function assertNonNull(value) {
      if (value == null) {
        throw new Error("Assertion Failure: value must not be null nor undefined");
      }
    }
    async function* asyncIterableFromStream(stream) {
      const reader = stream.getReader();
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            return;
          }
          assertNonNull(value);
          yield value;
        }
      } finally {
        reader.releaseLock();
      }
    }
    exports.asyncIterableFromStream = asyncIterableFromStream;
    function ensureAsyncIterable(streamLike) {
      if (isAsyncIterable(streamLike)) {
        return streamLike;
      } else {
        return asyncIterableFromStream(streamLike);
      }
    }
    exports.ensureAsyncIterable = ensureAsyncIterable;
  }
});

// node_modules/@msgpack/msgpack/dist/decodeAsync.js
var require_decodeAsync = __commonJS({
  "node_modules/@msgpack/msgpack/dist/decodeAsync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeStream = exports.decodeMultiStream = exports.decodeArrayStream = exports.decodeAsync = void 0;
    var Decoder_1 = require_Decoder();
    var stream_1 = require_stream2();
    var decode_1 = require_decode2();
    async function decodeAsync(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = (0, stream_1.ensureAsyncIterable)(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeAsync(stream);
    }
    exports.decodeAsync = decodeAsync;
    function decodeArrayStream(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = (0, stream_1.ensureAsyncIterable)(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeArrayStream(stream);
    }
    exports.decodeArrayStream = decodeArrayStream;
    function decodeMultiStream(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = (0, stream_1.ensureAsyncIterable)(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeStream(stream);
    }
    exports.decodeMultiStream = decodeMultiStream;
    function decodeStream(streamLike, options = decode_1.defaultDecodeOptions) {
      return decodeMultiStream(streamLike, options);
    }
    exports.decodeStream = decodeStream;
  }
});

// node_modules/@msgpack/msgpack/dist/index.js
var require_dist = __commonJS({
  "node_modules/@msgpack/msgpack/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeTimestampExtension = exports.encodeTimestampExtension = exports.decodeTimestampToTimeSpec = exports.encodeTimeSpecToTimestamp = exports.encodeDateToTimeSpec = exports.EXT_TIMESTAMP = exports.ExtData = exports.ExtensionCodec = exports.Encoder = exports.DataViewIndexOutOfBoundsError = exports.DecodeError = exports.Decoder = exports.decodeStream = exports.decodeMultiStream = exports.decodeArrayStream = exports.decodeAsync = exports.decodeMulti = exports.decode = exports.encode = void 0;
    var encode_1 = require_encode();
    Object.defineProperty(exports, "encode", { enumerable: true, get: function() {
      return encode_1.encode;
    } });
    var decode_1 = require_decode2();
    Object.defineProperty(exports, "decode", { enumerable: true, get: function() {
      return decode_1.decode;
    } });
    Object.defineProperty(exports, "decodeMulti", { enumerable: true, get: function() {
      return decode_1.decodeMulti;
    } });
    var decodeAsync_1 = require_decodeAsync();
    Object.defineProperty(exports, "decodeAsync", { enumerable: true, get: function() {
      return decodeAsync_1.decodeAsync;
    } });
    Object.defineProperty(exports, "decodeArrayStream", { enumerable: true, get: function() {
      return decodeAsync_1.decodeArrayStream;
    } });
    Object.defineProperty(exports, "decodeMultiStream", { enumerable: true, get: function() {
      return decodeAsync_1.decodeMultiStream;
    } });
    Object.defineProperty(exports, "decodeStream", { enumerable: true, get: function() {
      return decodeAsync_1.decodeStream;
    } });
    var Decoder_1 = require_Decoder();
    Object.defineProperty(exports, "Decoder", { enumerable: true, get: function() {
      return Decoder_1.Decoder;
    } });
    Object.defineProperty(exports, "DataViewIndexOutOfBoundsError", { enumerable: true, get: function() {
      return Decoder_1.DataViewIndexOutOfBoundsError;
    } });
    var DecodeError_1 = require_DecodeError();
    Object.defineProperty(exports, "DecodeError", { enumerable: true, get: function() {
      return DecodeError_1.DecodeError;
    } });
    var Encoder_1 = require_Encoder();
    Object.defineProperty(exports, "Encoder", { enumerable: true, get: function() {
      return Encoder_1.Encoder;
    } });
    var ExtensionCodec_1 = require_ExtensionCodec();
    Object.defineProperty(exports, "ExtensionCodec", { enumerable: true, get: function() {
      return ExtensionCodec_1.ExtensionCodec;
    } });
    var ExtData_1 = require_ExtData();
    Object.defineProperty(exports, "ExtData", { enumerable: true, get: function() {
      return ExtData_1.ExtData;
    } });
    var timestamp_1 = require_timestamp();
    Object.defineProperty(exports, "EXT_TIMESTAMP", { enumerable: true, get: function() {
      return timestamp_1.EXT_TIMESTAMP;
    } });
    Object.defineProperty(exports, "encodeDateToTimeSpec", { enumerable: true, get: function() {
      return timestamp_1.encodeDateToTimeSpec;
    } });
    Object.defineProperty(exports, "encodeTimeSpecToTimestamp", { enumerable: true, get: function() {
      return timestamp_1.encodeTimeSpecToTimestamp;
    } });
    Object.defineProperty(exports, "decodeTimestampToTimeSpec", { enumerable: true, get: function() {
      return timestamp_1.decodeTimestampToTimeSpec;
    } });
    Object.defineProperty(exports, "encodeTimestampExtension", { enumerable: true, get: function() {
      return timestamp_1.encodeTimestampExtension;
    } });
    Object.defineProperty(exports, "decodeTimestampExtension", { enumerable: true, get: function() {
      return timestamp_1.decodeTimestampExtension;
    } });
  }
});

// node_modules/obs-websocket-js/dist/msgpack.cjs
var require_msgpack = __commonJS({
  "node_modules/obs-websocket-js/dist/msgpack.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _class;
    var _chunkRL7MGYX4cjs = require_chunk_RL7MGYX4();
    var _msgpack = require_dist();
    var OBSWebSocket2 = (_class = class extends _chunkRL7MGYX4cjs.BaseOBSWebSocket {
      constructor(...args) {
        super(...args);
        _class.prototype.__init.call(this);
      }
      __init() {
        this.protocol = "obswebsocket.msgpack";
      }
      async encodeMessage(data) {
        return _msgpack.encode.call(void 0, data);
      }
      async decodeMessage(data) {
        if (typeof Blob !== "undefined" && data instanceof Blob) {
          data = await data.arrayBuffer();
        }
        return _msgpack.decode.call(void 0, data);
      }
    }, _class);
    var msgpack_default = OBSWebSocket2;
    exports.EventSubscription = _chunkRL7MGYX4cjs.EventSubscription;
    exports.OBSWebSocket = OBSWebSocket2;
    exports.OBSWebSocketError = _chunkRL7MGYX4cjs.OBSWebSocketError;
    exports.RequestBatchExecutionType = _chunkRL7MGYX4cjs.RequestBatchExecutionType;
    exports.WebSocketOpCode = _chunkRL7MGYX4cjs.WebSocketOpCode;
    exports.default = msgpack_default;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => uuhimsyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// settings.ts
var import_obsidian = require("obsidian");
var uuhimsySettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("OBS WebSocket Server").setHeading().setDesc("Set the OBS Websocket Server Settings");
    new import_obsidian.Setting(containerEl).setName("IP").setDesc("Enter the IP address or 'localhost'").addText((item) => {
      item.setValue(this.plugin.settings.websocketIP_Text).onChange(
        (value) => {
          this.plugin.settings.websocketIP_Text = value;
          this.plugin.saveSettings();
          refresh_websocketDetailsJS(this);
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("PORT").addText((item) => {
      item.setValue(this.plugin.settings.websocketPort_Text).onChange(
        (value) => {
          this.plugin.settings.websocketPort_Text = value;
          this.plugin.saveSettings();
          refresh_websocketDetailsJS(this);
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("Password").addText((item) => {
      item.setValue(this.plugin.settings.websocketPW_Text).onChange(
        (value) => {
          this.plugin.settings.websocketPW_Text = value;
          this.plugin.saveSettings();
          refresh_websocketDetailsJS(this);
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("OBS Launch Parameters").setHeading().setDesc("Open OBS with these options.");
    if (process.platform === "darwin") {
      new import_obsidian.Setting(containerEl).setName("Name").setDesc("Enter 'OBS' or a custom name").addText((item) => {
        item.setValue(this.plugin.settings.obsAppName_Text).onChange(
          (value) => {
            this.plugin.settings.obsAppName_Text = value;
            this.plugin.saveSettings();
          }
        );
      });
    }
    if (process.platform === "win32") {
      new import_obsidian.Setting(containerEl).setName("Name").setDesc("Enter 'obs64.exe' or a custom name").addText((item) => {
        item.setValue(this.plugin.settings.obsAppName_Text).onChange(
          (value) => {
            this.plugin.settings.obsAppName_Text = value;
            this.plugin.saveSettings();
          }
        );
      });
      new import_obsidian.Setting(containerEl).setName("Path to OBS app").addText((item) => {
        item.setValue(this.plugin.settings.obsAppPath_Text).onChange(
          (value) => {
            this.plugin.settings.obsAppPath_Text = value;
            this.plugin.saveSettings();
          }
        );
      });
    }
    new import_obsidian.Setting(containerEl).setName("Collection").addText((item) => {
      item.setValue(this.plugin.settings.obsCollection_Text).onChange(
        (value) => {
          this.plugin.settings.obsCollection_Text = value;
          this.plugin.saveSettings();
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("OBS Browser Source Debug Port").setDesc("Enter a Port for the Remote Debugger, or leave blank to skip this option").addText((item) => {
      item.setValue(this.plugin.settings.obsDebugPort_Text).onChange(
        (value) => {
          this.plugin.settings.obsDebugPort_Text = value;
          this.plugin.saveSettings();
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("OSC Server").setHeading();
    new import_obsidian.Setting(containerEl).setName("IP").setDesc("Enter the IP address or 'localhost'").addText((item) => {
      item.setValue(this.plugin.settings.oscIP_Text).onChange(
        (value) => {
          this.plugin.settings.oscIP_Text = value;
          this.plugin.saveSettings();
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("Incoming Message PORT").addText((item) => {
      item.setValue(this.plugin.settings.oscInPort_Text).onChange(
        (value) => {
          this.plugin.settings.oscInPort_Text = value;
          this.plugin.saveSettings();
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("Out going Message PORT").addText((item) => {
      item.setValue(this.plugin.settings.oscOutPort_Text).onChange(
        (value) => {
          this.plugin.settings.oscOutPort_Text = value;
          this.plugin.saveSettings();
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("Add UUhimsy scripts to Slides Extended Template").setHeading().setDesc("UUhimsy scripts will be included when exporting Slides Extended slides").addButton((button) => {
      button.setButtonText("Add UUhimsy scripts to Slides Extended Template").setTooltip("UUhimsy scripts are included when exporting from Slides Extended").setCta().onClick(async () => {
        const fileName = `.obsidian/plugins/slides-extended/template/reveal.html`;
        const existing = await this.app.vault.adapter.exists((0, import_obsidian.normalizePath)(`${fileName}`));
        if (existing) {
          let file = await this.app.vault.adapter.read((0, import_obsidian.normalizePath)(`${fileName}`));
          if (file.includes(`<script src="/_browser_Sources/js/revealSlideControls.js"></script>`)) {
            console.log("template already includes uuhimsy scripts");
          } else {
            console.log("adding scripts");
            return await this.app.vault.adapter.process((0, import_obsidian.normalizePath)(`${fileName}`), (data) => {
              return data.replace("</body>", `    <script src="/_browser_Sources/obs_webSocket_details/websocketDetails.js"></script>
    <script src="/_browser_Sources/obs_webSocket_details/obs-ws.js"></script>
    <script src="/_browser_Sources/obs_webSocket_details/obsConnect.js"></script>
    <script src="/_browser_Sources/obs_webSocket_details/startConnection.js"></script>
    <script src="/_browser_Sources/js/revealSlideControls.js"></script>
</body>`);
            });
          }
        }
      });
    });
    async function refresh_websocketDetailsJS(obsidian) {
      const fileName = `_browser_Sources/obs_webSocket_details/websocketDetails.js`;
      const existing = await obsidian.app.vault.adapter.exists((0, import_obsidian.normalizePath)(`${fileName}`));
      if (!existing) {
        await obsidian.app.vault.create(
          `${fileName}`,
          `var wssDetails = {
                    "IP":"${obsidian.plugin.settings.websocketIP_Text}",
                    "PORT":"${obsidian.plugin.settings.websocketPort_Text}",
                    "PW":"${obsidian.plugin.settings.websocketPW_Text}"
                };`
        );
      } else {
        await obsidian.app.vault.delete(obsidian.app.vault.getFileByPath(fileName));
        await obsidian.app.vault.create(
          `${fileName}`,
          `var wssDetails = {
    "IP":"${obsidian.plugin.settings.websocketIP_Text}",
    "PORT":"${obsidian.plugin.settings.websocketPort_Text}",
    "PW":"${obsidian.plugin.settings.websocketPW_Text}"
};`
        );
      }
    }
  }
};

// suggest.ts
var import_obsidian2 = require("obsidian");
var UUhimsyEntranceSuggest = class extends import_obsidian2.FuzzySuggestModal {
  getItems() {
    const files = this.app.vault.getMarkdownFiles();
    const choices = files.filter((file) => {
      return file.basename.startsWith("Entrance");
    });
    return choices;
  }
  getItemText(item) {
    return item.basename;
  }
  async onChooseItem(item, evt) {
    var _a, _b;
    (_b = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.editor) == null ? void 0 : _b.replaceSelection(await this.app.vault.read(item));
  }
};
var UUhimsyExitSuggest = class extends import_obsidian2.FuzzySuggestModal {
  getItems() {
    const files = this.app.vault.getMarkdownFiles();
    const choices = files.filter((file) => {
      return file.basename.startsWith("Exit");
    });
    return choices;
  }
  getItemText(item) {
    return item.basename;
  }
  async onChooseItem(item, evt) {
    var _a, _b;
    (_b = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.editor) == null ? void 0 : _b.replaceSelection(await this.app.vault.read(item));
  }
};

// main.ts
var { execSync } = require("child_process");
var { Client, Server, Message } = require_lib2();
var OBSWebSocket = require_msgpack().default;
var DEFAULT_SETTINGS = {
  websocketIP_Text: "localhost",
  websocketPort_Text: "4455",
  websocketPW_Text: "password",
  oscIP_Text: "localhost",
  oscInPort_Text: "4466",
  oscOutPort_Text: "4477",
  obsAppName_Text: "OBS",
  obsAppPath_Text: "C:\\\\Program Files\\\\obs-studio\\\\bin\\\\64bit\\\\",
  obsCollection_Text: "Key_and_Mouse_Visuals_Collection",
  obsDebug_Text: "Y",
  obsDebugPort_Text: "9222"
};
var uuhimsyPlugin = class extends import_obsidian3.Plugin {
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    this.saveData(this.settings);
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new uuhimsySettingsTab(this.app, this));
    new import_obsidian3.Notice("Enabled OSC plugin");
    new import_obsidian3.Notice(this.settings.websocketIP_Text);
    new import_obsidian3.Notice(this.app.vault.configDir);
    this.addCommand({
      id: "start-osc-to-websocket",
      name: "Start OSC to OBS Websocket connection",
      callback: () => {
        new import_obsidian3.Notice("Starting OSC Server");
        var websocketIP = this.settings.websocketIP_Text;
        var websocketPort = this.settings.websocketPort_Text;
        var websocketPassword = this.settings.websocketPW_Text;
        var oscIP = this.settings.oscIP_Text;
        var oscInPORT = this.settings.oscInPort_Text;
        var oscOutPORT = this.settings.oscOutPort_Text;
        setOSCconnection(
          websocketIP,
          websocketPort,
          websocketPassword,
          oscIP,
          oscInPORT,
          oscOutPORT
        );
        async function setOSCconnection(websocketIP2, websocketPort2, websocketPassword2, oscIP2, oscInPORT2, oscOutPORT2) {
          const obs = new OBSWebSocket(websocketIP2, websocketPort2, websocketPassword2);
          try {
            const { obsWebSocketVersion, negotiatedRpcVersion } = await obs.connect(
              `ws://${websocketIP2}:${websocketPort2}`,
              websocketPassword2,
              {
                rpcVersion: 1
              }
            );
            console.log(
              `Connected to server ${obsWebSocketVersion} (using RPC ${negotiatedRpcVersion})`
            );
            new import_obsidian3.Notice("Connected to OBS WebSocket Server");
            initWebsocketFunctions();
          } catch (error) {
            new import_obsidian3.Notice("Failed to connect to OBS WebSocket Server");
            console.error("Failed to connect", error.code, error.message);
          }
          function initWebsocketFunctions() {
            obs.on("error", (err) => {
              console.error("Socket error:", err);
            });
            console.log(`ws://${websocketIP2}:${websocketPort2}`);
            var oscServer = new Server(oscInPORT2, oscIP2);
            oscServer.on("listening", () => {
              console.log("OSC Server is listening.");
            });
            oscServer.on("message", (msg) => {
              console.log(`Message: ${msg}`);
              sendToOBS(msg, obs, "osc-message");
            });
            function sendToOBS(msgParam, obsParam, eventName) {
              console.log("sending message:", JSON.stringify(msgParam));
              const webSocketMessage = JSON.stringify(msgParam);
              obsParam.call("CallVendorRequest", {
                vendorName: "obs-browser",
                requestType: "emit_event",
                requestData: {
                  event_name: eventName,
                  event_data: { webSocketMessage }
                }
              });
            }
          }
          const oscClient = new Client(oscIP2, oscOutPORT2);
          console.log("oscClient", oscClient, oscIP2, oscOutPORT2, oscInPORT2);
          obs.on("CustomEvent", function(event) {
            console.log("Message from OBS", event);
            if (event.event_name === "OSC-out") {
              const message = new Message(event.address);
              if (Object.hasOwn(event, "arg1")) {
                message.append(event.arg1);
                console.log("arg1", message);
              }
              if (Object.hasOwn(event, "arg2")) {
                message.append(event.arg2);
                console.log(message);
              }
              if (Object.hasOwn(event, "arg3")) {
                message.append(event.arg3);
                console.log(message);
              }
              if (Object.hasOwn(event, "arg4")) {
                message.append(event.arg4);
                console.log(message);
              }
              if (Object.hasOwn(event, "arg5")) {
                message.append(event.arg5);
                console.log(message);
              }
              if (Object.hasOwn(event, "arg6")) {
                message.append(event.arg6);
                console.log(message);
              }
              if (Object.hasOwn(event, "arg7")) {
                message.append(event.arg7);
                console.log(message);
              }
              console.log("message to OSC device", message);
              oscClient.send(message, (err) => {
                if (err) {
                  console.error(new Error(err));
                }
              });
            }
          });
        }
      }
    });
    this.addCommand({
      id: "get-obs-scene-tags",
      name: "Get OBS Scene tags",
      callback: async () => {
        new import_obsidian3.Notice("Get OBS Scenes");
        var websocketIP = this.settings.websocketIP_Text;
        var websocketPort = this.settings.websocketPort_Text;
        var websocketPassword = this.settings.websocketPW_Text;
        const obs = new OBSWebSocket(websocketIP, websocketPort, websocketPassword);
        try {
          const { obsWebSocketVersion, negotiatedRpcVersion } = await obs.connect(
            `ws://${websocketIP}:${websocketPort}`,
            websocketPassword,
            {
              rpcVersion: 1
            }
          );
          console.log(
            `Connected to server ${obsWebSocketVersion} (using RPC ${negotiatedRpcVersion})`
          );
          new import_obsidian3.Notice("Connected to OBS WebSocket Server");
        } catch (error) {
          new import_obsidian3.Notice("Failed to connect to OBS WebSocket Server");
          console.error("Failed to connect", error.code, error.message);
        }
        obs.on("error", (err) => {
          console.error("Socket error:", err);
        });
        console.log(`ws://${websocketIP}:${websocketPort}`);
        const sceneList = await obs.call("GetSceneList");
        console.log(sceneList);
        sceneList.scenes.forEach(async (scene, index) => {
          if (scene.sceneName.startsWith("scene|||")) {
            const sceneName = scene.sceneName.split("|||");
            let fileName = `Entrance Scene - ${sceneName[1]}`;
            let existing = await this.app.vault.adapter.exists((0, import_obsidian3.normalizePath)(`_slide_Tags/${fileName}`));
            if (!existing) {
              await this.app.vault.create(
                `_slide_Tags/${fileName}.md`,
                `<!-- slide data-scene-entrance="${sceneName[1]}" --> `
              );
            }
            fileName = `Exit Scene - ${sceneName[1]}`;
            existing = await this.app.vault.adapter.exists((0, import_obsidian3.normalizePath)(`_slide_Tags/${fileName}`));
            if (!existing) {
              await this.app.vault.create(
                `_slide_Tags/${fileName}.md`,
                `<!-- slide data-scene-exit="${sceneName[1]}" --> `
              );
            }
          }
        });
        let cameraSources = await obs.call("GetSceneItemList", { sceneName: "Input Camera" });
        cameraSources.sceneItems.forEach(async (source, index) => {
          let fileName = `Entrance Camera - ${source.sourceName}`;
          let existing = await this.app.vault.adapter.exists((0, import_obsidian3.normalizePath)(`_slide_Tags/${fileName}`));
          if (!existing) {
            await this.app.vault.create(
              `_slide_Tags/${fileName}.md`,
              `<!-- slide data-camera-entrance="${source.sourceName}" --> `
            );
          }
          fileName = `Exit Camera - ${source.sourceName}`;
          existing = await this.app.vault.adapter.exists((0, import_obsidian3.normalizePath)(`_slide_Tags/${fileName}`));
          if (!existing) {
            await this.app.vault.create(
              `_slide_Tags/${fileName}.md`,
              `<!-- slide data-camera-exit="${source.sourceName}" --> `
            );
          }
        });
      }
    });
    this.addCommand({
      id: "insert-entrance-tag",
      name: "Insert slide entrance tag",
      editorCallback: (editor, view) => {
        new UUhimsyEntranceSuggest(this.app).open();
      }
    });
    this.addCommand({
      id: "insert-exit-tag",
      name: "Insert slide exit tag",
      editorCallback: (editor, view) => {
        new UUhimsyExitSuggest(this.app).open();
      }
    });
    this.addCommand({
      id: "send-camera-position-to-obs",
      name: "Start sending camera PTZ position to OBS",
      checkCallback: async (checking) => {
        let isMac = process.platform === "darwin";
        if (isMac) {
          if (!checking) {
            console.log("true");
            var websocketIP = this.settings.websocketIP_Text;
            var websocketPort = this.settings.websocketPort_Text;
            var websocketPassword = this.settings.websocketPW_Text;
            const obs = new OBSWebSocket(websocketIP, websocketPort, websocketPassword);
            try {
              const { obsWebSocketVersion, negotiatedRpcVersion } = await obs.connect(
                `ws://${websocketIP}:${websocketPort}`,
                websocketPassword,
                {
                  rpcVersion: 1
                }
              );
              console.log(
                `Connected to server ${obsWebSocketVersion} (using RPC ${negotiatedRpcVersion})`
              );
              new import_obsidian3.Notice("Connected to OBS WebSocket Server");
            } catch (error) {
              new import_obsidian3.Notice("Failed to connect to OBS WebSocket Server");
              console.error("Failed to connect", error.code, error.message);
            }
            obs.on("error", (err) => {
              console.error("Socket error:", err);
            });
            console.log(`ws://${websocketIP}:${websocketPort}`);
            const vaultPath = (0, import_obsidian3.normalizePath)(`${this.app.vault.adapter.basePath}/${this.app.vault.configDir}/plugins/UUhimsyPlugin`);
            const util = require("util");
            const exec = util.promisify(require("child_process").exec);
            let previousPTZ = "";
            setInterval(async () => {
              let pt = await getCameraPanTilt(vaultPath, util, exec);
              let z = await getCameraZoom(vaultPath, util, exec);
              let ptzMessage = `${pt}${z}}`;
              if (ptzMessage != previousPTZ) {
                previousPTZ = ptzMessage;
                await obs.call("SetInputSettings", {
                  inputName: "PTZ values",
                  inputSettings: {
                    text: `${ptzMessage}`
                  }
                });
                obs.call("CallVendorRequest", {
                  vendorName: "obs-browser",
                  requestType: "emit_event",
                  requestData: {
                    event_name: "ptz-message",
                    event_data: { ptzMessage }
                  }
                });
              }
            }, 2e3);
            async function getCameraPanTilt(vaultPath2, util2, exec2) {
              try {
                console.log(vaultPath2);
                const { stdout, stderr } = await exec2(`'${vaultPath2}/uvc-util' -I 0 -o pan-tilt-abs`);
                let ptResult = stdout.toString();
                ptResult = ptResult.replace(/\n/g, "").replace("pan", '"pan"').replace("}", ', "zoom": ').replace(/=/g, ": ").replace("tilt", '"tilt"');
                return ptResult;
              } catch (e) {
                console.error(e);
              }
            }
            async function getCameraZoom(vaultPath2, util2, exec2) {
              try {
                const { stdout, stderr } = await exec2(`'${vaultPath2}/uvc-util' -I 0 -o zoom-abs`);
                return stdout.replace(/\n/g, "");
              } catch (e) {
                console.error(e);
              }
            }
            obs.on("CustomEvent", async function(event) {
              console.log("Message from OBS", event);
              if (event.event_name === "set-ptz") {
                console.log("command", `'shortcuts' run ${event.shortcut_name}`);
                const stdout = await exec(`'${vaultPath}/uvc-util' -I 0 -o pan-tilt-abs`);
                console.log(stdout);
              }
            });
          }
          return true;
        }
        return false;
      }
      //end get PTZ command	
    });
    this.addCommand({
      id: "stop-camera-position-to-obs",
      name: "Stop sending camera PTZ position to OBS",
      callback: () => {
        var highestTimeoutId = setTimeout(";");
        for (var i = 0; i < highestTimeoutId; i++) {
          clearTimeout(i);
        }
      }
    });
    this.addCommand({
      id: "get-shortcuts-tags",
      name: "Get Apple Shortcuts tags",
      checkCallback: async (checking) => {
        let isMac = process.platform === "darwin";
        if (isMac) {
          if (!checking) {
            const util = require("util");
            const exec = util.promisify(require("child_process").exec);
            const { stdout, stderr } = await exec(`'shortcuts' list`);
            let shortcuts = stdout.split("\n");
            shortcuts = shortcuts.filter((shortcut) => {
              return shortcut.toLowerCase().startsWith("uuhimsy");
            });
            console.log(shortcuts);
            console.log(typeof shortcuts);
            Object.entries(shortcuts).forEach(async ([key, shortcut]) => {
              let fileName = `Entrance Shortcuts - ${shortcut}.md`;
              let existing = await this.app.vault.adapter.exists((0, import_obsidian3.normalizePath)(`_slide_Tags/${fileName}`));
              if (!existing) {
                await this.app.vault.create(
                  `_slide_Tags/${fileName}`,
                  `<!-- slide data-shortcut-entrance="${shortcut}" --> `
                );
              }
              fileName = `Exit Shortcuts - ${shortcut}.md`;
              existing = await this.app.vault.adapter.exists((0, import_obsidian3.normalizePath)(`_slide_Tags/${fileName}`));
              console.log(fileName);
              console.log("existing", existing);
              if (!existing) {
                await this.app.vault.create(
                  `_slide_Tags/${fileName}`,
                  `<!-- slide data-shortcut-exit="${shortcut}" --> `
                );
              }
            });
          }
          ;
        }
      }
    });
    this.addCommand({
      id: "run-apple-shortcut",
      name: "Run Apple Shortcut",
      callback: async () => {
        var websocketIP = this.settings.websocketIP_Text;
        var websocketPort = this.settings.websocketPort_Text;
        var websocketPassword = this.settings.websocketPW_Text;
        const obs = new OBSWebSocket(websocketIP, websocketPort, websocketPassword);
        try {
          const { obsWebSocketVersion, negotiatedRpcVersion } = await obs.connect(
            `ws://${websocketIP}:${websocketPort}`,
            websocketPassword,
            {
              rpcVersion: 1
            }
          );
          console.log(
            `Connected to server ${obsWebSocketVersion} (using RPC ${negotiatedRpcVersion})`
          );
          new import_obsidian3.Notice("Connected to OBS WebSocket Server");
        } catch (error) {
          new import_obsidian3.Notice("Failed to connect to OBS WebSocket Server");
          console.error("Failed to connect", error.code, error.message);
        }
        obs.on("error", (err) => {
          console.error("Socket error:", err);
        });
        console.log(`ws://${websocketIP}:${websocketPort}`);
        obs.on("CustomEvent", async function(event) {
          if (event.event_name === "run-shortcut") {
            console.log("message from OBS", event);
            console.log(JSON.stringify(event.event_data));
            await obs.call("SetInputSettings", {
              inputName: "CommandText",
              inputSettings: {
                text: `${event.event_name} ${event.event_data.shortcut_name}`
              }
            });
            console.log("command", `'shortcuts' run ${event.event_data.shortcut_name}`);
            let stdout;
            if (Object.hasOwn(event, "event.event_data.shortcut_input")) {
              stdout = execSync(`'shortcuts' run "${event.event_data.shortcut_name}" <<< "${event.event_data.shortcut_input}"`, { encoding: "utf8" });
            } else {
              stdout = execSync(`'shortcuts' run "${event.event_data.shortcut_name}"`, { encoding: "utf8" });
            }
            console.log("shortcut result ", stdout);
            await obs.call("SetInputSettings", {
              inputName: "CommandResultsText",
              inputSettings: {
                text: `${stdout}`
              }
            });
          }
        });
      }
    });
    this.addCommand(
      {
        id: "open-obs",
        name: "Open OBS",
        callback: async () => {
          const util = require("util");
          const exec = util.promisify(require("child_process").exec);
          let commandString = "hello";
          if (process.platform === "darwin") {
            commandString = `open -n -a "${this.settings.obsAppName_Text}"`;
            commandString += ` --args --collection "${this.settings.obsCollection_Text}"`;
            commandString += ` --remote-debugging-port=${this.settings.obsDebugPort_Text}`;
            commandString += ` --remote-allow-origins=http://localhost:${this.settings.obsDebugPort_Text}`;
            commandString += ` --websocket_port "${this.settings.websocketPort_Text}"`;
            commandString += ` --websocket_password "${this.settings.websocketPW_Text}"`;
            commandString += ` --multi`;
            exec(commandString);
          }
          if (process.platform === "win32") {
            const path = require("path");
            const obsPath = `${this.settings.obsAppPath_Text}${this.settings.obsAppName_Text}`;
            const obsDir = path.dirname(obsPath);
            process.chdir(obsDir);
            commandString = `${this.settings.obsAppName_Text}`;
            commandString += ` --args --collection "${this.settings.obsCollection_Text}"`;
            commandString += ` --remote-debugging-port=${this.settings.obsDebugPort_Text}`;
            commandString += ` --remote-allow-origins=http://localhost:${this.settings.obsDebugPort_Text}`;
            commandString += ` --websocket_port "${this.settings.websocketPort_Text}"`;
            commandString += ` --websocket_password "${this.settings.websocketPW_Text}"`;
            commandString += ` --multi`;
            exec(commandString, (error, stdout, stderr) => {
              if (error) {
                console.error(`exec error: ${error}`);
                return;
              }
              console.log(`stdout: ${stdout}`);
              console.error(`stderr: ${stderr}`);
            });
          }
          console.log(commandString);
        }
      }
    );
  }
  onunload() {
    new import_obsidian3.Notice("Disabled UUhimsy plugin");
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL25vZGUtb3NjL2Rpc3QvbGliL01lc3NhZ2UuanMiLCAibm9kZV9tb2R1bGVzL25vZGUtb3NjL2Rpc3QvbGliL0J1bmRsZS5qcyIsICJub2RlX21vZHVsZXMvYmlucGFjay9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvb3NjLW1pbi9saWIvb3NjLXV0aWxpdGllcy5qcyIsICJub2RlX21vZHVsZXMvb3NjLW1pbi9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL25vZGUtb3NjL2Rpc3QvbGliL2ludGVybmFsL2RlY29kZS5qcyIsICJub2RlX21vZHVsZXMvbm9kZS1vc2MvZGlzdC9saWIvU2VydmVyLmpzIiwgIm5vZGVfbW9kdWxlcy9ub2RlLW9zYy9kaXN0L2xpYi9DbGllbnQuanMiLCAibm9kZV9tb2R1bGVzL25vZGUtb3NjL2Rpc3QvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsICJub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCAibm9kZV9tb2R1bGVzL2hhcy1mbGFnL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9zdXBwb3J0cy1jb2xvci9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanMiLCAibm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL2NvbnN0YW50cy5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL2J1ZmZlci11dGlsLmpzIiwgIm5vZGVfbW9kdWxlcy93cy9saWIvbGltaXRlci5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL3ZhbGlkYXRpb24uanMiLCAibm9kZV9tb2R1bGVzL3dzL2xpYi9yZWNlaXZlci5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL3NlbmRlci5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL2V2ZW50LXRhcmdldC5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL2V4dGVuc2lvbi5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL3N0cmVhbS5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL3N1YnByb3RvY29sLmpzIiwgIm5vZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LXNlcnZlci5qcyIsICJub2RlX21vZHVsZXMvd3MvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2lzb21vcnBoaWMtd3Mvbm9kZS5qcyIsICJub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanMiLCAibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEyNTYuanMiLCAibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtYmFzZTY0LmpzIiwgIm5vZGVfbW9kdWxlcy9vYnMtd2Vic29ja2V0LWpzL2Rpc3QvZDovcHJvamVjdHMvb2JzLXdlYnNvY2tldC1qcy9kaXN0L2NodW5rLVJMN01HWVg0LmNqcyIsICJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9zcmMvdXRpbHMvaW50LnRzIiwgIm5vZGVfbW9kdWxlcy9AbXNncGFjay9tc2dwYWNrL3NyYy91dGlscy91dGY4LnRzIiwgIm5vZGVfbW9kdWxlcy9AbXNncGFjay9tc2dwYWNrL3NyYy9FeHREYXRhLnRzIiwgIm5vZGVfbW9kdWxlcy9AbXNncGFjay9tc2dwYWNrL3NyYy9EZWNvZGVFcnJvci50cyIsICJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9zcmMvdGltZXN0YW1wLnRzIiwgIm5vZGVfbW9kdWxlcy9AbXNncGFjay9tc2dwYWNrL3NyYy9FeHRlbnNpb25Db2RlYy50cyIsICJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9zcmMvdXRpbHMvdHlwZWRBcnJheXMudHMiLCAibm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svc3JjL0VuY29kZXIudHMiLCAibm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svc3JjL2VuY29kZS50cyIsICJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9zcmMvdXRpbHMvcHJldHR5Qnl0ZS50cyIsICJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9zcmMvQ2FjaGVkS2V5RGVjb2Rlci50cyIsICJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9zcmMvRGVjb2Rlci50cyIsICJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9zcmMvZGVjb2RlLnRzIiwgIm5vZGVfbW9kdWxlcy9AbXNncGFjay9tc2dwYWNrL3NyYy91dGlscy9zdHJlYW0udHMiLCAibm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svc3JjL2RlY29kZUFzeW5jLnRzIiwgIm5vZGVfbW9kdWxlcy9AbXNncGFjay9tc2dwYWNrL3NyYy9pbmRleC50cyIsICJub2RlX21vZHVsZXMvb2JzLXdlYnNvY2tldC1qcy9kaXN0L2Q6L3Byb2plY3RzL29icy13ZWJzb2NrZXQtanMvZGlzdC9tc2dwYWNrLmNqcyIsICJtYWluLnRzIiwgInNldHRpbmdzLnRzIiwgInN1Z2dlc3QudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdHlwZVRhZ3MgPSB7XG4gIHM6ICdzdHJpbmcnLFxuICBmOiAnZmxvYXQnLFxuICBpOiAnaW50ZWdlcicsXG4gIGI6ICdibG9iJ1xufTtcblxuY2xhc3MgQXJndW1lbnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCB2YWx1ZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG59XG5cbmNsYXNzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCAuLi5hcmdzKSB7XG4gICAgdGhpcy5vc2NUeXBlID0gJ21lc3NhZ2UnO1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgfVxuICBcbiAgYXBwZW5kKGFyZykge1xuICAgIGxldCBhcmdPdXQ7XG4gICAgc3dpdGNoICh0eXBlb2YgYXJnKSB7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBhcmcuZm9yRWFjaChhID0+IHRoaXMuYXBwZW5kKGEpKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJnLnR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGVUYWdzW2FyZy50eXBlXSkgYXJnLnR5cGUgPSB0eXBlVGFnc1thcmcudHlwZV07XG4gICAgICAgIHRoaXMuYXJncy5wdXNoKGFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRvbid0IGtub3cgaG93IHRvIGVuY29kZSBvYmplY3QgJHthcmd9YCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgaWYgKE1hdGguZmxvb3IoYXJnKSA9PT0gYXJnKSB7XG4gICAgICAgIGFyZ091dCA9IG5ldyBBcmd1bWVudCgnaW50ZWdlcicsIGFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmdPdXQgPSBuZXcgQXJndW1lbnQoJ2Zsb2F0JywgYXJnKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBhcmdPdXQgPSBuZXcgQXJndW1lbnQoJ3N0cmluZycsIGFyZyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGFyZ091dCA9IG5ldyBBcmd1bWVudCgnYm9vbGVhbicsIGFyZyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBkb24ndCBrbm93IGhvdyB0byBlbmNvZGUgJHthcmd9YCk7XG4gICAgfVxuICAgIGlmIChhcmdPdXQpIHRoaXMuYXJncy5wdXNoKGFyZ091dCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlO1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIE1lc3NhZ2UgPSByZXF1aXJlKCcuL01lc3NhZ2UuanMnKTtcblxuZnVuY3Rpb24gc2FuaXRpemUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEFycmF5KSBlbGVtZW50ID0gbmV3IE1lc3NhZ2UoZWxlbWVudFswXSwgLi4uZWxlbWVudC5zbGljZSgxKSk7XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5jbGFzcyBCdW5kbGUge1xuICBjb25zdHJ1Y3Rvcih0aW1ldGFnLCAuLi5lbGVtZW50cykge1xuICAgIGlmICghKHR5cGVvZiB0aW1ldGFnID09PSAnbnVtYmVyJykpIHtcbiAgICAgIGVsZW1lbnRzLnVuc2hpZnQodGltZXRhZyk7XG4gICAgICB0aW1ldGFnID0gMDtcbiAgICB9XG4gICAgdGhpcy50aW1ldGFnID0gdGltZXRhZztcbiAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHMubWFwKHNhbml0aXplKTtcbiAgfVxuXG4gIGFwcGVuZChlbGVtZW50KSB7XG4gICAgdGhpcy5lbGVtZW50cy5wdXNoKHNhbml0aXplKGVsZW1lbnQpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1bmRsZTtcbiIsICIvLyB0IGlzIGEgYmlucGFjayB0eXBlbmFtZVxudmFyIHNpemVPZlR5cGUgPSBmdW5jdGlvbih0KSB7XG4gICAgLy8gdW5zaWduZWQgYXJlIHRoZSBzYW1lIGxlbmd0aCBhcyBzaWduZWRcbiAgICBpZih0WzBdID09PSAnVScpIHtcbiAgICAgICAgdCA9IHQuc2xpY2UoMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgJ0Zsb2F0MzInIDogNCxcbiAgICAgICAgJ0Zsb2F0NjQnIDogOCxcbiAgICAgICAgJ0ludDgnIDogMSxcbiAgICAgICAgJ0ludDE2JyA6IDIsXG4gICAgICAgICdJbnQzMicgOiA0LFxuICAgICAgICAnSW50NjQnIDogOFxuICAgIH1bdF07XG59O1xuXG52YXIgZW5kaWFuQ29udiA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAvLyBub2RlIGRvZXNuJ3QgZGVmaW5lIDggYml0IGVuZGlhbm5lc3NcbiAgICBpZih0W3QubGVuZ3RoIC0gMV0gPT09ICc4JylcbiAgICAgICAgcmV0dXJuICcnO1xuXG4gICAgaWYoZSA9PT0gJ2JpZycpIHtcbiAgICAgICAgcmV0dXJuICdCRSc7XG4gICAgfVxuICAgIHJldHVybiAnTEUnO1xufTtcblxudmFyIGFkZEJpbmRpbmdzID0gZnVuY3Rpb24oYmlucGFja1R5cGVuYW1lLCBub2RlVHlwZW5hbWUpe1xuICAgIGlmKCEodHlwZW9mIG5vZGVUeXBlbmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBub2RlVHlwZW5hbWUgIT09IG51bGwpKSB7XG4gICAgICAgIG5vZGVUeXBlbmFtZSA9IGJpbnBhY2tUeXBlbmFtZTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHNbJ3BhY2snICsgYmlucGFja1R5cGVuYW1lXSA9IGZ1bmN0aW9uKG51bSwgZW5kaWFuKXtcbiAgICAgICAgYiA9IG5ldyBCdWZmZXIoc2l6ZU9mVHlwZShiaW5wYWNrVHlwZW5hbWUpKTtcbiAgICAgICAgYlsnd3JpdGUnICsgbm9kZVR5cGVuYW1lICsgZW5kaWFuQ29udihlbmRpYW4sIGJpbnBhY2tUeXBlbmFtZSldKG51bSwgMCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzWyd1bnBhY2snICsgYmlucGFja1R5cGVuYW1lXSA9IGZ1bmN0aW9uKGJ1ZmYsIGVuZGlhbil7XG4gICAgICAgIHJldHVybiBidWZmWydyZWFkJyArIG5vZGVUeXBlbmFtZSArIGVuZGlhbkNvbnYoZW5kaWFuLCBiaW5wYWNrVHlwZW5hbWUpXSgwKTtcbiAgICB9XG59XG5cbnZhciBhZGRJbnRCaW5kaW5ncyA9IGZ1bmN0aW9uKG4pIHtcbiAgICBhZGRCaW5kaW5ncyhcIkludFwiICsgbik7XG4gICAgYWRkQmluZGluZ3MoXCJVSW50XCIgKyBuKTtcbn1cblxuYWRkSW50QmluZGluZ3MoOCk7XG5hZGRJbnRCaW5kaW5ncygxNik7XG5hZGRJbnRCaW5kaW5ncygzMik7XG5cbnR3b1RvVGhlMzIgPSBNYXRoLnBvdygyLCAzMik7XG5cbi8vIDY0IGJpdCBiaW5kaW5ncyByZXF1aXJlIHNwZWNpYWwgY2FyZVxudmFyIHJlYWQ2NCA9IGZ1bmN0aW9uKHVuc2lnbmVkKXtyZXR1cm4gZnVuY3Rpb24oYnVmZiwgZW5kaWFuKXtcbiAgICB2YXIgZSA9IGVuZGlhbkNvbnYoZW5kaWFuLCAnJyk7XG4gICAgdmFyIHUgPSB1bnNpZ25lZCA/ICdVJyA6ICcnO1xuICAgIHZhciBsb3csIGhpZ2g7XG4gICAgaWYoZSA9PT0gJ0xFJykge1xuICAgICAgICBsb3cgPSBidWZmLnJlYWRVSW50MzJMRSgwKTtcbiAgICAgICAgaGlnaCA9IGJ1ZmZbJ3JlYWQnICsgdSArICdJbnQzMkxFJ10oNCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG93ID0gYnVmZi5yZWFkVUludDMyQkUoNCk7XG4gICAgICAgIGhpZ2ggPSBidWZmWydyZWFkJyArIHUgKyAnSW50MzJCRSddKDApO1xuICAgIH1cbiAgICByZXR1cm4gaGlnaCAqIHR3b1RvVGhlMzIgKyBsb3c7XG59O307XG5cbnZhciB3cml0ZTY0ID0gZnVuY3Rpb24odW5zaWduZWQpe3JldHVybiBmdW5jdGlvbihudW0sIGVuZGlhbil7XG4gICAgdmFyIGUgPSBlbmRpYW5Db252KGVuZGlhbiwgJycpO1xuICAgIHZhciB1ID0gdW5zaWduZWQgPyAnVScgOiAnJztcbiAgICB2YXIgYiA9IG5ldyBCdWZmZXIoOCk7XG4gICAgdmFyIGhpZ2ggPSBNYXRoLmZsb29yKG51bSAvIHR3b1RvVGhlMzIpO1xuICAgIHZhciBsb3cgPSBNYXRoLmZsb29yKG51bSAtIGhpZ2ggKiB0d29Ub1RoZTMyKTtcbiAgICBpZihlID09ICdMRScpIHtcbiAgICAgICAgYi53cml0ZVVJbnQzMkxFKGxvdywgMCwgdHJ1ZSk7XG4gICAgICAgIGJbJ3dyaXRlJyArIHUgKyAnSW50MzJMRSddKGhpZ2gsIDQsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGIud3JpdGVVSW50MzJCRShsb3csIDQsIHRydWUpO1xuICAgICAgICBiWyd3cml0ZScgKyB1ICsgJ0ludDMyQkUnXShoaWdoLCAwLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGI7XG59O307XG5cbm1vZHVsZS5leHBvcnRzLnVucGFja0ludDY0ID0gcmVhZDY0KGZhbHNlKTtcbm1vZHVsZS5leHBvcnRzLnVucGFja1VJbnQ2NCA9IHJlYWQ2NCh0cnVlKTtcbm1vZHVsZS5leHBvcnRzLnBhY2tJbnQ2NCA9IHdyaXRlNjQoZmFsc2UpO1xubW9kdWxlLmV4cG9ydHMucGFja1VJbnQ2NCA9IHdyaXRlNjQodHJ1ZSk7XG5cbmFkZEJpbmRpbmdzKFwiRmxvYXQzMlwiLCBcIkZsb2F0XCIpO1xuYWRkQmluZGluZ3MoXCJGbG9hdDY0XCIsIFwiRG91YmxlXCIpO1xuIiwgIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBJc0FycmF5LCBTdHJpY3RFcnJvciwgVFdPX1BPV18zMiwgVU5JWF9FUE9DSCwgYmlucGFjaywgZ2V0QXJyYXlBcmcsIGlzT3NjQnVuZGxlQnVmZmVyLCBtYWtlVGltZXRhZywgbWFwQnVuZGxlTGlzdCwgb3NjVHlwZUNvZGVzLCBwYWRkaW5nLCB0b09zY1R5cGVBbmRBcmdzLFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBiaW5wYWNrID0gcmVxdWlyZShcImJpbnBhY2tcIik7XG5cbiAgZXhwb3J0cy5jb25jYXQgPSBmdW5jdGlvbihidWZmZXJzKSB7XG4gICAgdmFyIGJ1ZmZlciwgY29weVRvLCBkZXN0QnVmZmVyLCBqLCBrLCBsLCBsZW4sIGxlbjEsIGxlbjIsIHN1bUxlbmd0aDtcbiAgICBpZiAoIUlzQXJyYXkoYnVmZmVycykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbmNhdCBtdXN0IHRha2UgYW4gYXJyYXkgb2YgYnVmZmVyc1wiKTtcbiAgICB9XG4gICAgZm9yIChqID0gMCwgbGVuID0gYnVmZmVycy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgYnVmZmVyID0gYnVmZmVyc1tqXTtcbiAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uY2F0IG11c3QgdGFrZSBhbiBhcnJheSBvZiBidWZmZXJzXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBzdW1MZW5ndGggPSAwO1xuICAgIGZvciAoayA9IDAsIGxlbjEgPSBidWZmZXJzLmxlbmd0aDsgayA8IGxlbjE7IGsrKykge1xuICAgICAgYnVmZmVyID0gYnVmZmVyc1trXTtcbiAgICAgIHN1bUxlbmd0aCArPSBidWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICBkZXN0QnVmZmVyID0gbmV3IEJ1ZmZlcihzdW1MZW5ndGgpO1xuICAgIGNvcHlUbyA9IDA7XG4gICAgZm9yIChsID0gMCwgbGVuMiA9IGJ1ZmZlcnMubGVuZ3RoOyBsIDwgbGVuMjsgbCsrKSB7XG4gICAgICBidWZmZXIgPSBidWZmZXJzW2xdO1xuICAgICAgYnVmZmVyLmNvcHkoZGVzdEJ1ZmZlciwgY29weVRvKTtcbiAgICAgIGNvcHlUbyArPSBidWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdEJ1ZmZlcjtcbiAgfTtcblxuICBleHBvcnRzLnRvT3NjU3RyaW5nID0gZnVuY3Rpb24oc3RyLCBzdHJpY3QpIHtcbiAgICB2YXIgaSwgaiwgbnVsbEluZGV4LCByZWY7XG4gICAgaWYgKCEodHlwZW9mIHN0ciA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IHBhY2sgYSBub24tc3RyaW5nIGludG8gYW4gb3NjLXN0cmluZ1wiKTtcbiAgICB9XG4gICAgbnVsbEluZGV4ID0gc3RyLmluZGV4T2YoXCJcXHUwMDAwXCIpO1xuICAgIGlmIChudWxsSW5kZXggIT09IC0xICYmIHN0cmljdCkge1xuICAgICAgdGhyb3cgU3RyaWN0RXJyb3IoXCJDYW4ndCBwYWNrIGFuIG9zYy1zdHJpbmcgdGhhdCBjb250YWlucyBOVUxMIGNoYXJhY3RlcnNcIik7XG4gICAgfVxuICAgIGlmIChudWxsSW5kZXggIT09IC0xKSB7XG4gICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgbnVsbEluZGV4KTtcbiAgICB9XG4gICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHBhZGRpbmcoc3RyKTsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICBzdHIgKz0gXCJcXHUwMDAwXCI7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHN0cik7XG4gIH07XG5cbiAgZXhwb3J0cy5zcGxpdE9zY1N0cmluZyA9IGZ1bmN0aW9uKGJ1ZmZlciwgc3RyaWN0KSB7XG4gICAgdmFyIGksIGosIG51bGxJbmRleCwgcmF3U3RyLCByZWYsIHJlZjEsIHJlc3QsIHNwbGl0UG9pbnQsIHN0cjtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgICB0aHJvdyBTdHJpY3RFcnJvcihcIkNhbid0IHNwbGl0IHNvbWV0aGluZyB0aGF0IGlzbid0IGEgYnVmZmVyXCIpO1xuICAgIH1cbiAgICByYXdTdHIgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIpO1xuICAgIG51bGxJbmRleCA9IHJhd1N0ci5pbmRleE9mKFwiXFx1MDAwMFwiKTtcbiAgICBpZiAobnVsbEluZGV4ID09PSAtMSkge1xuICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbGwgb3NjLXN0cmluZ3MgbXVzdCBjb250YWluIGEgbnVsbCBjaGFyYWN0ZXJcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdHJpbmc6IHJhd1N0cixcbiAgICAgICAgcmVzdDogbmV3IEJ1ZmZlcigwKVxuICAgICAgfTtcbiAgICB9XG4gICAgc3RyID0gcmF3U3RyLnNsaWNlKDAsIG51bGxJbmRleCk7XG4gICAgc3BsaXRQb2ludCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN0cikgKyBwYWRkaW5nKHN0cik7XG4gICAgaWYgKHN0cmljdCAmJiBzcGxpdFBvaW50ID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhyb3cgU3RyaWN0RXJyb3IoXCJOb3QgZW5vdWdoIHBhZGRpbmcgZm9yIG9zYy1zdHJpbmdcIik7XG4gICAgfVxuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgIGZvciAoaSA9IGogPSByZWYgPSBCdWZmZXIuYnl0ZUxlbmd0aChzdHIpLCByZWYxID0gc3BsaXRQb2ludDsgcmVmIDw9IHJlZjEgPyBqIDwgcmVmMSA6IGogPiByZWYxOyBpID0gcmVmIDw9IHJlZjEgPyArK2ogOiAtLWopIHtcbiAgICAgICAgaWYgKGJ1ZmZlcltpXSAhPT0gMCkge1xuICAgICAgICAgIHRocm93IFN0cmljdEVycm9yKFwiTm90IGVub3VnaCBvciBpbmNvcnJlY3QgcGFkZGluZyBmb3Igb3NjLXN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXN0ID0gYnVmZmVyLnNsaWNlKHNwbGl0UG9pbnQsIGJ1ZmZlci5sZW5ndGgpO1xuICAgIHJldHVybiB7XG4gICAgICBzdHJpbmc6IHN0cixcbiAgICAgIHJlc3Q6IHJlc3RcbiAgICB9O1xuICB9O1xuXG4gIGV4cG9ydHMuc3BsaXRJbnRlZ2VyID0gZnVuY3Rpb24oYnVmZmVyLCB0eXBlKSB7XG4gICAgdmFyIGJ5dGVzLCBudW0sIHJlc3QsIHZhbHVlO1xuICAgIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAgIHR5cGUgPSBcIkludDMyXCI7XG4gICAgfVxuICAgIGJ5dGVzID0gKGJpbnBhY2tbXCJwYWNrXCIgKyB0eXBlXSgwKSkubGVuZ3RoO1xuICAgIGlmIChidWZmZXIubGVuZ3RoIDwgYnl0ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJ1ZmZlciBpcyBub3QgYmlnIGVub3VnaCBmb3IgaW50ZWdlciB0eXBlXCIpO1xuICAgIH1cbiAgICBudW0gPSAwO1xuICAgIHZhbHVlID0gYmlucGFja1tcInVucGFja1wiICsgdHlwZV0oYnVmZmVyLnNsaWNlKDAsIGJ5dGVzKSwgXCJiaWdcIik7XG4gICAgcmVzdCA9IGJ1ZmZlci5zbGljZShieXRlcywgYnVmZmVyLmxlbmd0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGludGVnZXI6IHZhbHVlLFxuICAgICAgcmVzdDogcmVzdFxuICAgIH07XG4gIH07XG5cbiAgZXhwb3J0cy5zcGxpdFRpbWV0YWcgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICB2YXIgYSwgYiwgYnl0ZXMsIGMsIGQsIGZyYWN0aW9uYWwsIHJlc3QsIHNlY29uZHMsIHR5cGU7XG4gICAgdHlwZSA9IFwiVUludDMyXCI7XG4gICAgYnl0ZXMgPSAoYmlucGFja1tcInBhY2tcIiArIHR5cGVdKDApKS5sZW5ndGg7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCAoYnl0ZXMgKiAyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnVmZmVyIGlzIG5vdCBiaWcgZW5vdWdoIHRvIGNvbnRhaW4gYSB0aW1ldGFnXCIpO1xuICAgIH1cbiAgICBhID0gMDtcbiAgICBiID0gYnl0ZXM7XG4gICAgc2Vjb25kcyA9IGJpbnBhY2tbXCJ1bnBhY2tcIiArIHR5cGVdKGJ1ZmZlci5zbGljZShhLCBiKSwgXCJiaWdcIik7XG4gICAgYyA9IGJ5dGVzO1xuICAgIGQgPSBieXRlcyArIGJ5dGVzO1xuICAgIGZyYWN0aW9uYWwgPSBiaW5wYWNrW1widW5wYWNrXCIgKyB0eXBlXShidWZmZXIuc2xpY2UoYywgZCksIFwiYmlnXCIpO1xuICAgIHJlc3QgPSBidWZmZXIuc2xpY2UoZCwgYnVmZmVyLmxlbmd0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRpbWV0YWc6IFtzZWNvbmRzLCBmcmFjdGlvbmFsXSxcbiAgICAgIHJlc3Q6IHJlc3RcbiAgICB9O1xuICB9O1xuXG4gIFVOSVhfRVBPQ0ggPSAyMjA4OTg4ODAwO1xuXG4gIFRXT19QT1dfMzIgPSA0Mjk0OTY3Mjk2O1xuXG4gIGV4cG9ydHMuZGF0ZVRvVGltZXRhZyA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZXhwb3J0cy50aW1lc3RhbXBUb1RpbWV0YWcoZGF0ZS5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgfTtcblxuICBleHBvcnRzLnRpbWVzdGFtcFRvVGltZXRhZyA9IGZ1bmN0aW9uKHNlY3MpIHtcbiAgICB2YXIgZnJhY1NlY29uZHMsIHdob2xlU2VjcztcbiAgICB3aG9sZVNlY3MgPSBNYXRoLmZsb29yKHNlY3MpO1xuICAgIGZyYWNTZWNvbmRzID0gc2VjcyAtIHdob2xlU2VjcztcbiAgICByZXR1cm4gbWFrZVRpbWV0YWcod2hvbGVTZWNzLCBmcmFjU2Vjb25kcyk7XG4gIH07XG5cbiAgZXhwb3J0cy50aW1ldGFnVG9UaW1lc3RhbXAgPSBmdW5jdGlvbih0aW1ldGFnKSB7XG4gICAgdmFyIHNlY29uZHM7XG4gICAgc2Vjb25kcyA9IHRpbWV0YWdbMF0gKyBleHBvcnRzLm50cFRvRnJhY3Rpb25hbFNlY29uZHModGltZXRhZ1sxXSk7XG4gICAgcmV0dXJuIHNlY29uZHMgLSBVTklYX0VQT0NIO1xuICB9O1xuXG4gIG1ha2VUaW1ldGFnID0gZnVuY3Rpb24odW5peHNlY29uZHMsIGZyYWNTZWNvbmRzKSB7XG4gICAgdmFyIG50cEZyYWNzLCBudHBTZWNzO1xuICAgIG50cFNlY3MgPSB1bml4c2Vjb25kcyArIFVOSVhfRVBPQ0g7XG4gICAgbnRwRnJhY3MgPSBNYXRoLnJvdW5kKFRXT19QT1dfMzIgKiBmcmFjU2Vjb25kcyk7XG4gICAgcmV0dXJuIFtudHBTZWNzLCBudHBGcmFjc107XG4gIH07XG5cbiAgZXhwb3J0cy50aW1ldGFnVG9EYXRlID0gZnVuY3Rpb24odGltZXRhZykge1xuICAgIHZhciBkYXRlLCBkZCwgZnJhY3MsIGZyYWN0aW9uYWwsIHNlY29uZHM7XG4gICAgc2Vjb25kcyA9IHRpbWV0YWdbMF0sIGZyYWN0aW9uYWwgPSB0aW1ldGFnWzFdO1xuICAgIHNlY29uZHMgPSBzZWNvbmRzIC0gVU5JWF9FUE9DSDtcbiAgICBmcmFjcyA9IGV4cG9ydHMubnRwVG9GcmFjdGlvbmFsU2Vjb25kcyhmcmFjdGlvbmFsKTtcbiAgICBkYXRlID0gbmV3IERhdGUoKTtcbiAgICBkYXRlLnNldFRpbWUoKHNlY29uZHMgKiAxMDAwKSArIChmcmFjcyAqIDEwMDApKTtcbiAgICBkZCA9IG5ldyBEYXRlKCk7XG4gICAgZGQuc2V0VVRDRnVsbFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICBkZC5zZXRVVENNb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgIGRkLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgIGRkLnNldFVUQ0hvdXJzKGRhdGUuZ2V0VVRDSG91cnMoKSk7XG4gICAgZGQuc2V0VVRDTWludXRlcyhkYXRlLmdldFVUQ01pbnV0ZXMoKSk7XG4gICAgZGQuc2V0VVRDU2Vjb25kcyhkYXRlLmdldFVUQ1NlY29uZHMoKSk7XG4gICAgZGQuc2V0VVRDTWlsbGlzZWNvbmRzKGZyYWNzICogMTAwMCk7XG4gICAgcmV0dXJuIGRkO1xuICB9O1xuXG4gIGV4cG9ydHMuZGVsdGFUaW1ldGFnID0gZnVuY3Rpb24oc2Vjb25kcywgbm93KSB7XG4gICAgdmFyIG47XG4gICAgbiA9IChub3cgIT0gbnVsbCA/IG5vdyA6IG5ldyBEYXRlKCkpIC8gMTAwMDtcbiAgICByZXR1cm4gZXhwb3J0cy50aW1lc3RhbXBUb1RpbWV0YWcobiArIHNlY29uZHMpO1xuICB9O1xuXG4gIGV4cG9ydHMubnRwVG9GcmFjdGlvbmFsU2Vjb25kcyA9IGZ1bmN0aW9uKGZyYWNTZWNvbmRzKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoZnJhY1NlY29uZHMpIC8gVFdPX1BPV18zMjtcbiAgfTtcblxuICBleHBvcnRzLnRvVGltZXRhZ0J1ZmZlciA9IGZ1bmN0aW9uKHRpbWV0YWcpIHtcbiAgICB2YXIgaGlnaCwgbG93LCB0eXBlO1xuICAgIGlmICh0eXBlb2YgdGltZXRhZyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdGltZXRhZyA9IGV4cG9ydHMudGltZXN0YW1wVG9UaW1ldGFnKHRpbWV0YWcpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRpbWV0YWcgPT09IFwib2JqZWN0XCIgJiYgKFwiZ2V0VGltZVwiIGluIHRpbWV0YWcpKSB7XG4gICAgICB0aW1ldGFnID0gZXhwb3J0cy5kYXRlVG9UaW1ldGFnKHRpbWV0YWcpO1xuICAgIH0gZWxzZSBpZiAodGltZXRhZy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdGltZXRhZ1wiICsgdGltZXRhZyk7XG4gICAgfVxuICAgIHR5cGUgPSBcIlVJbnQzMlwiO1xuICAgIGhpZ2ggPSBiaW5wYWNrW1wicGFja1wiICsgdHlwZV0odGltZXRhZ1swXSwgXCJiaWdcIik7XG4gICAgbG93ID0gYmlucGFja1tcInBhY2tcIiArIHR5cGVdKHRpbWV0YWdbMV0sIFwiYmlnXCIpO1xuICAgIHJldHVybiBleHBvcnRzLmNvbmNhdChbaGlnaCwgbG93XSk7XG4gIH07XG5cbiAgZXhwb3J0cy50b0ludGVnZXJCdWZmZXIgPSBmdW5jdGlvbihudW1iZXIsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgICB0eXBlID0gXCJJbnQzMlwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG51bWJlciAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHBhY2sgYSBub24tbnVtYmVyIGludG8gYW4gaW50ZWdlciBidWZmZXJcIik7XG4gICAgfVxuICAgIHJldHVybiBiaW5wYWNrW1wicGFja1wiICsgdHlwZV0obnVtYmVyLCBcImJpZ1wiKTtcbiAgfTtcblxuICBvc2NUeXBlQ29kZXMgPSB7XG4gICAgczoge1xuICAgICAgcmVwcmVzZW50YXRpb246IFwic3RyaW5nXCIsXG4gICAgICBzcGxpdDogZnVuY3Rpb24oYnVmZmVyLCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIHNwbGl0O1xuICAgICAgICBzcGxpdCA9IGV4cG9ydHMuc3BsaXRPc2NTdHJpbmcoYnVmZmVyLCBzdHJpY3QpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBzcGxpdC5zdHJpbmcsXG4gICAgICAgICAgcmVzdDogc3BsaXQucmVzdFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRvQXJnOiBmdW5jdGlvbih2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cG9ydHMudG9Pc2NTdHJpbmcodmFsdWUsIHN0cmljdCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpOiB7XG4gICAgICByZXByZXNlbnRhdGlvbjogXCJpbnRlZ2VyXCIsXG4gICAgICBzcGxpdDogZnVuY3Rpb24oYnVmZmVyLCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIHNwbGl0O1xuICAgICAgICBzcGxpdCA9IGV4cG9ydHMuc3BsaXRJbnRlZ2VyKGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHNwbGl0LmludGVnZXIsXG4gICAgICAgICAgcmVzdDogc3BsaXQucmVzdFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRvQXJnOiBmdW5jdGlvbih2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cG9ydHMudG9JbnRlZ2VyQnVmZmVyKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHQ6IHtcbiAgICAgIHJlcHJlc2VudGF0aW9uOiBcInRpbWV0YWdcIixcbiAgICAgIHNwbGl0OiBmdW5jdGlvbihidWZmZXIsIHN0cmljdCkge1xuICAgICAgICB2YXIgc3BsaXQ7XG4gICAgICAgIHNwbGl0ID0gZXhwb3J0cy5zcGxpdFRpbWV0YWcoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogc3BsaXQudGltZXRhZyxcbiAgICAgICAgICByZXN0OiBzcGxpdC5yZXN0XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdG9Bcmc6IGZ1bmN0aW9uKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMudG9UaW1ldGFnQnVmZmVyKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGY6IHtcbiAgICAgIHJlcHJlc2VudGF0aW9uOiBcImZsb2F0XCIsXG4gICAgICBzcGxpdDogZnVuY3Rpb24oYnVmZmVyLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogYmlucGFjay51bnBhY2tGbG9hdDMyKGJ1ZmZlci5zbGljZSgwLCA0KSwgXCJiaWdcIiksXG4gICAgICAgICAgcmVzdDogYnVmZmVyLnNsaWNlKDQsIGJ1ZmZlci5sZW5ndGgpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdG9Bcmc6IGZ1bmN0aW9uKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIG51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmlucGFjay5wYWNrRmxvYXQzMih2YWx1ZSwgXCJiaWdcIik7XG4gICAgICB9XG4gICAgfSxcbiAgICBkOiB7XG4gICAgICByZXByZXNlbnRhdGlvbjogXCJkb3VibGVcIixcbiAgICAgIHNwbGl0OiBmdW5jdGlvbihidWZmZXIsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBiaW5wYWNrLnVucGFja0Zsb2F0NjQoYnVmZmVyLnNsaWNlKDAsIDgpLCBcImJpZ1wiKSxcbiAgICAgICAgICByZXN0OiBidWZmZXIuc2xpY2UoOCwgYnVmZmVyLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB0b0FyZzogZnVuY3Rpb24odmFsdWUsIHN0cmljdCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgbnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaW5wYWNrLnBhY2tGbG9hdDY0KHZhbHVlLCBcImJpZ1wiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGI6IHtcbiAgICAgIHJlcHJlc2VudGF0aW9uOiBcImJsb2JcIixcbiAgICAgIHNwbGl0OiBmdW5jdGlvbihidWZmZXIsIHN0cmljdCkge1xuICAgICAgICB2YXIgbGVuZ3RoLCByZWY7XG4gICAgICAgIHJlZiA9IGV4cG9ydHMuc3BsaXRJbnRlZ2VyKGJ1ZmZlciksIGxlbmd0aCA9IHJlZi5pbnRlZ2VyLCBidWZmZXIgPSByZWYucmVzdDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogYnVmZmVyLnNsaWNlKDAsIGxlbmd0aCksXG4gICAgICAgICAgcmVzdDogYnVmZmVyLnNsaWNlKGxlbmd0aCwgYnVmZmVyLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB0b0FyZzogZnVuY3Rpb24odmFsdWUsIHN0cmljdCkge1xuICAgICAgICB2YXIgc2l6ZTtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgbm9kZS5qcyBCdWZmZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgc2l6ZSA9IGV4cG9ydHMudG9JbnRlZ2VyQnVmZmVyKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmNvbmNhdChbc2l6ZSwgdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFQ6IHtcbiAgICAgIHJlcHJlc2VudGF0aW9uOiBcInRydWVcIixcbiAgICAgIHNwbGl0OiBmdW5jdGlvbihidWZmZXIsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3Q6IGJ1ZmZlcixcbiAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRvQXJnOiBmdW5jdGlvbih2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICAgIGlmICghdmFsdWUgJiYgc3RyaWN0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ1ZSBtdXN0IGJlIHRydWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoMCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBGOiB7XG4gICAgICByZXByZXNlbnRhdGlvbjogXCJmYWxzZVwiLFxuICAgICAgc3BsaXQ6IGZ1bmN0aW9uKGJ1ZmZlciwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdDogYnVmZmVyLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRvQXJnOiBmdW5jdGlvbih2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiBzdHJpY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmYWxzZSBtdXN0IGJlIGZhbHNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKDApO1xuICAgICAgfVxuICAgIH0sXG4gICAgTjoge1xuICAgICAgcmVwcmVzZW50YXRpb246IFwibnVsbFwiLFxuICAgICAgc3BsaXQ6IGZ1bmN0aW9uKGJ1ZmZlciwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdDogYnVmZmVyLFxuICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdG9Bcmc6IGZ1bmN0aW9uKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHN0cmljdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm51bGwgbXVzdCBiZSBmYWxzZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIEk6IHtcbiAgICAgIHJlcHJlc2VudGF0aW9uOiBcImJhbmdcIixcbiAgICAgIHNwbGl0OiBmdW5jdGlvbihidWZmZXIsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3Q6IGJ1ZmZlcixcbiAgICAgICAgICB2YWx1ZTogXCJiYW5nXCJcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB0b0FyZzogZnVuY3Rpb24odmFsdWUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZXhwb3J0cy5vc2NUeXBlQ29kZVRvVHlwZVN0cmluZyA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICB2YXIgcmVmO1xuICAgIHJldHVybiAocmVmID0gb3NjVHlwZUNvZGVzW2NvZGVdKSAhPSBudWxsID8gcmVmLnJlcHJlc2VudGF0aW9uIDogdm9pZCAwO1xuICB9O1xuXG4gIGV4cG9ydHMudHlwZVN0cmluZ1RvT3NjVHlwZUNvZGUgPSBmdW5jdGlvbihyZXApIHtcbiAgICB2YXIgY29kZSwgc3RyO1xuICAgIGZvciAoY29kZSBpbiBvc2NUeXBlQ29kZXMpIHtcbiAgICAgIGlmICghaGFzUHJvcC5jYWxsKG9zY1R5cGVDb2RlcywgY29kZSkpIGNvbnRpbnVlO1xuICAgICAgc3RyID0gb3NjVHlwZUNvZGVzW2NvZGVdLnJlcHJlc2VudGF0aW9uO1xuICAgICAgaWYgKHN0ciA9PT0gcmVwKSB7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBleHBvcnRzLmFyZ1RvVHlwZUNvZGUgPSBmdW5jdGlvbihhcmcsIHN0cmljdCkge1xuICAgIHZhciBjb2RlLCB2YWx1ZTtcbiAgICBpZiAoKChhcmcgIT0gbnVsbCA/IGFyZy50eXBlIDogdm9pZCAwKSAhPSBudWxsKSAmJiAodHlwZW9mIGFyZy50eXBlID09PSAnc3RyaW5nJykgJiYgKChjb2RlID0gZXhwb3J0cy50eXBlU3RyaW5nVG9Pc2NUeXBlQ29kZShhcmcudHlwZSkpICE9IG51bGwpKSB7XG4gICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgdmFsdWUgPSAoYXJnICE9IG51bGwgPyBhcmcudmFsdWUgOiB2b2lkIDApICE9IG51bGwgPyBhcmcudmFsdWUgOiBhcmc7XG4gICAgaWYgKHN0cmljdCAmJiAodmFsdWUgPT0gbnVsbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgaGFzIG5vIHZhbHVlJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gJ3MnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICdmJztcbiAgICB9XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYic7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAnVCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ0YnO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnTic7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkkgZG9uJ3Qga25vdyB3aGF0IHR5cGUgdGhpcyBpcyBzdXBwb3NlZCB0byBiZS5cIik7XG4gIH07XG5cbiAgZXhwb3J0cy5zcGxpdE9zY0FyZ3VtZW50ID0gZnVuY3Rpb24oYnVmZmVyLCB0eXBlLCBzdHJpY3QpIHtcbiAgICB2YXIgb3NjdHlwZTtcbiAgICBvc2N0eXBlID0gZXhwb3J0cy50eXBlU3RyaW5nVG9Pc2NUeXBlQ29kZSh0eXBlKTtcbiAgICBpZiAob3NjdHlwZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gb3NjVHlwZUNvZGVzW29zY3R5cGVdLnNwbGl0KGJ1ZmZlciwgc3RyaWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSSBkb24ndCB1bmRlcnN0YW5kIGhvdyBJJ20gc3VwcG9zZWQgdG8gdW5wYWNrIFwiICsgdHlwZSk7XG4gICAgfVxuICB9O1xuXG4gIGV4cG9ydHMudG9Pc2NBcmd1bWVudCA9IGZ1bmN0aW9uKHZhbHVlLCB0eXBlLCBzdHJpY3QpIHtcbiAgICB2YXIgb3NjdHlwZTtcbiAgICBvc2N0eXBlID0gZXhwb3J0cy50eXBlU3RyaW5nVG9Pc2NUeXBlQ29kZSh0eXBlKTtcbiAgICBpZiAob3NjdHlwZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gb3NjVHlwZUNvZGVzW29zY3R5cGVdLnRvQXJnKHZhbHVlLCBzdHJpY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJIGRvbid0IGtub3cgaG93IHRvIHBhY2sgXCIgKyB0eXBlKTtcbiAgICB9XG4gIH07XG5cbiAgZXhwb3J0cy5mcm9tT3NjTWVzc2FnZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgc3RyaWN0KSB7XG4gICAgdmFyIGFkZHJlc3MsIGFyZywgYXJncywgYXJyYXlTdGFjaywgYnVpbHQsIGosIGxlbiwgcmVmLCByZWYxLCB0eXBlLCB0eXBlU3RyaW5nLCB0eXBlcztcbiAgICByZWYgPSBleHBvcnRzLnNwbGl0T3NjU3RyaW5nKGJ1ZmZlciwgc3RyaWN0KSwgYWRkcmVzcyA9IHJlZi5zdHJpbmcsIGJ1ZmZlciA9IHJlZi5yZXN0O1xuICAgIGlmIChzdHJpY3QgJiYgYWRkcmVzc1swXSAhPT0gJy8nKSB7XG4gICAgICB0aHJvdyBTdHJpY3RFcnJvcignYWRkcmVzc2VzIG11c3Qgc3RhcnQgd2l0aCAvJyk7XG4gICAgfVxuICAgIGlmICghYnVmZmVyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgYXJnczogW11cbiAgICAgIH07XG4gICAgfVxuICAgIHJlZjEgPSBleHBvcnRzLnNwbGl0T3NjU3RyaW5nKGJ1ZmZlciwgc3RyaWN0KSwgdHlwZXMgPSByZWYxLnN0cmluZywgYnVmZmVyID0gcmVmMS5yZXN0O1xuICAgIGlmICh0eXBlc1swXSAhPT0gJywnKSB7XG4gICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIHRocm93IFN0cmljdEVycm9yKCdBcmd1bWVudCBsaXN0cyBtdXN0IGJlZ2luIHdpdGggLCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgYXJnczogW11cbiAgICAgIH07XG4gICAgfVxuICAgIHR5cGVzID0gdHlwZXMuc2xpY2UoMSwgK3R5cGVzLmxlbmd0aCArIDEgfHwgOWU5KTtcbiAgICBhcmdzID0gW107XG4gICAgYXJyYXlTdGFjayA9IFthcmdzXTtcbiAgICBmb3IgKGogPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgdHlwZSA9IHR5cGVzW2pdO1xuICAgICAgaWYgKHR5cGUgPT09ICdbJykge1xuICAgICAgICBhcnJheVN0YWNrLnB1c2goW10pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnXScpIHtcbiAgICAgICAgaWYgKGFycmF5U3RhY2subGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3RyaWN0RXJyb3IoXCJNaXNtYXRjaGVkICddJyBjaGFyYWN0ZXIuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWlsdCA9IGFycmF5U3RhY2sucG9wKCk7XG4gICAgICAgICAgYXJyYXlTdGFja1thcnJheVN0YWNrLmxlbmd0aCAtIDFdLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgIHZhbHVlOiBidWlsdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdHlwZVN0cmluZyA9IGV4cG9ydHMub3NjVHlwZUNvZGVUb1R5cGVTdHJpbmcodHlwZSk7XG4gICAgICBpZiAodHlwZVN0cmluZyA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkkgZG9uJ3QgdW5kZXJzdGFuZCB0aGUgYXJndW1lbnQgY29kZSBcIiArIHR5cGUpO1xuICAgICAgfVxuICAgICAgYXJnID0gZXhwb3J0cy5zcGxpdE9zY0FyZ3VtZW50KGJ1ZmZlciwgdHlwZVN0cmluZywgc3RyaWN0KTtcbiAgICAgIGlmIChhcmcgIT0gbnVsbCkge1xuICAgICAgICBidWZmZXIgPSBhcmcucmVzdDtcbiAgICAgIH1cbiAgICAgIGFycmF5U3RhY2tbYXJyYXlTdGFjay5sZW5ndGggLSAxXS5wdXNoKHtcbiAgICAgICAgdHlwZTogdHlwZVN0cmluZyxcbiAgICAgICAgdmFsdWU6IGFyZyAhPSBudWxsID8gYXJnLnZhbHVlIDogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGFycmF5U3RhY2subGVuZ3RoICE9PSAxICYmIHN0cmljdCkge1xuICAgICAgdGhyb3cgbmV3IFN0cmljdEVycm9yKFwiTWlzbWF0Y2hlZCAnWycgY2hhcmFjdGVyXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICBvc2NUeXBlOiBcIm1lc3NhZ2VcIlxuICAgIH07XG4gIH07XG5cbiAgZXhwb3J0cy5mcm9tT3NjQnVuZGxlID0gZnVuY3Rpb24oYnVmZmVyLCBzdHJpY3QpIHtcbiAgICB2YXIgYnVuZGxlVGFnLCBjb252ZXJ0ZWRFbGVtcywgcmVmLCByZWYxLCB0aW1ldGFnO1xuICAgIHJlZiA9IGV4cG9ydHMuc3BsaXRPc2NTdHJpbmcoYnVmZmVyLCBzdHJpY3QpLCBidW5kbGVUYWcgPSByZWYuc3RyaW5nLCBidWZmZXIgPSByZWYucmVzdDtcbiAgICBpZiAoYnVuZGxlVGFnICE9PSBcIlxcI2J1bmRsZVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvc2MtYnVuZGxlcyBtdXN0IGJlZ2luIHdpdGggXFwjYnVuZGxlXCIpO1xuICAgIH1cbiAgICByZWYxID0gZXhwb3J0cy5zcGxpdFRpbWV0YWcoYnVmZmVyKSwgdGltZXRhZyA9IHJlZjEudGltZXRhZywgYnVmZmVyID0gcmVmMS5yZXN0O1xuICAgIGNvbnZlcnRlZEVsZW1zID0gbWFwQnVuZGxlTGlzdChidWZmZXIsIGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZnJvbU9zY1BhY2tldChidWZmZXIsIHN0cmljdCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRpbWV0YWc6IHRpbWV0YWcsXG4gICAgICBlbGVtZW50czogY29udmVydGVkRWxlbXMsXG4gICAgICBvc2NUeXBlOiBcImJ1bmRsZVwiXG4gICAgfTtcbiAgfTtcblxuICBleHBvcnRzLmZyb21Pc2NQYWNrZXQgPSBmdW5jdGlvbihidWZmZXIsIHN0cmljdCkge1xuICAgIGlmIChpc09zY0J1bmRsZUJ1ZmZlcihidWZmZXIsIHN0cmljdCkpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmZyb21Pc2NCdW5kbGUoYnVmZmVyLCBzdHJpY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5mcm9tT3NjTWVzc2FnZShidWZmZXIsIHN0cmljdCk7XG4gICAgfVxuICB9O1xuXG4gIGdldEFycmF5QXJnID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKElzQXJyYXkoYXJnKSkge1xuICAgICAgcmV0dXJuIGFyZztcbiAgICB9IGVsc2UgaWYgKCgoYXJnICE9IG51bGwgPyBhcmcudHlwZSA6IHZvaWQgMCkgPT09IFwiYXJyYXlcIikgJiYgKElzQXJyYXkoYXJnICE9IG51bGwgPyBhcmcudmFsdWUgOiB2b2lkIDApKSkge1xuICAgICAgcmV0dXJuIGFyZy52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKChhcmcgIT0gbnVsbCkgJiYgKGFyZy50eXBlID09IG51bGwpICYmIChJc0FycmF5KGFyZy52YWx1ZSkpKSB7XG4gICAgICByZXR1cm4gYXJnLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgdG9Pc2NUeXBlQW5kQXJncyA9IGZ1bmN0aW9uKGFyZ0xpc3QsIHN0cmljdCkge1xuICAgIHZhciBhcmcsIGJ1ZmYsIGosIGxlbiwgb3NjYXJncywgb3NjdHlwZSwgcmVmLCB0aGlzQXJncywgdGhpc1R5cGUsIHR5cGVDb2RlLCB2YWx1ZTtcbiAgICBvc2N0eXBlID0gXCJcIjtcbiAgICBvc2NhcmdzID0gW107XG4gICAgZm9yIChqID0gMCwgbGVuID0gYXJnTGlzdC5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgYXJnID0gYXJnTGlzdFtqXTtcbiAgICAgIGlmICgoZ2V0QXJyYXlBcmcoYXJnKSkgIT0gbnVsbCkge1xuICAgICAgICByZWYgPSB0b09zY1R5cGVBbmRBcmdzKGdldEFycmF5QXJnKGFyZyksIHN0cmljdCksIHRoaXNUeXBlID0gcmVmWzBdLCB0aGlzQXJncyA9IHJlZlsxXTtcbiAgICAgICAgb3NjdHlwZSArPSBcIltcIiArIHRoaXNUeXBlICsgXCJdXCI7XG4gICAgICAgIG9zY2FyZ3MgPSBvc2NhcmdzLmNvbmNhdCh0aGlzQXJncyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdHlwZUNvZGUgPSBleHBvcnRzLmFyZ1RvVHlwZUNvZGUoYXJnLCBzdHJpY3QpO1xuICAgICAgaWYgKHR5cGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgdmFsdWUgPSBhcmcgIT0gbnVsbCA/IGFyZy52YWx1ZSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICB2YWx1ZSA9IGFyZztcbiAgICAgICAgfVxuICAgICAgICBidWZmID0gZXhwb3J0cy50b09zY0FyZ3VtZW50KHZhbHVlLCBleHBvcnRzLm9zY1R5cGVDb2RlVG9UeXBlU3RyaW5nKHR5cGVDb2RlKSwgc3RyaWN0KTtcbiAgICAgICAgaWYgKGJ1ZmYgIT0gbnVsbCkge1xuICAgICAgICAgIG9zY2FyZ3MucHVzaChidWZmKTtcbiAgICAgICAgICBvc2N0eXBlICs9IHR5cGVDb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbb3NjdHlwZSwgb3NjYXJnc107XG4gIH07XG5cbiAgZXhwb3J0cy50b09zY01lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlLCBzdHJpY3QpIHtcbiAgICB2YXIgYWRkcmVzcywgYWxsQXJncywgYXJncywgb2xkX2FyZywgb3NjYWRkciwgb3NjYXJncywgb3NjdHlwZSwgcmVmO1xuICAgIGFkZHJlc3MgPSAobWVzc2FnZSAhPSBudWxsID8gbWVzc2FnZS5hZGRyZXNzIDogdm9pZCAwKSAhPSBudWxsID8gbWVzc2FnZS5hZGRyZXNzIDogbWVzc2FnZTtcbiAgICBpZiAodHlwZW9mIGFkZHJlc3MgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1lc3NhZ2UgbXVzdCBjb250YWluIGFuIGFkZHJlc3NcIik7XG4gICAgfVxuICAgIGFyZ3MgPSBtZXNzYWdlICE9IG51bGwgPyBtZXNzYWdlLmFyZ3MgOiB2b2lkIDA7XG4gICAgaWYgKGFyZ3MgPT09IHZvaWQgMCkge1xuICAgICAgYXJncyA9IFtdO1xuICAgIH1cbiAgICBpZiAoIUlzQXJyYXkoYXJncykpIHtcbiAgICAgIG9sZF9hcmcgPSBhcmdzO1xuICAgICAgYXJncyA9IFtdO1xuICAgICAgYXJnc1swXSA9IG9sZF9hcmc7XG4gICAgfVxuICAgIG9zY2FkZHIgPSBleHBvcnRzLnRvT3NjU3RyaW5nKGFkZHJlc3MsIHN0cmljdCk7XG4gICAgcmVmID0gdG9Pc2NUeXBlQW5kQXJncyhhcmdzLCBzdHJpY3QpLCBvc2N0eXBlID0gcmVmWzBdLCBvc2NhcmdzID0gcmVmWzFdO1xuICAgIG9zY3R5cGUgPSBcIixcIiArIG9zY3R5cGU7XG4gICAgYWxsQXJncyA9IGV4cG9ydHMuY29uY2F0KG9zY2FyZ3MpO1xuICAgIG9zY3R5cGUgPSBleHBvcnRzLnRvT3NjU3RyaW5nKG9zY3R5cGUpO1xuICAgIHJldHVybiBleHBvcnRzLmNvbmNhdChbb3NjYWRkciwgb3NjdHlwZSwgYWxsQXJnc10pO1xuICB9O1xuXG4gIGV4cG9ydHMudG9Pc2NCdW5kbGUgPSBmdW5jdGlvbihidW5kbGUsIHN0cmljdCkge1xuICAgIHZhciBhbGxFbGVtcywgYnVmZiwgZSwgZWxlbSwgZWxlbWVudHMsIGVsZW1zdHIsIGosIGxlbiwgb3NjQnVuZGxlVGFnLCBvc2NFbGVtcywgb3NjVGltZVRhZywgcmVmLCByZWYxLCBzaXplLCB0aW1ldGFnO1xuICAgIGlmIChzdHJpY3QgJiYgKChidW5kbGUgIT0gbnVsbCA/IGJ1bmRsZS50aW1ldGFnIDogdm9pZCAwKSA9PSBudWxsKSkge1xuICAgICAgdGhyb3cgU3RyaWN0RXJyb3IoXCJidW5kbGVzIG11c3QgaGF2ZSB0aW1ldGFncy5cIik7XG4gICAgfVxuICAgIHRpbWV0YWcgPSAocmVmID0gYnVuZGxlICE9IG51bGwgPyBidW5kbGUudGltZXRhZyA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZiA6IG5ldyBEYXRlKCk7XG4gICAgZWxlbWVudHMgPSAocmVmMSA9IGJ1bmRsZSAhPSBudWxsID8gYnVuZGxlLmVsZW1lbnRzIDogdm9pZCAwKSAhPSBudWxsID8gcmVmMSA6IFtdO1xuICAgIGlmICghSXNBcnJheShlbGVtZW50cykpIHtcbiAgICAgIGVsZW1zdHIgPSBlbGVtZW50cztcbiAgICAgIGVsZW1lbnRzID0gW107XG4gICAgICBlbGVtZW50cy5wdXNoKGVsZW1zdHIpO1xuICAgIH1cbiAgICBvc2NCdW5kbGVUYWcgPSBleHBvcnRzLnRvT3NjU3RyaW5nKFwiXFwjYnVuZGxlXCIpO1xuICAgIG9zY1RpbWVUYWcgPSBleHBvcnRzLnRvVGltZXRhZ0J1ZmZlcih0aW1ldGFnKTtcbiAgICBvc2NFbGVtcyA9IFtdO1xuICAgIGZvciAoaiA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBlbGVtID0gZWxlbWVudHNbal07XG4gICAgICB0cnkge1xuICAgICAgICBidWZmID0gZXhwb3J0cy50b09zY1BhY2tldChlbGVtLCBzdHJpY3QpO1xuICAgICAgICBzaXplID0gZXhwb3J0cy50b0ludGVnZXJCdWZmZXIoYnVmZi5sZW5ndGgpO1xuICAgICAgICBvc2NFbGVtcy5wdXNoKGV4cG9ydHMuY29uY2F0KFtzaXplLCBidWZmXSkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZSA9IGVycm9yO1xuICAgICAgICBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBhbGxFbGVtcyA9IGV4cG9ydHMuY29uY2F0KG9zY0VsZW1zKTtcbiAgICByZXR1cm4gZXhwb3J0cy5jb25jYXQoW29zY0J1bmRsZVRhZywgb3NjVGltZVRhZywgYWxsRWxlbXNdKTtcbiAgfTtcblxuICBleHBvcnRzLnRvT3NjUGFja2V0ID0gZnVuY3Rpb24oYnVuZGxlT3JNZXNzYWdlLCBzdHJpY3QpIHtcbiAgICBpZiAoKGJ1bmRsZU9yTWVzc2FnZSAhPSBudWxsID8gYnVuZGxlT3JNZXNzYWdlLm9zY1R5cGUgOiB2b2lkIDApICE9IG51bGwpIHtcbiAgICAgIGlmIChidW5kbGVPck1lc3NhZ2Uub3NjVHlwZSA9PT0gXCJidW5kbGVcIikge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy50b09zY0J1bmRsZShidW5kbGVPck1lc3NhZ2UsIHN0cmljdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwb3J0cy50b09zY01lc3NhZ2UoYnVuZGxlT3JNZXNzYWdlLCBzdHJpY3QpO1xuICAgIH1cbiAgICBpZiAoKChidW5kbGVPck1lc3NhZ2UgIT0gbnVsbCA/IGJ1bmRsZU9yTWVzc2FnZS50aW1ldGFnIDogdm9pZCAwKSAhPSBudWxsKSB8fCAoKGJ1bmRsZU9yTWVzc2FnZSAhPSBudWxsID8gYnVuZGxlT3JNZXNzYWdlLmVsZW1lbnRzIDogdm9pZCAwKSAhPSBudWxsKSkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMudG9Pc2NCdW5kbGUoYnVuZGxlT3JNZXNzYWdlLCBzdHJpY3QpO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0cy50b09zY01lc3NhZ2UoYnVuZGxlT3JNZXNzYWdlLCBzdHJpY3QpO1xuICB9O1xuXG4gIGV4cG9ydHMuYXBwbHlNZXNzYWdlVHJhbmZvcm1lclRvQnVuZGxlID0gZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgdmFyIGJ1bmRsZVRhZ0J1ZmZlciwgY29weUluZGV4LCBlbGVtLCBlbGVtcywgaiwgaywgbGVuLCBsZW4xLCBsZW5ndGhCdWZmLCBvdXRCdWZmZXIsIHJlZiwgc3RyaW5nLCB0aW1ldGFnQnVmZmVyLCB0b3RhbExlbmd0aDtcbiAgICAgIHJlZiA9IGV4cG9ydHMuc3BsaXRPc2NTdHJpbmcoYnVmZmVyKSwgc3RyaW5nID0gcmVmLnN0cmluZywgYnVmZmVyID0gcmVmLnJlc3Q7XG4gICAgICBpZiAoc3RyaW5nICE9PSBcIlxcI2J1bmRsZVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9zYy1idW5kbGVzIG11c3QgYmVnaW4gd2l0aCBcXCNidW5kbGVcIik7XG4gICAgICB9XG4gICAgICBidW5kbGVUYWdCdWZmZXIgPSBleHBvcnRzLnRvT3NjU3RyaW5nKHN0cmluZyk7XG4gICAgICB0aW1ldGFnQnVmZmVyID0gYnVmZmVyLnNsaWNlKDAsIDgpO1xuICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKDgsIGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgZWxlbXMgPSBtYXBCdW5kbGVMaXN0KGJ1ZmZlciwgZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmFwcGx5VHJhbnNmb3JtKGJ1ZmZlciwgdHJhbnNmb3JtLCBleHBvcnRzLmFwcGx5TWVzc2FnZVRyYW5mb3JtZXJUb0J1bmRsZSh0cmFuc2Zvcm0pKTtcbiAgICAgIH0pO1xuICAgICAgdG90YWxMZW5ndGggPSBidW5kbGVUYWdCdWZmZXIubGVuZ3RoICsgdGltZXRhZ0J1ZmZlci5sZW5ndGg7XG4gICAgICBmb3IgKGogPSAwLCBsZW4gPSBlbGVtcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICBlbGVtID0gZWxlbXNbal07XG4gICAgICAgIHRvdGFsTGVuZ3RoICs9IDQgKyBlbGVtLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG91dEJ1ZmZlciA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpO1xuICAgICAgYnVuZGxlVGFnQnVmZmVyLmNvcHkob3V0QnVmZmVyLCAwKTtcbiAgICAgIHRpbWV0YWdCdWZmZXIuY29weShvdXRCdWZmZXIsIGJ1bmRsZVRhZ0J1ZmZlci5sZW5ndGgpO1xuICAgICAgY29weUluZGV4ID0gYnVuZGxlVGFnQnVmZmVyLmxlbmd0aCArIHRpbWV0YWdCdWZmZXIubGVuZ3RoO1xuICAgICAgZm9yIChrID0gMCwgbGVuMSA9IGVsZW1zLmxlbmd0aDsgayA8IGxlbjE7IGsrKykge1xuICAgICAgICBlbGVtID0gZWxlbXNba107XG4gICAgICAgIGxlbmd0aEJ1ZmYgPSBleHBvcnRzLnRvSW50ZWdlckJ1ZmZlcihlbGVtLmxlbmd0aCk7XG4gICAgICAgIGxlbmd0aEJ1ZmYuY29weShvdXRCdWZmZXIsIGNvcHlJbmRleCk7XG4gICAgICAgIGNvcHlJbmRleCArPSA0O1xuICAgICAgICBlbGVtLmNvcHkob3V0QnVmZmVyLCBjb3B5SW5kZXgpO1xuICAgICAgICBjb3B5SW5kZXggKz0gZWxlbS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0QnVmZmVyO1xuICAgIH07XG4gIH07XG5cbiAgZXhwb3J0cy5hcHBseVRyYW5zZm9ybSA9IGZ1bmN0aW9uKGJ1ZmZlciwgbVRyYW5zZm9ybSwgYnVuZGxlVHJhbnNmb3JtKSB7XG4gICAgaWYgKGJ1bmRsZVRyYW5zZm9ybSA9PSBudWxsKSB7XG4gICAgICBidW5kbGVUcmFuc2Zvcm0gPSBleHBvcnRzLmFwcGx5TWVzc2FnZVRyYW5mb3JtZXJUb0J1bmRsZShtVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgaWYgKGlzT3NjQnVuZGxlQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICAgIHJldHVybiBidW5kbGVUcmFuc2Zvcm0oYnVmZmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1UcmFuc2Zvcm0oYnVmZmVyKTtcbiAgICB9XG4gIH07XG5cbiAgZXhwb3J0cy5hZGRyZXNzVHJhbnNmb3JtID0gZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgdmFyIHJlZiwgcmVzdCwgc3RyaW5nO1xuICAgICAgcmVmID0gZXhwb3J0cy5zcGxpdE9zY1N0cmluZyhidWZmZXIpLCBzdHJpbmcgPSByZWYuc3RyaW5nLCByZXN0ID0gcmVmLnJlc3Q7XG4gICAgICBzdHJpbmcgPSB0cmFuc2Zvcm0oc3RyaW5nKTtcbiAgICAgIHJldHVybiBleHBvcnRzLmNvbmNhdChbZXhwb3J0cy50b09zY1N0cmluZyhzdHJpbmcpLCByZXN0XSk7XG4gICAgfTtcbiAgfTtcblxuICBleHBvcnRzLm1lc3NhZ2VUcmFuc2Zvcm0gPSBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICB2YXIgbWVzc2FnZTtcbiAgICAgIG1lc3NhZ2UgPSBleHBvcnRzLmZyb21Pc2NNZXNzYWdlKGJ1ZmZlcik7XG4gICAgICByZXR1cm4gZXhwb3J0cy50b09zY01lc3NhZ2UodHJhbnNmb3JtKG1lc3NhZ2UpKTtcbiAgICB9O1xuICB9O1xuXG4gIElzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gIFN0cmljdEVycm9yID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIlN0cmljdCBFcnJvcjogXCIgKyBzdHIpO1xuICB9O1xuXG4gIHBhZGRpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgYnVmZmxlbmd0aDtcbiAgICBidWZmbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyKTtcbiAgICByZXR1cm4gNCAtIChidWZmbGVuZ3RoICUgNCk7XG4gIH07XG5cbiAgaXNPc2NCdW5kbGVCdWZmZXIgPSBmdW5jdGlvbihidWZmZXIsIHN0cmljdCkge1xuICAgIHZhciBzdHJpbmc7XG4gICAgc3RyaW5nID0gZXhwb3J0cy5zcGxpdE9zY1N0cmluZyhidWZmZXIsIHN0cmljdCkuc3RyaW5nO1xuICAgIHJldHVybiBzdHJpbmcgPT09IFwiXFwjYnVuZGxlXCI7XG4gIH07XG5cbiAgbWFwQnVuZGxlTGlzdCA9IGZ1bmN0aW9uKGJ1ZmZlciwgZnVuYykge1xuICAgIHZhciBlLCBlbGVtLCBlbGVtcywgaiwgbGVuLCBub25OdWxsRWxlbXMsIHNpemUsIHRoaXNFbGVtQnVmZmVyO1xuICAgIGVsZW1zID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlZiwgcmVzdWx0cztcbiAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgIHdoaWxlIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHJlZiA9IGV4cG9ydHMuc3BsaXRJbnRlZ2VyKGJ1ZmZlciksIHNpemUgPSByZWYuaW50ZWdlciwgYnVmZmVyID0gcmVmLnJlc3Q7XG4gICAgICAgIGlmIChzaXplID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnVuZGxlIGxpc3Q6IHNpemUgb2YgZWxlbWVudCBpcyBiaWdnZXIgdGhhbiBidWZmZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc0VsZW1CdWZmZXIgPSBidWZmZXIuc2xpY2UoMCwgc2l6ZSk7XG4gICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShzaXplLCBidWZmZXIubGVuZ3RoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goZnVuYyh0aGlzRWxlbUJ1ZmZlcikpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGUgPSBlcnJvcjtcbiAgICAgICAgICByZXN1bHRzLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0pKCk7XG4gICAgbm9uTnVsbEVsZW1zID0gW107XG4gICAgZm9yIChqID0gMCwgbGVuID0gZWxlbXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIGVsZW0gPSBlbGVtc1tqXTtcbiAgICAgIGlmIChlbGVtICE9IG51bGwpIHtcbiAgICAgICAgbm9uTnVsbEVsZW1zLnB1c2goZWxlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub25OdWxsRWxlbXM7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCAiKGZ1bmN0aW9uKCkge1xuICBcbi8vfnJlYWRtZS5vdXR+XG4vL1shW2J1aWxkIHN0YXR1c10oaHR0cHM6Ly9zZWN1cmUudHJhdmlzLWNpLm9yZy9ydXNzZWxsbWNjL25vZGUtb3NjLW1pbi5wbmcpXShodHRwOi8vdHJhdmlzLWNpLm9yZy9ydXNzZWxsbWNjL25vZGUtb3NjLW1pbikgWyFbQ292ZXJhZ2UgU3RhdHVzXShodHRwczovL2NvdmVyYWxscy5pby9yZXBvcy9ydXNzZWxsbWNjL25vZGUtb3NjLW1pbi9iYWRnZS5wbmc/YnJhbmNoPW1hc3RlcildKGh0dHBzOi8vY292ZXJhbGxzLmlvL3IvcnVzc2VsbG1jYy9ub2RlLW9zYy1taW4/YnJhbmNoPW1hc3RlcikgWyFbZGVwZW5kZW5jaWVzXShodHRwczovL2RhdmlkLWRtLm9yZy9ydXNzZWxsbWNjL25vZGUtb3NjLW1pbi5wbmcpXShodHRwczovL2RhdmlkLWRtLm9yZy9ydXNzZWxsbWNjL25vZGUtb3NjLW1pbilcbi8vIyBvc2MtbWluXG4vLyBcbi8vIF9zaW1wbGUgdXRpbGl0aWVzIGZvciBvcGVuIHNvdW5kIGNvbnRyb2wgaW4gbm9kZS5qc19cbi8vXG4vLyBUaGlzIHBhY2thZ2UgcHJvdmlkZXMgc29tZSBub2RlLmpzIHV0aWxpdGllcyBmb3Igd29ya2luZyB3aXRoIFxuLy8gW09TQ10oaHR0cDovL29wZW5zb3VuZGNvbnRyb2wub3JnLyksIGEgZm9ybWF0IGZvciBzb3VuZCBhbmQgc3lzdGVtcyBjb250cm9sLiAgXG4vLyBIZXJlIHdlIGltcGxlbWVudCB0aGUgW09TQyAxLjFdW3NwZWMxMV0gc3BlY2lmaWNhdGlvbi4gIE9TQyBpcyBhIHRyYW5zcG9ydC1pbmRlcGVuZGVudFxuLy8gcHJvdG9jb2wsIHNvIHdlIGRvbid0IHByb3ZpZGUgYW55IHNlcnZlciBvYmplY3RzLCBhcyB5b3Ugc2hvdWxkIGJlIGFibGUgdG8gXG4vLyB1c2UgT1NDIG92ZXIgYW55IHRyYW5zcG9ydCB5b3UgbGlrZS4gIFRoZSBtb3N0IGNvbW1vbiBpcyBwcm9iYWJseSB1ZHAsIGJ1dCB0Y3Bcbi8vIGlzIG5vdCB1bmhlYXJkIG9mLlxuLy9cbi8vIFtzcGVjMTFdOiBodHRwOi8vb3BlbnNvdW5kY29udHJvbC5vcmcvc3BlYy0xXzFcbi8vXG4vLy0tLS1cbi8vIyMgSW5zdGFsbGF0aW9uXG4vL35pbnN0YWxsYXRpb25+XG4vLy0tLS1cbi8vIyMgRXhhbXBsZXNcbi8vfmV4YW1wbGVzflxuLy9cbi8vIG1vcmUgZXhhbXBsZXMgYXJlIGF2YWlsYWJsZSBpbiB0aGUgYGV4YW1wbGVzL2AgZGlyZWN0b3J5LlxuLy9cbi8vLS0tLVxuLy9+YXBpflxuLy8tLS0tXG4vL35yZXByZXNlbnRhdGlvbn5cbi8vLS0tLVxuLy8jIyBMaWNlbnNlXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgZm91bmQgaW4gQ09QWUlORyAoemxpYiBsaWNlbnNlKVxuXG4vL35yZXByZXNlbnRhdGlvbn5cbi8vIyMgSmF2YXNjcmlwdCByZXByZXNlbnRhdGlvbnMgb2YgdGhlIE9TQyB0eXBlcy4gIFxuLy8gU2VlIHRoZSBbc3BlY11bc3BlY10gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIE9TQyB0eXBlcy5cbi8vXG4vLyArIEFuIF9PU0MgUGFja2V0XyBpcyBhbiBfT1NDIE1lc3NhZ2VfIG9yIGFuIF9PU0MgQnVuZGxlXy5cbi8vXG4vLyArIEFuIF9PU0MgTWVzc2FnZV86XG4vL1xuLy8gICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgb3NjVHlwZSA6IFwibWVzc2FnZVwiXG4vLyAgICAgICAgICAgICAgIGFkZHJlc3MgOiBcIi9hZGRyZXNzL3BhdHRlcm4vbWlnaHQvaGF2ZS93aWxkY2FyZHNcIlxuLy8gICAgICAgICAgICAgICBhcmdzIDogW2FyZzEsYXJnMl1cbi8vICAgICAgICAgICB9XG4vL1xuLy8gICAgV2hlcmUgYXJncyBpcyBhbiBhcnJheSBvZiBfT1NDIEFyZ3VtZW50c18uICBgb3NjVHlwZWAgaXMgb3B0aW9uYWwuXG4vLyAgICBgYXJnc2AgY2FuIGJlIGEgc2luZ2xlIGVsZW1lbnQuXG4vL1xuLy8gKyBBbiBfT1NDIEFyZ3VtZW50XyBpcyByZXByZXNlbnRlZCBhcyBhIGphdmFzY3JpcHQgb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBsYXlvdXQ6XG4vL1xuLy8gICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgdHlwZSA6IFwic3RyaW5nXCJcbi8vICAgICAgICAgICAgICAgdmFsdWUgOiBcInZhbHVlXCJcbi8vICAgICAgICAgICB9XG4vL1xuLy8gICAgV2hlcmUgdGhlIGB0eXBlYCBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbi8vICAgICsgYHN0cmluZ2AgLSBzdHJpbmcgdmFsdWVcbi8vICAgICsgYGZsb2F0YCAtIG51bWVyaWMgdmFsdWVcbi8vICAgICsgYGludGVnZXJgIC0gbnVtZXJpYyB2YWx1ZVxuLy8gICAgKyBgYmxvYmAgLSBub2RlLmpzIEJ1ZmZlciB2YWx1ZVxuLy8gICAgKyBgdHJ1ZWAgLSB2YWx1ZSBpcyBib29sZWFuIHRydWVcbi8vICAgICsgYGZhbHNlYCAtIHZhbHVlIGlzIGJvb2xlYW4gZmFsc2Vcbi8vICAgICsgYG51bGxgIC0gbm8gdmFsdWVcbi8vICAgICsgYGJhbmdgIC0gbm8gdmFsdWUgKHRoaXMgaXMgdGhlIGBJYCB0eXBlIHRhZylcbi8vICAgICsgYHRpbWV0YWdgIC0gbnVtZXJpYyB2YWx1ZVxuLy8gICAgKyBgYXJyYXlgIC0gYXJyYXkgb2YgX09TQyBBcmd1bWVudHNfXG4vLyBcbi8vICAgIE5vdGUgdGhhdCBgdHlwZWAgaXMgYWx3YXlzIGEgc3RyaW5nIC0gaS5lLiBgXCJ0cnVlXCJgIHJhdGhlciB0aGFuIGB0cnVlYC5cbi8vICAgXG4vLyAgICBUaGUgZm9sbG93aW5nIG5vbi1zdGFuZGFyZCB0eXBlcyBhcmUgYWxzbyBzdXBwb3J0ZWQ6XG4vLyAgICArIGBkb3VibGVgIC0gbnVtZXJpYyB2YWx1ZSAoZW5jb2RlcyB0byBhIGZsb2F0NjQgdmFsdWUpXG4vL1xuLy8gICAgXG4vLyAgICBGb3IgbWVzc2FnZXMgc2VudCB0byB0aGUgYHRvQnVmZmVyYCBmdW5jdGlvbiwgYHR5cGVgIGlzIG9wdGlvbmFsLlxuLy8gICAgSWYgdGhlIGFyZ3VtZW50IGlzIG5vdCBhbiBvYmplY3QsIGl0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgZWl0aGVyXG4vLyAgICBgc3RyaW5nYCwgYGZsb2F0YCwgYGFycmF5YCBvciBgYmxvYmAsIGRlcGVuZGluZyBvbiBpdHMgamF2YXNjcmlwdCB0eXBlXG4vLyAgICAoU3RyaW5nLCBOdW1iZXIsIEFycmF5LCBCdWZmZXIsIHJlc3BlY3RpdmVseSlcbi8vXG4vLyArIEFuIF9PU0MgQnVuZGxlXyBpcyByZXByZXNlbnRlZCBhcyBhIGphdmFzY3JpcHQgb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4vL1xuLy8gICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgb3NjVHlwZSA6IFwiYnVuZGxlXCJcbi8vICAgICAgICAgICAgICAgdGltZXRhZyA6IDdcbi8vICAgICAgICAgICAgICAgZWxlbWVudHMgOiBbZWxlbWVudDEsIGVsZW1lbnRdXG4vLyAgICAgICAgICAgfVxuLy9cbi8vICAgYG9zY1R5cGVgIFwiYnVuZGxlXCJcbi8vXG4vLyAgIGB0aW1ldGFnYCBpcyBvbmUgb2Y6XG4vLyAgICAtIGBudWxsYCAtIG1lYW5pbmcgbm93LCB0aGUgY3VycmVudCB0aW1lLlxuLy8gICAgICBCeSB0aGUgdGltZSB0aGUgYnVuZGxlIGlzIHJlY2VpdmVkIGl0IHdpbGwgdG9vIGxhdGUgYW5kIGRlcGVuZGluZ1xuLy8gICAgICBvbiB0aGUgcmVjZWl2ZXIgbWF5IGJlIGRpc2NhcmRlZCBvciB5b3UgbWF5IGJlIHNjb2xkZWQgZm9yIGJlaW5nIGxhdGUuXG4vLyAgICAtIGBudW1iZXJgIC0gcmVsYXRpdmUgc2Vjb25kcyBmcm9tIG5vdyB3aXRoIG1pbGxpc2Vjb25kIGFjY3VyYWN5LlxuLy8gICAgLSBgRGF0ZWAgLSBhIEphdmFTY3JpcHQgRGF0ZSBvYmplY3QgaW4geW91ciBsb2NhbCB0aW1lIHpvbmUuXG4vLyAgICAgT1NDIHRpbWV0YWdzIHVzZSBVVEMgdGltZXpvbmUsIHNvIGRvIG5vdCB0cnkgdG8gYWRqdXN0IGZvciB0aW1lem9uZXMsXG4vLyAgICAgdGhpcyBpcyBub3QgbmVlZGVkLlxuLy8gICAgLSBgQXJyYXlgIC0gYFtudW1iZXJPZlNlY29uZHNTaW5jZTE5MDAsIGZyYWN0aW9uYWxTZWNvbmRzXWBcbi8vICAgICAgQm90aCB2YWx1ZXMgYXJlIGBudW1iZXJgcy4gVGhpcyBnaXZlcyBmdWxsIHRpbWluZyBhY2N1cmFjeSBvZiAxLygyXjMyKSBzZWNvbmRzLlxuLy9cbi8vICBgZWxlbWVudHNgIGlzIGFuIGBBcnJheWAgb2YgZWl0aGVyIF9PU0MgTWVzc2FnZV8gb3IgX09TQyBCdW5kbGVfXG4vL1xuLy9cbi8vIFtzcGVjXTogaHR0cDovL29wZW5zb3VuZGNvbnRyb2wub3JnL3NwZWMtMV8wXG5cbiAgdmFyIHV0aWxzLCBjb2ZmZWU7XG4gIHV0aWxzID0gcmVxdWlyZShcIi4vb3NjLXV0aWxpdGllc1wiKTtcbi8vIH5hcGl+XG4vLyMjIEV4cG9ydGVkIGZ1bmN0aW9uc1xuLy9cbi8vLS0tLS0tXG4vLyMjIyAuZnJvbUJ1ZmZlcihidWZmZXIsIFtzdHJpY3RdKVxuLy8gdGFrZXMgYSBub2RlLmpzIEJ1ZmZlciBvZiBhIGNvbXBsZXRlIF9PU0MgUGFja2V0XyBhbmQgXG4vLyBvdXRwdXRzIHRoZSBqYXZhc2NyaXB0IHJlcHJlc2VudGF0aW9uLCBvciB0aHJvd3MgaWYgdGhlIGJ1ZmZlciBpcyBpbGwtZm9ybWVkLlxuLy9cbi8vIGBzdHJpY3RgIGlzIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IG1ha2VzIHRoZSBmdW5jdGlvbiBmYWlsIG1vcmUgb2Z0ZW4uXG4gIGV4cG9ydHMuZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlciwgc3RyaWN0KSB7XG4gICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICBidWZmZXIgPSBuZXcgQnVmZmVyKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuICAgIH0gZWxzZSBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgYnVmZmVyID0gbmV3IEJ1ZmZlcihidWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuZnJvbU9zY1BhY2tldChidWZmZXIsIHN0cmljdCk7XG4gIH07XG5cbi8vfmFwaX5cbi8vLS0tLVxuLy8jIyMgLnRvQnVmZmVyKG9iamVjdCwgW3N0cmljdF0pXG4vLyB0YWtlcyBhIF9PU0MgcGFja2V0XyBqYXZhc2NyaXB0IHJlcHJlc2VudGF0aW9uIGFzIGRlZmluZWQgYmVsb3cgYW5kIHJldHVybnNcbi8vIGEgbm9kZS5qcyBCdWZmZXIsIG9yIHRocm93cyBpZiB0aGUgcmVwcmVzZW50YXRpb24gaXMgaWxsLWZvcm1lZC5cbi8vXG4vLyBTZWUgXCJKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9ucyBvZiB0aGUgT1NDIHR5cGVzXCIgYmVsb3cuXG4vL1xuLy8tLS0tXG4vLyMjIyAudG9CdWZmZXIoYWRkcmVzcywgYXJnc1tdLCBbc3RyaWN0XSlcbi8vIGFsdGVybmF0aXZlIHN5bnRheCBmb3IgYWJvdmUuICBBc3N1bWVzIHRoaXMgaXMgYW4gX09TQyBNZXNzYWdlXyBhcyBkZWZpbmVkIGJlbG93LFxuLy8gYW5kIGBhcmdzYCBpcyBhbiBhcnJheSBvZiBfT1NDIEFyZ3VtZW50c18gb3Igc2luZ2xlIF9PU0MgQXJndW1lbnRfXG4gIGV4cG9ydHMudG9CdWZmZXIgPSBmdW5jdGlvbihvYmplY3QsIHN0cmljdCwgb3B0KSB7XG4gICAgaWYodHlwZW9mIG9iamVjdCA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiB1dGlscy50b09zY1BhY2tldCh7J2FkZHJlc3MnIDogb2JqZWN0LCAnYXJncycgOiBzdHJpY3R9LCBvcHQpO1xuICAgIHJldHVybiB1dGlscy50b09zY1BhY2tldChvYmplY3QsIHN0cmljdCk7XG4gIH07XG5cbi8vfmFwaX5cbi8vLS0tLVxuLy8jIyMgLmFwcGx5QWRkcmVzc1RyYW5zZm9ybShidWZmZXIsIHRyYW5zZm9ybSlcbi8vIHRha2VzIGEgY2FsbGJhY2sgdGhhdCB0YWtlcyBhIHN0cmluZyBhbmQgb3V0cHV0cyBhIHN0cmluZyxcbi8vIGFuZCBhcHBsaWVzIHRoYXQgdG8gdGhlIGFkZHJlc3Mgb2YgdGhlIG1lc3NhZ2UgZW5jb2RlZCBpbiB0aGUgYnVmZmVyLFxuLy8gYW5kIG91dHB1dHMgYW4gZW5jb2RlZCBidWZmZXIuXG4vL1xuLy8gSWYgdGhlIGJ1ZmZlciBlbmNvZGVzIGFuIF9PU0MgQnVuZGxlXywgdGhpcyBhcHBsaWVzIHRoZSBmdW5jdGlvbiB0byBlYWNoIGFkZHJlc3MgXG4vLyBpbiB0aGUgYnVuZGxlLlxuLy9cbi8vIFRoZXJlJ3MgdHdvIHN1YnRsZSByZWFzb25zIHlvdSdkIHdhbnQgdG8gdXNlIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gXG4vLyBjb21wb3NpbmcgYGZyb21CdWZmZXJgIGFuZCBgdG9CdWZmZXJgOlxuLy8gICAtIEZ1dHVyZS1wcm9vZmluZyAtIGlmIHRoZSBPU0MgbWVzc2FnZSB1c2VzIGFuIGFyZ3VtZW50IHR5cGVjb2RlIHRoYXRcbi8vICAgICB3ZSBkb24ndCB1bmRlcnN0YW5kLCBjYWxsaW5nIGBmcm9tQnVmZmVyYCB3aWxsIHRocm93LiAgVGhlIG9ubHkgdGltZVxuLy8gICAgIHdoZW4gYGFwcGx5QWRkcmVzc1RyYW5mb3JtYCBtaWdodCBmYWlsIGlzIGlmIHRoZSBhZGRyZXNzIGlzIG1hbGZvcm1lZC5cbi8vICAgLSBBY2N1cmFjeSAtIGphdmFzY3JpcHQgcmVwcmVzZW50cyBudW1iZXJzIGFzIDY0LWJpdCBmbG9hdHMsIHNvIHNvbWVcbi8vICAgICBPU0MgdHlwZXMgd2lsbCBub3QgYmUgYWJsZSB0byBiZSByZXByZXNlbnRlZCBhY2N1cmF0ZWx5LiAgSWYgYWNjdXJhY3lcbi8vICAgICBpcyBpbXBvcnRhbnQgdG8geW91LCB0aGVuLCB5b3Ugc2hvdWxkIG5ldmVyIGNvbnZlcnQgdGhlIE9TQyBtZXNzYWdlIHRvIGFcbi8vICAgICBqYXZhc2NyaXB0IHJlcHJlc2VudGF0aW9uLlxuICBleHBvcnRzLmFwcGx5QWRkcmVzc1RyYW5zZm9ybSA9IGZ1bmN0aW9uKGJ1ZmZlciwgdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIHV0aWxzLmFwcGx5VHJhbnNmb3JtKGJ1ZmZlciwgdXRpbHMuYWRkcmVzc1RyYW5zZm9ybSh0cmFuc2Zvcm0pKTtcbiAgfTtcbiAgXG4vL35hcGl+XG4vLy0tLS1cbi8vIyMjIC5hcHBseU1lc3NhZ2VUcmFuc2Zvcm0oYnVmZmVyLCB0cmFuc2Zvcm0pXG4vLyB0YWtlcyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW5kIHJldHVybnMgYSBqYXZhc2NyaXB0IF9PU0MgTWVzc2FnZV8gcmVwcmVzZW50YXRpb24sXG4vLyBhbmQgYXBwbGllcyB0aGF0IHRvIGVhY2ggbWVzc2FnZSBlbmNvZGVkIGluIHRoZSBidWZmZXIsXG4vLyBhbmQgb3V0cHV0cyBhIG5ldyBidWZmZXIgd2l0aCB0aGUgbmV3IGFkZHJlc3MuXG4vL1xuLy8gSWYgdGhlIGJ1ZmZlciBlbmNvZGVzIGFuIG9zYy1idW5kbGUsIHRoaXMgYXBwbGllcyB0aGUgZnVuY3Rpb24gdG8gZWFjaCBtZXNzYWdlIFxuLy8gaW4gdGhlIGJ1bmRsZS5cbi8vXG4vLyBTZWUgbm90ZXMgYWJvdmUgZm9yIGFwcGx5QWRkcmVzc1RyYW5zZm9ybSBmb3Igd2h5IHlvdSBtaWdodCB3YW50IHRvIHVzZSB0aGlzLlxuLy8gV2hpbGUgdGhpcyBkb2VzIHBhcnNlIGFuZCByZS1wYWNrIHRoZSBtZXNzYWdlcywgdGhlIGJ1bmRsZSB0aW1ldGFncyBhcmUgbGVmdFxuLy8gaW4gdGhlaXIgYWNjdXJhdGUgYW5kIHByZXN0aW5lIHN0YXRlLlxuICBleHBvcnRzLmFwcGx5TWVzc2FnZVRyYW5zZm9ybSA9IGZ1bmN0aW9uKGJ1ZmZlciwgdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIHV0aWxzLmFwcGx5VHJhbnNmb3JtKGJ1ZmZlciwgdXRpbHMubWVzc2FnZVRyYW5zZm9ybSh0cmFuc2Zvcm0pKTtcbiAgfTtcblxuXG4vL35hcGl+XG4vLy0tLS1cbi8vIyMjIC50aW1ldGFnVG9EYXRlKG50cFRpbWVUYWcpXG4vLyBDb252ZXJ0IGEgdGltZXRhZyBhcnJheSB0byBhIEphdmFTY3JpcHQgRGF0ZSBvYmplY3QgaW4geW91ciBsb2NhbCB0aW1lem9uZS5cbi8vXG4vLyBSZWNlaXZlZCBPU0MgYnVuZGxlcyBjb252ZXJ0ZWQgd2l0aCBgZnJvbUJ1ZmZlcmAgd2lsbCBoYXZlIGEgdGltZXRhZyBhcnJheTpcbi8vIFtzZWNvbmRzU2luY2UxOTcwLCBmcmFjdGlvbmFsU2Vjb25kc11cbi8vIFRoaXMgdXRpbGl0eSBpcyB1c2VmdWwgZm9yIGxvZ2dpbmcuIEFjY3VyYWN5IGlzIHJlZHVjZWQgdG8gbWlsbGlzZWNvbmRzLlxuICBleHBvcnRzLnRpbWV0YWdUb0RhdGUgPSB1dGlscy50aW1ldGFnVG9EYXRlO1xuXG4vL35hcGl+XG4vLy0tLS1cbi8vIyMjIC5kYXRlVG9UaW1ldGFnKGRhdGUpXG4vLyBDb252ZXJ0IGEgSmF2YVNjcmlwdCBEYXRlIHRvIGEgTlRQIHRpbWV0YWcgYXJyYXkgW3NlY29uZHNTaW5jZTE5NzAsIGZyYWN0aW9uYWxTZWNvbmRzXS5cbi8vXG4vLyBgdG9CdWZmZXJgIGFscmVhZHkgYWNjZXB0cyBEYXRlcyBmb3IgdGltZXRhZ3Mgc28geW91IG1pZ2h0IG5vdCBuZWVkIHRoaXMgZnVuY3Rpb24uIElmIHlvdSBuZWVkIHRvIHNjaGVkdWxlIGJ1bmRsZXMgd2l0aCBmaW5lciB0aGFuIG1pbGxpc2Vjb25kIGFjY3VyYWN5IHRoZW4geW91IGNvdWxkIHVzZSB0aGlzIHRvIGhlbHAgYXNzZW1ibGUgdGhlIE5UUCBhcnJheS5cbiAgZXhwb3J0cy5kYXRlVG9UaW1ldGFnID0gdXRpbHMuZGF0ZVRvVGltZXRhZztcblxuLy9+YXBpflxuLy8tLS0tXG4vLyMjIyAudGltZXRhZ1RvVGltZXN0YW1wKHRpbWVUYWcpXG4vLyBDb252ZXJ0IGEgdGltZXRhZyBhcnJheSB0byB0aGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIFVOSVggZXBvY2guXG4vL1xuICBleHBvcnRzLnRpbWV0YWdUb1RpbWVzdGFtcCA9IHV0aWxzLnRpbWV0YWdUb1RpbWVzdGFtcDtcblxuLy9+YXBpflxuLy8tLS0tXG4vLyMjIyAudGltZXN0YW1wVG9UaW1ldGFnKHRpbWVTdGFtcClcbi8vIENvbnZlcnQgYSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSB0aGUgVU5JWCBlcG9jaCB0byBhIHRpbWV0YWcgYXJyYXkuXG4vL1xuICBleHBvcnRzLnRpbWVzdGFtcFRvVGltZXRhZyA9IHV0aWxzLnRpbWVzdGFtcFRvVGltZXRhZztcblxufSkuY2FsbCh0aGlzKTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBvc2NNaW4gPSByZXF1aXJlKCdvc2MtbWluJyk7XG5cbmZ1bmN0aW9uIHNhbml0aXplTWVzc2FnZShkZWNvZGVkKSB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBbXTtcbiAgbWVzc2FnZS5wdXNoKGRlY29kZWQuYWRkcmVzcyk7XG4gIGRlY29kZWQuYXJncy5mb3JFYWNoKGFyZyA9PiB7XG4gICAgbWVzc2FnZS5wdXNoKGFyZy52YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gbWVzc2FnZTtcbn1cblxuZnVuY3Rpb24gc2FuaXRpemVCdW5kbGUoZGVjb2RlZCkge1xuICBkZWNvZGVkLmVsZW1lbnRzID0gZGVjb2RlZC5lbGVtZW50cy5tYXAoZWxlbWVudCA9PiB7XG4gICAgaWYgKGVsZW1lbnQub3NjVHlwZSA9PT0gJ2J1bmRsZScpIHJldHVybiBzYW5pdGl6ZUJ1bmRsZShlbGVtZW50KTtcbiAgICBlbHNlIGlmIChlbGVtZW50Lm9zY1R5cGUgPT09ICdtZXNzYWdlJykgcmV0dXJuIHNhbml0aXplTWVzc2FnZShlbGVtZW50KTtcbiAgfSk7XG4gIHJldHVybiBkZWNvZGVkO1xufVxuXG5mdW5jdGlvbiBkZWNvZGUoZGF0YSkge1xuICBjb25zdCBkZWNvZGVkID0gb3NjTWluLmZyb21CdWZmZXIoZGF0YSk7XG4gIGlmIChkZWNvZGVkLm9zY1R5cGUgPT09ICdidW5kbGUnKSB7XG4gICAgcmV0dXJuIHNhbml0aXplQnVuZGxlKGRlY29kZWQpO1xuICB9XG4gIGVsc2UgaWYgKGRlY29kZWQub3NjVHlwZSA9PT0gJ21lc3NhZ2UnKSB7XG4gICAgcmV0dXJuIHNhbml0aXplTWVzc2FnZShkZWNvZGVkKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IgKCdNYWxmb3JtZWQgUGFja2V0Jyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWNvZGU7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9kZV9kZ3JhbSA9IHJlcXVpcmUoJ25vZGU6ZGdyYW0nKTtcbnZhciBub2RlX2V2ZW50cyA9IHJlcXVpcmUoJ25vZGU6ZXZlbnRzJyk7XG52YXIgZGVjb2RlID0gcmVxdWlyZSgnI2RlY29kZScpO1xuXG5jbGFzcyBTZXJ2ZXIgZXh0ZW5kcyBub2RlX2V2ZW50cy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcihwb3J0LCBob3N0PScxMjcuMC4wLjEnLCBjYikge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKHR5cGVvZiBob3N0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGhvc3Q7XG4gICAgICBob3N0ID0gJzEyNy4wLjAuMSc7XG4gICAgfVxuICAgIGlmICghY2IpIGNiID0gKCkgPT4ge307XG4gICAgbGV0IGRlY29kZWQ7XG4gICAgdGhpcy5wb3J0ID0gcG9ydDtcbiAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgIHRoaXMuX3NvY2sgPSBub2RlX2RncmFtLmNyZWF0ZVNvY2tldCh7XG4gICAgICB0eXBlOiAndWRwNCcsXG4gICAgICByZXVzZUFkZHI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLl9zb2NrLmJpbmQocG9ydCwgaG9zdCk7XG4gICAgdGhpcy5fc29jay5vbignbGlzdGVuaW5nJywgKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdsaXN0ZW5pbmcnKTtcbiAgICAgIGNiKCk7XG4gICAgfSk7XG4gICAgdGhpcy5fc29jay5vbignbWVzc2FnZScsIChtc2csIHJpbmZvKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBkZWNvZGVkID0gZGVjb2RlKG1zZyk7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgY2FuJ3QgZGVjb2RlIGluY29taW5nIG1lc3NhZ2U6ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IsIHJpbmZvKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRlY29kZWQuZWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdidW5kbGUnLCBkZWNvZGVkLCByaW5mbyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChkZWNvZGVkKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRlY29kZWQsIHJpbmZvKTtcbiAgICAgICAgdGhpcy5lbWl0KGRlY29kZWRbMF0sIGRlY29kZWQsIHJpbmZvKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjbG9zZShjYikge1xuICAgIHRoaXMuX3NvY2suY2xvc2UoY2IpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VydmVyO1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIG5vZGVfZGdyYW0gPSByZXF1aXJlKCdub2RlOmRncmFtJyk7XG52YXIgb3NjTWluID0gcmVxdWlyZSgnb3NjLW1pbicpO1xudmFyIE1lc3NhZ2UgPSByZXF1aXJlKCcuL01lc3NhZ2UuanMnKTtcblxuY29uc3QgeyB0b0J1ZmZlciB9ID0gb3NjTWluO1xuXG5jbGFzcyBDbGllbnQge1xuICBjb25zdHJ1Y3Rvcihob3N0LCBwb3J0KSB7XG4gICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICB0aGlzLnBvcnQgPSBwb3J0O1xuICAgIHRoaXMuX3NvY2sgPSBub2RlX2RncmFtLmNyZWF0ZVNvY2tldCh7XG4gICAgICB0eXBlOiAndWRwNCcsXG4gICAgICByZXVzZUFkZHI6IHRydWVcbiAgICB9KTtcbiAgfVxuICBjbG9zZShjYikge1xuICAgIHRoaXMuX3NvY2suY2xvc2UoY2IpO1xuICB9XG4gIHNlbmQoLi4uYXJncykge1xuICAgIGxldCBtZXNzYWdlID0gYXJnc1swXTtcbiAgICBsZXQgY2FsbGJhY2s7XG4gICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYWxsYmFjayA9ICgpID0+IHt9O1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIG1lc3NhZ2UgPSB7XG4gICAgICAgIGFkZHJlc3M6IG1lc3NhZ2VbMF0sXG4gICAgICAgIGFyZ3M6IG1lc3NhZ2Uuc3BsaWNlKDEpXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBsZXQgbWVzO1xuICAgIGxldCBidWY7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAodHlwZW9mIG1lc3NhZ2UpIHtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICBidWYgPSB0b0J1ZmZlcihtZXNzYWdlKTtcbiAgICAgICAgICB0aGlzLl9zb2NrLnNlbmQoYnVmLCAwLCBidWYubGVuZ3RoLCB0aGlzLnBvcnQsIHRoaXMuaG9zdCwgY2FsbGJhY2spO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgIG1lcyA9IG5ldyBNZXNzYWdlKGFyZ3NbMF0pO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbWVzLmFwcGVuZChhcmdzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmID0gdG9CdWZmZXIobWVzKTtcbiAgICAgICAgICB0aGlzLl9zb2NrLnNlbmQoYnVmLCAwLCBidWYubGVuZ3RoLCB0aGlzLnBvcnQsIHRoaXMuaG9zdCwgY2FsbGJhY2spO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoYXQgTWVzc2FnZSBKdXN0IERvZXNuXFwndCBTZWVtIFJpZ2h0Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5jb2RlICE9PSAnRVJSX1NPQ0tFVF9ER1JBTV9OT1RfUlVOTklORycpIHRocm93IGU7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBSZWZlcmVuY2VFcnJvcignQ2Fubm90IHNlbmQgbWVzc2FnZSBvbiBjbG9zZWQgc29ja2V0LicpO1xuICAgICAgZXJyb3IuY29kZSA9IGUuY29kZTtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnQ7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTWVzc2FnZSA9IHJlcXVpcmUoJy4vTWVzc2FnZS5qcycpO1xudmFyIEJ1bmRsZSA9IHJlcXVpcmUoJy4vQnVuZGxlLmpzJyk7XG52YXIgU2VydmVyID0gcmVxdWlyZSgnLi9TZXJ2ZXIuanMnKTtcbnZhciBDbGllbnQgPSByZXF1aXJlKCcuL0NsaWVudC5qcycpO1xuXG5cblxuZXhwb3J0cy5NZXNzYWdlID0gTWVzc2FnZTtcbmV4cG9ydHMuQnVuZGxlID0gQnVuZGxlO1xuZXhwb3J0cy5TZXJ2ZXIgPSBTZXJ2ZXI7XG5leHBvcnRzLkNsaWVudCA9IENsaWVudDtcbiIsICIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCAiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXHRjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXHRcdGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG5cdFx0bGV0IG5hbWVzcGFjZXNDYWNoZTtcblx0XHRsZXQgZW5hYmxlZENhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0aWYgKGVuYWJsZU92ZXJyaWRlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuYWJsZU92ZXJyaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuYW1lc3BhY2VzQ2FjaGUgIT09IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMpIHtcblx0XHRcdFx0XHRuYW1lc3BhY2VzQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzO1xuXHRcdFx0XHRcdGVuYWJsZWRDYWNoZSA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbmFibGVkQ2FjaGU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXHRcdGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc2xpY2UoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0KiBYWFggRE8gTk9UIFVTRS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzdHViIGZ1bmN0aW9uLlxuXHQqIFhYWCBJdCBXSUxMIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblx0Ki9cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiIsICIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbmV4cG9ydHMuZGVzdHJveSA9ICgoKSA9PiB7XG5cdGxldCB3YXJuZWQgPSBmYWxzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmICghd2FybmVkKSB7XG5cdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdFx0fVxuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0bGV0IG07XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgKG0gPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSkgJiYgcGFyc2VJbnQobVsxXSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqIElmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlLCBmYWxscyBiYWNrXG4gKiB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge30pO1xuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZsYWcsIGFyZ3YgPSBwcm9jZXNzLmFyZ3YpID0+IHtcblx0Y29uc3QgcHJlZml4ID0gZmxhZy5zdGFydHNXaXRoKCctJykgPyAnJyA6IChmbGFnLmxlbmd0aCA9PT0gMSA/ICctJyA6ICctLScpO1xuXHRjb25zdCBwb3NpdGlvbiA9IGFyZ3YuaW5kZXhPZihwcmVmaXggKyBmbGFnKTtcblx0Y29uc3QgdGVybWluYXRvclBvc2l0aW9uID0gYXJndi5pbmRleE9mKCctLScpO1xuXHRyZXR1cm4gcG9zaXRpb24gIT09IC0xICYmICh0ZXJtaW5hdG9yUG9zaXRpb24gPT09IC0xIHx8IHBvc2l0aW9uIDwgdGVybWluYXRvclBvc2l0aW9uKTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG5jb25zdCBoYXNGbGFnID0gcmVxdWlyZSgnaGFzLWZsYWcnKTtcblxuY29uc3Qge2Vudn0gPSBwcm9jZXNzO1xuXG5sZXQgZm9yY2VDb2xvcjtcbmlmIChoYXNGbGFnKCduby1jb2xvcicpIHx8XG5cdGhhc0ZsYWcoJ25vLWNvbG9ycycpIHx8XG5cdGhhc0ZsYWcoJ2NvbG9yPWZhbHNlJykgfHxcblx0aGFzRmxhZygnY29sb3I9bmV2ZXInKSkge1xuXHRmb3JjZUNvbG9yID0gMDtcbn0gZWxzZSBpZiAoaGFzRmxhZygnY29sb3InKSB8fFxuXHRoYXNGbGFnKCdjb2xvcnMnKSB8fFxuXHRoYXNGbGFnKCdjb2xvcj10cnVlJykgfHxcblx0aGFzRmxhZygnY29sb3I9YWx3YXlzJykpIHtcblx0Zm9yY2VDb2xvciA9IDE7XG59XG5cbmlmICgnRk9SQ0VfQ09MT1InIGluIGVudikge1xuXHRpZiAoZW52LkZPUkNFX0NPTE9SID09PSAndHJ1ZScpIHtcblx0XHRmb3JjZUNvbG9yID0gMTtcblx0fSBlbHNlIGlmIChlbnYuRk9SQ0VfQ09MT1IgPT09ICdmYWxzZScpIHtcblx0XHRmb3JjZUNvbG9yID0gMDtcblx0fSBlbHNlIHtcblx0XHRmb3JjZUNvbG9yID0gZW52LkZPUkNFX0NPTE9SLmxlbmd0aCA9PT0gMCA/IDEgOiBNYXRoLm1pbihwYXJzZUludChlbnYuRk9SQ0VfQ09MT1IsIDEwKSwgMyk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlTGV2ZWwobGV2ZWwpIHtcblx0aWYgKGxldmVsID09PSAwKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRsZXZlbCxcblx0XHRoYXNCYXNpYzogdHJ1ZSxcblx0XHRoYXMyNTY6IGxldmVsID49IDIsXG5cdFx0aGFzMTZtOiBsZXZlbCA+PSAzXG5cdH07XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzQ29sb3IoaGF2ZVN0cmVhbSwgc3RyZWFtSXNUVFkpIHtcblx0aWYgKGZvcmNlQ29sb3IgPT09IDApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcj0xNm0nKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPWZ1bGwnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPXRydWVjb2xvcicpKSB7XG5cdFx0cmV0dXJuIDM7XG5cdH1cblxuXHRpZiAoaGFzRmxhZygnY29sb3I9MjU2JykpIHtcblx0XHRyZXR1cm4gMjtcblx0fVxuXG5cdGlmIChoYXZlU3RyZWFtICYmICFzdHJlYW1Jc1RUWSAmJiBmb3JjZUNvbG9yID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGNvbnN0IG1pbiA9IGZvcmNlQ29sb3IgfHwgMDtcblxuXHRpZiAoZW52LlRFUk0gPT09ICdkdW1iJykge1xuXHRcdHJldHVybiBtaW47XG5cdH1cblxuXHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuXHRcdC8vIFdpbmRvd3MgMTAgYnVpbGQgMTA1ODYgaXMgdGhlIGZpcnN0IFdpbmRvd3MgcmVsZWFzZSB0aGF0IHN1cHBvcnRzIDI1NiBjb2xvcnMuXG5cdFx0Ly8gV2luZG93cyAxMCBidWlsZCAxNDkzMSBpcyB0aGUgZmlyc3QgcmVsZWFzZSB0aGF0IHN1cHBvcnRzIDE2bS9UcnVlQ29sb3IuXG5cdFx0Y29uc3Qgb3NSZWxlYXNlID0gb3MucmVsZWFzZSgpLnNwbGl0KCcuJyk7XG5cdFx0aWYgKFxuXHRcdFx0TnVtYmVyKG9zUmVsZWFzZVswXSkgPj0gMTAgJiZcblx0XHRcdE51bWJlcihvc1JlbGVhc2VbMl0pID49IDEwNTg2XG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gTnVtYmVyKG9zUmVsZWFzZVsyXSkgPj0gMTQ5MzEgPyAzIDogMjtcblx0XHR9XG5cblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmICgnQ0knIGluIGVudikge1xuXHRcdGlmIChbJ1RSQVZJUycsICdDSVJDTEVDSScsICdBUFBWRVlPUicsICdHSVRMQUJfQ0knLCAnR0lUSFVCX0FDVElPTlMnLCAnQlVJTERLSVRFJ10uc29tZShzaWduID0+IHNpZ24gaW4gZW52KSB8fCBlbnYuQ0lfTkFNRSA9PT0gJ2NvZGVzaGlwJykge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1pbjtcblx0fVxuXG5cdGlmICgnVEVBTUNJVFlfVkVSU0lPTicgaW4gZW52KSB7XG5cdFx0cmV0dXJuIC9eKDlcXC4oMCpbMS05XVxcZCopXFwufFxcZHsyLH1cXC4pLy50ZXN0KGVudi5URUFNQ0lUWV9WRVJTSU9OKSA/IDEgOiAwO1xuXHR9XG5cblx0aWYgKGVudi5DT0xPUlRFUk0gPT09ICd0cnVlY29sb3InKSB7XG5cdFx0cmV0dXJuIDM7XG5cdH1cblxuXHRpZiAoJ1RFUk1fUFJPR1JBTScgaW4gZW52KSB7XG5cdFx0Y29uc3QgdmVyc2lvbiA9IHBhcnNlSW50KChlbnYuVEVSTV9QUk9HUkFNX1ZFUlNJT04gfHwgJycpLnNwbGl0KCcuJylbMF0sIDEwKTtcblxuXHRcdHN3aXRjaCAoZW52LlRFUk1fUFJPR1JBTSkge1xuXHRcdFx0Y2FzZSAnaVRlcm0uYXBwJzpcblx0XHRcdFx0cmV0dXJuIHZlcnNpb24gPj0gMyA/IDMgOiAyO1xuXHRcdFx0Y2FzZSAnQXBwbGVfVGVybWluYWwnOlxuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdC8vIE5vIGRlZmF1bHRcblx0XHR9XG5cdH1cblxuXHRpZiAoLy0yNTYoY29sb3IpPyQvaS50ZXN0KGVudi5URVJNKSkge1xuXHRcdHJldHVybiAyO1xuXHR9XG5cblx0aWYgKC9ec2NyZWVufF54dGVybXxednQxMDB8XnZ0MjIwfF5yeHZ0fGNvbG9yfGFuc2l8Y3lnd2lufGxpbnV4L2kudGVzdChlbnYuVEVSTSkpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmICgnQ09MT1JURVJNJyBpbiBlbnYpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdHJldHVybiBtaW47XG59XG5cbmZ1bmN0aW9uIGdldFN1cHBvcnRMZXZlbChzdHJlYW0pIHtcblx0Y29uc3QgbGV2ZWwgPSBzdXBwb3J0c0NvbG9yKHN0cmVhbSwgc3RyZWFtICYmIHN0cmVhbS5pc1RUWSk7XG5cdHJldHVybiB0cmFuc2xhdGVMZXZlbChsZXZlbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRzdXBwb3J0c0NvbG9yOiBnZXRTdXBwb3J0TGV2ZWwsXG5cdHN0ZG91dDogdHJhbnNsYXRlTGV2ZWwoc3VwcG9ydHNDb2xvcih0cnVlLCB0dHkuaXNhdHR5KDEpKSksXG5cdHN0ZGVycjogdHJhbnNsYXRlTGV2ZWwoc3VwcG9ydHNDb2xvcih0cnVlLCB0dHkuaXNhdHR5KDIpKSlcbn07XG4iLCAiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBOb2RlLmpzIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuZGVzdHJveSA9IHV0aWwuZGVwcmVjYXRlKFxuXHQoKSA9PiB7fSxcblx0J0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nXG4pO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFs2LCAyLCAzLCA0LCA1LCAxXTtcblxudHJ5IHtcblx0Ly8gT3B0aW9uYWwgZGVwZW5kZW5jeSAoYXMgaW4sIGRvZXNuJ3QgbmVlZCB0byBiZSBpbnN0YWxsZWQsIE5PVCBsaWtlIG9wdGlvbmFsRGVwZW5kZW5jaWVzIGluIHBhY2thZ2UuanNvbilcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuXHRjb25zdCBzdXBwb3J0c0NvbG9yID0gcmVxdWlyZSgnc3VwcG9ydHMtY29sb3InKTtcblxuXHRpZiAoc3VwcG9ydHNDb2xvciAmJiAoc3VwcG9ydHNDb2xvci5zdGRlcnIgfHwgc3VwcG9ydHNDb2xvcikubGV2ZWwgPj0gMikge1xuXHRcdGV4cG9ydHMuY29sb3JzID0gW1xuXHRcdFx0MjAsXG5cdFx0XHQyMSxcblx0XHRcdDI2LFxuXHRcdFx0MjcsXG5cdFx0XHQzMixcblx0XHRcdDMzLFxuXHRcdFx0MzgsXG5cdFx0XHQzOSxcblx0XHRcdDQwLFxuXHRcdFx0NDEsXG5cdFx0XHQ0Mixcblx0XHRcdDQzLFxuXHRcdFx0NDQsXG5cdFx0XHQ0NSxcblx0XHRcdDU2LFxuXHRcdFx0NTcsXG5cdFx0XHQ2Mixcblx0XHRcdDYzLFxuXHRcdFx0NjgsXG5cdFx0XHQ2OSxcblx0XHRcdDc0LFxuXHRcdFx0NzUsXG5cdFx0XHQ3Nixcblx0XHRcdDc3LFxuXHRcdFx0NzgsXG5cdFx0XHQ3OSxcblx0XHRcdDgwLFxuXHRcdFx0ODEsXG5cdFx0XHQ5Mixcblx0XHRcdDkzLFxuXHRcdFx0OTgsXG5cdFx0XHQ5OSxcblx0XHRcdDExMixcblx0XHRcdDExMyxcblx0XHRcdDEyOCxcblx0XHRcdDEyOSxcblx0XHRcdDEzNCxcblx0XHRcdDEzNSxcblx0XHRcdDE0OCxcblx0XHRcdDE0OSxcblx0XHRcdDE2MCxcblx0XHRcdDE2MSxcblx0XHRcdDE2Mixcblx0XHRcdDE2Myxcblx0XHRcdDE2NCxcblx0XHRcdDE2NSxcblx0XHRcdDE2Nixcblx0XHRcdDE2Nyxcblx0XHRcdDE2OCxcblx0XHRcdDE2OSxcblx0XHRcdDE3MCxcblx0XHRcdDE3MSxcblx0XHRcdDE3Mixcblx0XHRcdDE3Myxcblx0XHRcdDE3OCxcblx0XHRcdDE3OSxcblx0XHRcdDE4NCxcblx0XHRcdDE4NSxcblx0XHRcdDE5Nixcblx0XHRcdDE5Nyxcblx0XHRcdDE5OCxcblx0XHRcdDE5OSxcblx0XHRcdDIwMCxcblx0XHRcdDIwMSxcblx0XHRcdDIwMixcblx0XHRcdDIwMyxcblx0XHRcdDIwNCxcblx0XHRcdDIwNSxcblx0XHRcdDIwNixcblx0XHRcdDIwNyxcblx0XHRcdDIwOCxcblx0XHRcdDIwOSxcblx0XHRcdDIxNCxcblx0XHRcdDIxNSxcblx0XHRcdDIyMCxcblx0XHRcdDIyMVxuXHRcdF07XG5cdH1cbn0gY2F0Y2ggKGVycm9yKSB7XG5cdC8vIFN3YWxsb3cgLSB3ZSBvbmx5IGNhcmUgaWYgYHN1cHBvcnRzLWNvbG9yYCBpcyBhdmFpbGFibGU7IGl0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbn1cblxuLyoqXG4gKiBCdWlsZCB1cCB0aGUgZGVmYXVsdCBgaW5zcGVjdE9wdHNgIG9iamVjdCBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogICAkIERFQlVHX0NPTE9SUz1ubyBERUJVR19ERVBUSD0xMCBERUJVR19TSE9XX0hJRERFTj1lbmFibGVkIG5vZGUgc2NyaXB0LmpzXG4gKi9cblxuZXhwb3J0cy5pbnNwZWN0T3B0cyA9IE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5maWx0ZXIoa2V5ID0+IHtcblx0cmV0dXJuIC9eZGVidWdfL2kudGVzdChrZXkpO1xufSkucmVkdWNlKChvYmosIGtleSkgPT4ge1xuXHQvLyBDYW1lbC1jYXNlXG5cdGNvbnN0IHByb3AgPSBrZXlcblx0XHQuc3Vic3RyaW5nKDYpXG5cdFx0LnRvTG93ZXJDYXNlKClcblx0XHQucmVwbGFjZSgvXyhbYS16XSkvZywgKF8sIGspID0+IHtcblx0XHRcdHJldHVybiBrLnRvVXBwZXJDYXNlKCk7XG5cdFx0fSk7XG5cblx0Ly8gQ29lcmNlIHN0cmluZyB2YWx1ZSBpbnRvIEpTIHZhbHVlXG5cdGxldCB2YWwgPSBwcm9jZXNzLmVudltrZXldO1xuXHRpZiAoL14oeWVzfG9ufHRydWV8ZW5hYmxlZCkkL2kudGVzdCh2YWwpKSB7XG5cdFx0dmFsID0gdHJ1ZTtcblx0fSBlbHNlIGlmICgvXihub3xvZmZ8ZmFsc2V8ZGlzYWJsZWQpJC9pLnRlc3QodmFsKSkge1xuXHRcdHZhbCA9IGZhbHNlO1xuXHR9IGVsc2UgaWYgKHZhbCA9PT0gJ251bGwnKSB7XG5cdFx0dmFsID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHR2YWwgPSBOdW1iZXIodmFsKTtcblx0fVxuXG5cdG9ialtwcm9wXSA9IHZhbDtcblx0cmV0dXJuIG9iajtcbn0sIHt9KTtcblxuLyoqXG4gKiBJcyBzdGRvdXQgYSBUVFk/IENvbG9yZWQgb3V0cHV0IGlzIGVuYWJsZWQgd2hlbiBgdHJ1ZWAuXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHRyZXR1cm4gJ2NvbG9ycycgaW4gZXhwb3J0cy5pbnNwZWN0T3B0cyA/XG5cdFx0Qm9vbGVhbihleHBvcnRzLmluc3BlY3RPcHRzLmNvbG9ycykgOlxuXHRcdHR0eS5pc2F0dHkocHJvY2Vzcy5zdGRlcnIuZmQpO1xufVxuXG4vKipcbiAqIEFkZHMgQU5TSSBjb2xvciBlc2NhcGUgY29kZXMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRjb25zdCB7bmFtZXNwYWNlOiBuYW1lLCB1c2VDb2xvcnN9ID0gdGhpcztcblxuXHRpZiAodXNlQ29sb3JzKSB7XG5cdFx0Y29uc3QgYyA9IHRoaXMuY29sb3I7XG5cdFx0Y29uc3QgY29sb3JDb2RlID0gJ1xcdTAwMUJbMycgKyAoYyA8IDggPyBjIDogJzg7NTsnICsgYyk7XG5cdFx0Y29uc3QgcHJlZml4ID0gYCAgJHtjb2xvckNvZGV9OzFtJHtuYW1lfSBcXHUwMDFCWzBtYDtcblxuXHRcdGFyZ3NbMF0gPSBwcmVmaXggKyBhcmdzWzBdLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgcHJlZml4KTtcblx0XHRhcmdzLnB1c2goY29sb3JDb2RlICsgJ20rJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZikgKyAnXFx1MDAxQlswbScpO1xuXHR9IGVsc2Uge1xuXHRcdGFyZ3NbMF0gPSBnZXREYXRlKCkgKyBuYW1lICsgJyAnICsgYXJnc1swXTtcblx0fVxufVxuXG5mdW5jdGlvbiBnZXREYXRlKCkge1xuXHRpZiAoZXhwb3J0cy5pbnNwZWN0T3B0cy5oaWRlRGF0ZSkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXHRyZXR1cm4gbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgJyAnO1xufVxuXG4vKipcbiAqIEludm9rZXMgYHV0aWwuZm9ybWF0V2l0aE9wdGlvbnMoKWAgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cyBhbmQgd3JpdGVzIHRvIHN0ZGVyci5cbiAqL1xuXG5mdW5jdGlvbiBsb2coLi4uYXJncykge1xuXHRyZXR1cm4gcHJvY2Vzcy5zdGRlcnIud3JpdGUodXRpbC5mb3JtYXRXaXRoT3B0aW9ucyhleHBvcnRzLmluc3BlY3RPcHRzLCAuLi5hcmdzKSArICdcXG4nKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHRpZiAobmFtZXNwYWNlcykge1xuXHRcdHByb2Nlc3MuZW52LkRFQlVHID0gbmFtZXNwYWNlcztcblx0fSBlbHNlIHtcblx0XHQvLyBJZiB5b3Ugc2V0IGEgcHJvY2Vzcy5lbnYgZmllbGQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGl0IGdldHMgY2FzdCB0byB0aGVcblx0XHQvLyBzdHJpbmcgJ251bGwnIG9yICd1bmRlZmluZWQnLiBKdXN0IGRlbGV0ZSBpbnN0ZWFkLlxuXHRcdGRlbGV0ZSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdHJldHVybiBwcm9jZXNzLmVudi5ERUJVRztcbn1cblxuLyoqXG4gKiBJbml0IGxvZ2ljIGZvciBgZGVidWdgIGluc3RhbmNlcy5cbiAqXG4gKiBDcmVhdGUgYSBuZXcgYGluc3BlY3RPcHRzYCBvYmplY3QgaW4gY2FzZSBgdXNlQ29sb3JzYCBpcyBzZXRcbiAqIGRpZmZlcmVudGx5IGZvciBhIHBhcnRpY3VsYXIgYGRlYnVnYCBpbnN0YW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBpbml0KGRlYnVnKSB7XG5cdGRlYnVnLmluc3BlY3RPcHRzID0ge307XG5cblx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGV4cG9ydHMuaW5zcGVjdE9wdHMpO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRkZWJ1Zy5pbnNwZWN0T3B0c1trZXlzW2ldXSA9IGV4cG9ydHMuaW5zcGVjdE9wdHNba2V5c1tpXV07XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJW8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsIG9uIGEgc2luZ2xlIGxpbmUuXG4gKi9cblxuZm9ybWF0dGVycy5vID0gZnVuY3Rpb24gKHYpIHtcblx0dGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblx0cmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKVxuXHRcdC5zcGxpdCgnXFxuJylcblx0XHQubWFwKHN0ciA9PiBzdHIudHJpbSgpKVxuXHRcdC5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqIE1hcCAlTyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGxvd2luZyBtdWx0aXBsZSBsaW5lcyBpZiBuZWVkZWQuXG4gKi9cblxuZm9ybWF0dGVycy5PID0gZnVuY3Rpb24gKHYpIHtcblx0dGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblx0cmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKTtcbn07XG4iLCAiLyoqXG4gKiBEZXRlY3QgRWxlY3Ryb24gcmVuZGVyZXIgLyBud2pzIHByb2Nlc3MsIHdoaWNoIGlzIG5vZGUsIGJ1dCB3ZSBzaG91bGRcbiAqIHRyZWF0IGFzIGEgYnJvd3Nlci5cbiAqL1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8IHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCBwcm9jZXNzLmJyb3dzZXIgPT09IHRydWUgfHwgcHJvY2Vzcy5fX253anMpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jyb3dzZXIuanMnKTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9ub2RlLmpzJyk7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQklOQVJZX1RZUEVTID0gWydub2RlYnVmZmVyJywgJ2FycmF5YnVmZmVyJywgJ2ZyYWdtZW50cyddO1xuY29uc3QgaGFzQmxvYiA9IHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJztcblxuaWYgKGhhc0Jsb2IpIEJJTkFSWV9UWVBFUy5wdXNoKCdibG9iJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUjogQnVmZmVyLmFsbG9jKDApLFxuICBHVUlEOiAnMjU4RUFGQTUtRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExJyxcbiAgaGFzQmxvYixcbiAga0Zvck9uRXZlbnRBdHRyaWJ1dGU6IFN5bWJvbCgna0lzRm9yT25FdmVudEF0dHJpYnV0ZScpLFxuICBrTGlzdGVuZXI6IFN5bWJvbCgna0xpc3RlbmVyJyksXG4gIGtTdGF0dXNDb2RlOiBTeW1ib2woJ3N0YXR1cy1jb2RlJyksXG4gIGtXZWJTb2NrZXQ6IFN5bWJvbCgnd2Vic29ja2V0JyksXG4gIE5PT1A6ICgpID0+IHt9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBFTVBUWV9CVUZGRVIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xuXG4vKipcbiAqIE1lcmdlcyBhbiBhcnJheSBvZiBidWZmZXJzIGludG8gYSBuZXcgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGFycmF5IG9mIGJ1ZmZlcnMgdG8gY29uY2F0XG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWxMZW5ndGggVGhlIHRvdGFsIGxlbmd0aCBvZiBidWZmZXJzIGluIHRoZSBsaXN0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSByZXN1bHRpbmcgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHJldHVybiBFTVBUWV9CVUZGRVI7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIGxpc3RbMF07XG5cbiAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnVmID0gbGlzdFtpXTtcbiAgICB0YXJnZXQuc2V0KGJ1Ziwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYnVmLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCB0b3RhbExlbmd0aCkge1xuICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcih0YXJnZXQuYnVmZmVyLCB0YXJnZXQuYnl0ZU9mZnNldCwgb2Zmc2V0KTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogTWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHNvdXJjZSBUaGUgYnVmZmVyIHRvIG1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHBhcmFtIHtCdWZmZXJ9IG91dHB1dCBUaGUgYnVmZmVyIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCB3cml0aW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gbWFzay5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSBzb3VyY2VbaV0gXiBtYXNrW2kgJiAzXTtcbiAgfVxufVxuXG4vKipcbiAqIFVubWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIHVubWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF91bm1hc2soYnVmZmVyLCBtYXNrKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZmVyW2ldIF49IG1hc2tbaSAmIDNdO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBidWZmZXIgdG8gYW4gYEFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY29udmVydFxuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IENvbnZlcnRlZCBidWZmZXJcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcihidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBidWYuYnVmZmVyO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmxlbmd0aCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGRhdGFgIHRvIGEgYEJ1ZmZlcmAuXG4gKlxuICogQHBhcmFtIHsqfSBkYXRhIFRoZSBkYXRhIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGJ1ZmZlclxuICogQHRocm93cyB7VHlwZUVycm9yfVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b0J1ZmZlcihkYXRhKSB7XG4gIHRvQnVmZmVyLnJlYWRPbmx5ID0gdHJ1ZTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSByZXR1cm4gZGF0YTtcblxuICBsZXQgYnVmO1xuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBidWYgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhKTtcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICBidWYgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgIHRvQnVmZmVyLnJlYWRPbmx5ID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gYnVmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29uY2F0LFxuICBtYXNrOiBfbWFzayxcbiAgdG9BcnJheUJ1ZmZlcixcbiAgdG9CdWZmZXIsXG4gIHVubWFzazogX3VubWFza1xufTtcblxuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovXG5pZiAoIXByb2Nlc3MuZW52LldTX05PX0JVRkZFUl9VVElMKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJ2J1ZmZlcnV0aWwnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzLm1hc2sgPSBmdW5jdGlvbiAoc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoIDwgNDgpIF9tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBlbHNlIGJ1ZmZlclV0aWwubWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cy51bm1hc2sgPSBmdW5jdGlvbiAoYnVmZmVyLCBtYXNrKSB7XG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDMyKSBfdW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgICBlbHNlIGJ1ZmZlclV0aWwudW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIENvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgdGhlIGVycm9yLlxuICB9XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBrRG9uZSA9IFN5bWJvbCgna0RvbmUnKTtcbmNvbnN0IGtSdW4gPSBTeW1ib2woJ2tSdW4nKTtcblxuLyoqXG4gKiBBIHZlcnkgc2ltcGxlIGpvYiBxdWV1ZSB3aXRoIGFkanVzdGFibGUgY29uY3VycmVuY3kuIEFkYXB0ZWQgZnJvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL1NUUk1ML2FzeW5jLWxpbWl0ZXJcbiAqL1xuY2xhc3MgTGltaXRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBMaW1pdGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25jdXJyZW5jeT1JbmZpbml0eV0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGpvYnMgYWxsb3dlZFxuICAgKiAgICAgdG8gcnVuIGNvbmN1cnJlbnRseVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uY3VycmVuY3kpIHtcbiAgICB0aGlzW2tEb25lXSA9ICgpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZy0tO1xuICAgICAgdGhpc1trUnVuXSgpO1xuICAgIH07XG4gICAgdGhpcy5jb25jdXJyZW5jeSA9IGNvbmN1cnJlbmN5IHx8IEluZmluaXR5O1xuICAgIHRoaXMuam9icyA9IFtdO1xuICAgIHRoaXMucGVuZGluZyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGpvYiB0byB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGpvYiBUaGUgam9iIHRvIHJ1blxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGQoam9iKSB7XG4gICAgdGhpcy5qb2JzLnB1c2goam9iKTtcbiAgICB0aGlzW2tSdW5dKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGpvYiBmcm9tIHRoZSBxdWV1ZSBhbmQgcnVucyBpdCBpZiBwb3NzaWJsZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFtrUnVuXSgpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nID09PSB0aGlzLmNvbmN1cnJlbmN5KSByZXR1cm47XG5cbiAgICBpZiAodGhpcy5qb2JzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgam9iID0gdGhpcy5qb2JzLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMucGVuZGluZysrO1xuICAgICAgam9iKHRoaXNba0RvbmVdKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMaW1pdGVyO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcblxuY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcbmNvbnN0IExpbWl0ZXIgPSByZXF1aXJlKCcuL2xpbWl0ZXInKTtcbmNvbnN0IHsga1N0YXR1c0NvZGUgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xuY29uc3QgVFJBSUxFUiA9IEJ1ZmZlci5mcm9tKFsweDAwLCAweDAwLCAweGZmLCAweGZmXSk7XG5jb25zdCBrUGVyTWVzc2FnZURlZmxhdGUgPSBTeW1ib2woJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qga1RvdGFsTGVuZ3RoID0gU3ltYm9sKCd0b3RhbC1sZW5ndGgnKTtcbmNvbnN0IGtDYWxsYmFjayA9IFN5bWJvbCgnY2FsbGJhY2snKTtcbmNvbnN0IGtCdWZmZXJzID0gU3ltYm9sKCdidWZmZXJzJyk7XG5jb25zdCBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG5cbi8vXG4vLyBXZSBsaW1pdCB6bGliIGNvbmN1cnJlbmN5LCB3aGljaCBwcmV2ZW50cyBzZXZlcmUgbWVtb3J5IGZyYWdtZW50YXRpb25cbi8vIGFzIGRvY3VtZW50ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy84ODcxI2lzc3VlY29tbWVudC0yNTA5MTU5MTNcbi8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTIwMlxuLy9cbi8vIEludGVudGlvbmFsbHkgZ2xvYmFsOyBpdCdzIHRoZSBnbG9iYWwgdGhyZWFkIHBvb2wgdGhhdCdzIGFuIGlzc3VlLlxuLy9cbmxldCB6bGliTGltaXRlcjtcblxuLyoqXG4gKiBwZXJtZXNzYWdlLWRlZmxhdGUgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIFBlck1lc3NhZ2VEZWZsYXRlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQZXJNZXNzYWdlRGVmbGF0ZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxOdW1iZXIpfSBbb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzXSBBZHZlcnRpc2Ugc3VwcG9ydFxuICAgKiAgICAgZm9yLCBvciByZXF1ZXN0LCBhIGN1c3RvbSBjbGllbnQgd2luZG93IHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gQWR2ZXJ0aXNlL1xuICAgKiAgICAgYWNrbm93bGVkZ2UgZGlzYWJsaW5nIG9mIGNsaWVudCBjb250ZXh0IHRha2VvdmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0PTEwXSBUaGUgbnVtYmVyIG9mIGNvbmN1cnJlbnRcbiAgICogICAgIGNhbGxzIHRvIHpsaWJcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxOdW1iZXIpfSBbb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzXSBSZXF1ZXN0L2NvbmZpcm0gdGhlXG4gICAqICAgICB1c2Ugb2YgYSBjdXN0b20gc2VydmVyIHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXI9ZmFsc2VdIFJlcXVlc3QvYWNjZXB0XG4gICAqICAgICBkaXNhYmxpbmcgb2Ygc2VydmVyIGNvbnRleHQgdGFrZW92ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRocmVzaG9sZD0xMDI0XSBTaXplIChpbiBieXRlcykgYmVsb3cgd2hpY2hcbiAgICogICAgIG1lc3NhZ2VzIHNob3VsZCBub3QgYmUgY29tcHJlc3NlZCBpZiBjb250ZXh0IHRha2VvdmVyIGlzIGRpc2FibGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy56bGliRGVmbGF0ZU9wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byB6bGliIG9uXG4gICAqICAgICBkZWZsYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy56bGliSW5mbGF0ZU9wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byB6bGliIG9uXG4gICAqICAgICBpbmZsYXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzU2VydmVyPWZhbHNlXSBDcmVhdGUgdGhlIGluc3RhbmNlIGluIGVpdGhlciBzZXJ2ZXIgb3JcbiAgICogICAgIGNsaWVudCBtb2RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBpc1NlcnZlciwgbWF4UGF5bG9hZCkge1xuICAgIHRoaXMuX21heFBheWxvYWQgPSBtYXhQYXlsb2FkIHwgMDtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLl90aHJlc2hvbGQgPVxuICAgICAgdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgIT09IHVuZGVmaW5lZCA/IHRoaXMuX29wdGlvbnMudGhyZXNob2xkIDogMTAyNDtcbiAgICB0aGlzLl9pc1NlcnZlciA9ICEhaXNTZXJ2ZXI7XG4gICAgdGhpcy5fZGVmbGF0ZSA9IG51bGw7XG4gICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG5cbiAgICB0aGlzLnBhcmFtcyA9IG51bGw7XG5cbiAgICBpZiAoIXpsaWJMaW1pdGVyKSB7XG4gICAgICBjb25zdCBjb25jdXJyZW5jeSA9XG4gICAgICAgIHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbmN5TGltaXRcbiAgICAgICAgICA6IDEwO1xuICAgICAgemxpYkxpbWl0ZXIgPSBuZXcgTGltaXRlcihjb25jdXJyZW5jeSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGV4dGVuc2lvbk5hbWUoKSB7XG4gICAgcmV0dXJuICdwZXJtZXNzYWdlLWRlZmxhdGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gRXh0ZW5zaW9uIHBhcmFtZXRlcnNcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgb2ZmZXIoKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge307XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PSBudWxsKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHQgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyL3Jlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHVibGljXG4gICAqL1xuICBhY2NlcHQoY29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9ucyA9IHRoaXMubm9ybWFsaXplUGFyYW1zKGNvbmZpZ3VyYXRpb25zKTtcblxuICAgIHRoaXMucGFyYW1zID0gdGhpcy5faXNTZXJ2ZXJcbiAgICAgID8gdGhpcy5hY2NlcHRBc1NlcnZlcihjb25maWd1cmF0aW9ucylcbiAgICAgIDogdGhpcy5hY2NlcHRBc0NsaWVudChjb25maWd1cmF0aW9ucyk7XG5cbiAgICByZXR1cm4gdGhpcy5wYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgYWxsIHJlc291cmNlcyB1c2VkIGJ5IHRoZSBleHRlbnNpb24uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuX2luZmxhdGUpIHtcbiAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWZsYXRlKSB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZS5jbG9zZSgpO1xuICAgICAgdGhpcy5fZGVmbGF0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIGRlZmxhdGUgc3RyZWFtIHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgcHJvY2Vzc2VkJ1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9mZmVycyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjY2VwdEFzU2VydmVyKG9mZmVycykge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLl9vcHRpb25zO1xuICAgIGNvbnN0IGFjY2VwdGVkID0gb2ZmZXJzLmZpbmQoKHBhcmFtcykgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiZcbiAgICAgICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIpIHx8XG4gICAgICAgIChwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyAmJlxuICAgICAgICAgIChvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID4gcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMpKSkgfHxcbiAgICAgICAgKHR5cGVvZiBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICBpZiAoIWFjY2VwdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbmUgb2YgdGhlIGV4dGVuc2lvbiBvZmZlcnMgY2FuIGJlIGFjY2VwdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdHMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICBhY2NlcHRlZC5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzID0gb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPT09IHRydWUgfHxcbiAgICAgIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gZmFsc2VcbiAgICApIHtcbiAgICAgIGRlbGV0ZSBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzO1xuICAgIH1cblxuICAgIHJldHVybiBhY2NlcHRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHQgdGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiByZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcmVzcG9uc2UgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiByZXNwb25zZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjY2VwdEFzQ2xpZW50KHJlc3BvbnNlKSB7XG4gICAgY29uc3QgcGFyYW1zID0gcmVzcG9uc2VbMF07XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcGFyYW1ldGVyIFwiY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcIicpO1xuICAgIH1cblxuICAgIGlmICghcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBmYWxzZSB8fFxuICAgICAgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID4gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVW5leHBlY3RlZCBvciBpbnZhbGlkIHBhcmFtZXRlciBcImNsaWVudF9tYXhfd2luZG93X2JpdHNcIidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY29uZmlndXJhdGlvbnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnMvcmVwb25zZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIG9mZmVycy9yZXNwb25zZSB3aXRoIG5vcm1hbGl6ZWQgcGFyYW1ldGVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbm9ybWFsaXplUGFyYW1zKGNvbmZpZ3VyYXRpb25zKSB7XG4gICAgY29uZmlndXJhdGlvbnMuZm9yRWFjaCgocGFyYW1zKSA9PiB7XG4gICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBwYXJhbXNba2V5XTtcblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFyYW1ldGVyIFwiJHtrZXl9XCIgbXVzdCBoYXZlIG9ubHkgYSBzaW5nbGUgdmFsdWVgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gdmFsdWVbMF07XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsaWVudF9tYXhfd2luZG93X2JpdHMnKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBudW0gPSArdmFsdWU7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobnVtKSB8fCBudW0gPCA4IHx8IG51bSA+IDE1KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gbnVtO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzU2VydmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnc2VydmVyX21heF93aW5kb3dfYml0cycpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSArdmFsdWU7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG51bSkgfHwgbnVtIDwgOCB8fCBudW0gPiAxNSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gbnVtO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3NlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyJ1xuICAgICAgICApIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcGFyYW1ldGVyIFwiJHtrZXl9XCJgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjb25maWd1cmF0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICB6bGliTGltaXRlci5hZGQoKGRvbmUpID0+IHtcbiAgICAgIHRoaXMuX2RlY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICB6bGliTGltaXRlci5hZGQoKGRvbmUpID0+IHtcbiAgICAgIHRoaXMuX2NvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZWNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuX2lzU2VydmVyID8gJ2NsaWVudCcgOiAnc2VydmVyJztcblxuICAgIGlmICghdGhpcy5faW5mbGF0ZSkge1xuICAgICAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9X21heF93aW5kb3dfYml0c2A7XG4gICAgICBjb25zdCB3aW5kb3dCaXRzID1cbiAgICAgICAgdHlwZW9mIHRoaXMucGFyYW1zW2tleV0gIT09ICdudW1iZXInXG4gICAgICAgICAgPyB6bGliLlpfREVGQVVMVF9XSU5ET1dCSVRTXG4gICAgICAgICAgOiB0aGlzLnBhcmFtc1trZXldO1xuXG4gICAgICB0aGlzLl9pbmZsYXRlID0gemxpYi5jcmVhdGVJbmZsYXRlUmF3KHtcbiAgICAgICAgLi4udGhpcy5fb3B0aW9ucy56bGliSW5mbGF0ZU9wdGlvbnMsXG4gICAgICAgIHdpbmRvd0JpdHNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrUGVyTWVzc2FnZURlZmxhdGVdID0gdGhpcztcbiAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuICAgICAgdGhpcy5faW5mbGF0ZS5vbignZXJyb3InLCBpbmZsYXRlT25FcnJvcik7XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKCdkYXRhJywgaW5mbGF0ZU9uRGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5faW5mbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG5cbiAgICB0aGlzLl9pbmZsYXRlLndyaXRlKGRhdGEpO1xuICAgIGlmIChmaW4pIHRoaXMuX2luZmxhdGUud3JpdGUoVFJBSUxFUik7XG5cbiAgICB0aGlzLl9pbmZsYXRlLmZsdXNoKCgpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IHRoaXMuX2luZmxhdGVba0Vycm9yXTtcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcblxuICAgICAgaWYgKHRoaXMuX2luZmxhdGUuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcblxuICAgICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcbiAgICAgICAgICB0aGlzLl9pbmZsYXRlLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHJlc3MgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgRGF0YSB0byBjb21wcmVzc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuX2lzU2VydmVyID8gJ3NlcnZlcicgOiAnY2xpZW50JztcblxuICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9X21heF93aW5kb3dfYml0c2A7XG4gICAgICBjb25zdCB3aW5kb3dCaXRzID1cbiAgICAgICAgdHlwZW9mIHRoaXMucGFyYW1zW2tleV0gIT09ICdudW1iZXInXG4gICAgICAgICAgPyB6bGliLlpfREVGQVVMVF9XSU5ET1dCSVRTXG4gICAgICAgICAgOiB0aGlzLnBhcmFtc1trZXldO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlID0gemxpYi5jcmVhdGVEZWZsYXRlUmF3KHtcbiAgICAgICAgLi4udGhpcy5fb3B0aW9ucy56bGliRGVmbGF0ZU9wdGlvbnMsXG4gICAgICAgIHdpbmRvd0JpdHNcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10gPSBbXTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZS5vbignZGF0YScsIGRlZmxhdGVPbkRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xuXG4gICAgdGhpcy5fZGVmbGF0ZS53cml0ZShkYXRhKTtcbiAgICB0aGlzLl9kZWZsYXRlLmZsdXNoKHpsaWIuWl9TWU5DX0ZMVVNILCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIGRlZmxhdGUgc3RyZWFtIHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgICAvL1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBkYXRhID0gYnVmZmVyVXRpbC5jb25jYXQoXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdLFxuICAgICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF1cbiAgICAgICk7XG5cbiAgICAgIGlmIChmaW4pIHtcbiAgICAgICAgZGF0YSA9IG5ldyBGYXN0QnVmZmVyKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEubGVuZ3RoIC0gNCk7XG4gICAgICB9XG5cbiAgICAgIC8vXG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgY2FsbGJhY2sgd2lsbCBub3QgYmUgY2FsbGVkIGFnYWluIGluXG4gICAgICAvLyBgUGVyTWVzc2FnZURlZmxhdGUjY2xlYW51cCgpYC5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBudWxsO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10gPSBbXTtcblxuICAgICAgaWYgKGZpbiAmJiB0aGlzLnBhcmFtc1tgJHtlbmRwb2ludH1fbm9fY29udGV4dF90YWtlb3ZlcmBdKSB7XG4gICAgICAgIHRoaXMuX2RlZmxhdGUucmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQZXJNZXNzYWdlRGVmbGF0ZTtcblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkRlZmxhdGVSYXdgIHN0cmVhbSBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZsYXRlT25EYXRhKGNodW5rKSB7XG4gIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuSW5mbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluZmxhdGVPbkRhdGEoY2h1bmspIHtcbiAgdGhpc1trVG90YWxMZW5ndGhdICs9IGNodW5rLmxlbmd0aDtcblxuICBpZiAoXG4gICAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkIDwgMSB8fFxuICAgIHRoaXNba1RvdGFsTGVuZ3RoXSA8PSB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWRcbiAgKSB7XG4gICAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpc1trRXJyb3JdID0gbmV3IFJhbmdlRXJyb3IoJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnKTtcbiAgdGhpc1trRXJyb3JdLmNvZGUgPSAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJztcbiAgdGhpc1trRXJyb3JdW2tTdGF0dXNDb2RlXSA9IDEwMDk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcbiAgdGhpcy5yZXNldCgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuSW5mbGF0ZVJhd2Agc3RyZWFtIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluZmxhdGVPbkVycm9yKGVycikge1xuICAvL1xuICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgYFpsaWIjY2xvc2UoKWAgYXMgdGhlIGhhbmRsZSBpcyBhdXRvbWF0aWNhbGx5XG4gIC8vIGNsb3NlZCB3aGVuIGFuIGVycm9yIGlzIGVtaXR0ZWQuXG4gIC8vXG4gIHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5faW5mbGF0ZSA9IG51bGw7XG4gIGVycltrU3RhdHVzQ29kZV0gPSAxMDA3O1xuICB0aGlzW2tDYWxsYmFja10oZXJyKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgaXNVdGY4IH0gPSByZXF1aXJlKCdidWZmZXInKTtcblxuY29uc3QgeyBoYXNCbG9iIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG4vL1xuLy8gQWxsb3dlZCB0b2tlbiBjaGFyYWN0ZXJzOlxuLy9cbi8vICchJywgJyMnLCAnJCcsICclJywgJyYnLCAnJycsICcqJywgJysnLCAnLScsXG4vLyAnLicsIDAtOSwgQS1aLCAnXicsICdfJywgJ2AnLCBhLXosICd8JywgJ34nXG4vL1xuLy8gdG9rZW5DaGFyc1szMl0gPT09IDAgLy8gJyAnXG4vLyB0b2tlbkNoYXJzWzMzXSA9PT0gMSAvLyAnISdcbi8vIHRva2VuQ2hhcnNbMzRdID09PSAwIC8vICdcIidcbi8vIC4uLlxuLy9cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdG9rZW5DaGFycyA9IFtcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMCAtIDE1XG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDE2IC0gMzFcbiAgMCwgMSwgMCwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMSwgMSwgMCwgMSwgMSwgMCwgLy8gMzIgLSA0N1xuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyA0OCAtIDYzXG4gIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDY0IC0gNzlcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMSwgMSwgLy8gODAgLSA5NVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA5NiAtIDExMVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAxLCAwLCAxLCAwIC8vIDExMiAtIDEyN1xuXTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGF0dXMgY29kZSBpcyBhbGxvd2VkIGluIGEgY2xvc2UgZnJhbWUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHN0YXR1cyBjb2RlIGlzIHZhbGlkLCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkge1xuICByZXR1cm4gKFxuICAgIChjb2RlID49IDEwMDAgJiZcbiAgICAgIGNvZGUgPD0gMTAxNCAmJlxuICAgICAgY29kZSAhPT0gMTAwNCAmJlxuICAgICAgY29kZSAhPT0gMTAwNSAmJlxuICAgICAgY29kZSAhPT0gMTAwNikgfHxcbiAgICAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OSlcbiAgKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBidWZmZXIgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LlxuICogUG9ydGVkIGZyb20gaHR0cHM6Ly93d3cuY2wuY2FtLmFjLnVrLyU3RW1nazI1L3Vjcy91dGY4X2NoZWNrLmMgYnlcbiAqIE1hcmt1cyBLdWhuLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgVGhlIGJ1ZmZlciB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGBidWZgIGNvbnRhaW5zIG9ubHkgY29ycmVjdCBVVEYtOCwgZWxzZSBgZmFsc2VgXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF9pc1ZhbGlkVVRGOChidWYpIHtcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKChidWZbaV0gJiAweDgwKSA9PT0gMCkge1xuICAgICAgLy8gMHh4eHh4eHhcbiAgICAgIGkrKztcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgLy8gMTEweHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDEgPT09IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaV0gJiAweGZlKSA9PT0gMHhjMCAvLyBPdmVybG9uZ1xuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAyO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZjApID09PSAweGUwKSB7XG4gICAgICAvLyAxMTEweHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMiA+PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAyXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaV0gPT09IDB4ZTAgJiYgKGJ1ZltpICsgMV0gJiAweGUwKSA9PT0gMHg4MCkgfHwgLy8gT3ZlcmxvbmdcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhlZCAmJiAoYnVmW2kgKyAxXSAmIDB4ZTApID09PSAweGEwKSAvLyBTdXJyb2dhdGUgKFUrRDgwMCAtIFUrREZGRilcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMztcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgLy8gMTExMTB4eHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDMgPj0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgMl0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAzXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaV0gPT09IDB4ZjAgJiYgKGJ1ZltpICsgMV0gJiAweGYwKSA9PT0gMHg4MCkgfHwgLy8gT3ZlcmxvbmdcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhmNCAmJiBidWZbaSArIDFdID4gMHg4ZikgfHxcbiAgICAgICAgYnVmW2ldID4gMHhmNCAvLyA+IFUrMTBGRkZGXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSB2YWx1ZSBpcyBhIGBCbG9iYC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSB0ZXN0ZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYEJsb2JgLCBlbHNlIGBmYWxzZWBcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIGhhc0Jsb2IgJiZcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHZhbHVlLmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHZhbHVlLnR5cGUgPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIHZhbHVlLnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICh2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnQmxvYicgfHxcbiAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdGaWxlJylcbiAgKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQmxvYixcbiAgaXNWYWxpZFN0YXR1c0NvZGUsXG4gIGlzVmFsaWRVVEY4OiBfaXNWYWxpZFVURjgsXG4gIHRva2VuQ2hhcnNcbn07XG5cbmlmIChpc1V0ZjgpIHtcbiAgbW9kdWxlLmV4cG9ydHMuaXNWYWxpZFVURjggPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgcmV0dXJuIGJ1Zi5sZW5ndGggPCAyNCA/IF9pc1ZhbGlkVVRGOChidWYpIDogaXNVdGY4KGJ1Zik7XG4gIH07XG59IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqLyBlbHNlIGlmICghcHJvY2Vzcy5lbnYuV1NfTk9fVVRGXzhfVkFMSURBVEUpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBpc1ZhbGlkVVRGOCA9IHJlcXVpcmUoJ3V0Zi04LXZhbGlkYXRlJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cy5pc1ZhbGlkVVRGOCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICAgIHJldHVybiBidWYubGVuZ3RoIDwgMzIgPyBfaXNWYWxpZFVURjgoYnVmKSA6IGlzVmFsaWRVVEY4KGJ1Zik7XG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIENvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgdGhlIGVycm9yLlxuICB9XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IFdyaXRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXRcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBjb25jYXQsIHRvQXJyYXlCdWZmZXIsIHVubWFzayB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSwgaXNWYWxpZFVURjggfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG5jb25zdCBGYXN0QnVmZmVyID0gQnVmZmVyW1N5bWJvbC5zcGVjaWVzXTtcblxuY29uc3QgR0VUX0lORk8gPSAwO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzE2ID0gMTtcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF82NCA9IDI7XG5jb25zdCBHRVRfTUFTSyA9IDM7XG5jb25zdCBHRVRfREFUQSA9IDQ7XG5jb25zdCBJTkZMQVRJTkcgPSA1O1xuY29uc3QgREVGRVJfRVZFTlQgPSA2O1xuXG4vKipcbiAqIEh5QmkgUmVjZWl2ZXIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGV4dGVuZHMgV3JpdGFibGVcbiAqL1xuY2xhc3MgUmVjZWl2ZXIgZXh0ZW5kcyBXcml0YWJsZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUmVjZWl2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyXG4gICAqICAgICBhbnkgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZFxuICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYmluYXJ5VHlwZT1ub2RlYnVmZmVyXSBUaGUgdHlwZSBmb3IgYmluYXJ5IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmV4dGVuc2lvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkXG4gICAqICAgICBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNTZXJ2ZXI9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRvIG9wZXJhdGUgaW5cbiAgICogICAgIGNsaWVudCBvciBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzID1cbiAgICAgIG9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzXG4gICAgICAgIDogdHJ1ZTtcbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gb3B0aW9ucy5iaW5hcnlUeXBlIHx8IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zIHx8IHt9O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFvcHRpb25zLmlzU2VydmVyO1xuICAgIHRoaXMuX21heFBheWxvYWQgPSBvcHRpb25zLm1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiA9ICEhb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb247XG4gICAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX2J1ZmZlcnMgPSBbXTtcblxuICAgIHRoaXMuX2NvbXByZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXNrID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX21hc2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpbiA9IGZhbHNlO1xuICAgIHRoaXMuX29wY29kZSA9IDA7XG5cbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgdGhpcy5fZXJyb3JlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgYFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBUaGUgY2h1bmsgb2YgZGF0YSB0byB3cml0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmcgVGhlIGNoYXJhY3RlciBlbmNvZGluZyBvZiBgY2h1bmtgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDggJiYgdGhpcy5fc3RhdGUgPT0gR0VUX0lORk8pIHJldHVybiBjYigpO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBjaHVuay5sZW5ndGg7XG4gICAgdGhpcy5fYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3VtZXMgYG5gIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gY29uc3VtZVxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBjb25zdW1lZCBieXRlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3VtZShuKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBuO1xuXG4gICAgaWYgKG4gPT09IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSByZXR1cm4gdGhpcy5fYnVmZmVycy5zaGlmdCgpO1xuXG4gICAgaWYgKG4gPCB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkge1xuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBuZXcgRmFzdEJ1ZmZlcihcbiAgICAgICAgYnVmLmJ1ZmZlcixcbiAgICAgICAgYnVmLmJ5dGVPZmZzZXQgKyBuLFxuICAgICAgICBidWYubGVuZ3RoIC0gblxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBuKTtcbiAgICB9XG5cbiAgICBjb25zdCBkc3QgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG5cbiAgICBkbyB7XG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gZHN0Lmxlbmd0aCAtIG47XG5cbiAgICAgIGlmIChuID49IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgZHN0LnNldCh0aGlzLl9idWZmZXJzLnNoaWZ0KCksIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkc3Quc2V0KG5ldyBVaW50OEFycmF5KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBuKSwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IG5ldyBGYXN0QnVmZmVyKFxuICAgICAgICAgIGJ1Zi5idWZmZXIsXG4gICAgICAgICAgYnVmLmJ5dGVPZmZzZXQgKyBuLFxuICAgICAgICAgIGJ1Zi5sZW5ndGggLSBuXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIG4gLT0gYnVmLmxlbmd0aDtcbiAgICB9IHdoaWxlIChuID4gMCk7XG5cbiAgICByZXR1cm4gZHN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgcGFyc2luZyBsb29wLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRMb29wKGNiKSB7XG4gICAgdGhpcy5fbG9vcCA9IHRydWU7XG5cbiAgICBkbyB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgIGNhc2UgR0VUX0lORk86XG4gICAgICAgICAgdGhpcy5nZXRJbmZvKGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY6XG4gICAgICAgICAgdGhpcy5nZXRQYXlsb2FkTGVuZ3RoMTYoY2IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF82NDpcbiAgICAgICAgICB0aGlzLmdldFBheWxvYWRMZW5ndGg2NChjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX01BU0s6XG4gICAgICAgICAgdGhpcy5nZXRNYXNrKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX0RBVEE6XG4gICAgICAgICAgdGhpcy5nZXREYXRhKGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBJTkZMQVRJTkc6XG4gICAgICAgIGNhc2UgREVGRVJfRVZFTlQ6XG4gICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IHdoaWxlICh0aGlzLl9sb29wKTtcblxuICAgIGlmICghdGhpcy5fZXJyb3JlZCkgY2IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgZmlyc3QgdHdvIGJ5dGVzIG9mIGEgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRJbmZvKGNiKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDIpO1xuXG4gICAgaWYgKChidWZbMF0gJiAweDMwKSAhPT0gMHgwMCkge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnUlNWMiBhbmQgUlNWMyBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8yXzMnXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29tcHJlc3NlZCA9IChidWZbMF0gJiAweDQwKSA9PT0gMHg0MDtcblxuICAgIGlmIChjb21wcmVzc2VkICYmICF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZmluID0gKGJ1ZlswXSAmIDB4ODApID09PSAweDgwO1xuICAgIHRoaXMuX29wY29kZSA9IGJ1ZlswXSAmIDB4MGY7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IGJ1ZlsxXSAmIDB4N2Y7XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAwKSB7XG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ2ludmFsaWQgb3Bjb2RlIDAnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vcGNvZGUgPSB0aGlzLl9mcmFnbWVudGVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAxIHx8IHRoaXMuX29wY29kZSA9PT0gMHgwMikge1xuICAgICAgaWYgKHRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NvbXByZXNzZWQgPSBjb21wcmVzc2VkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNyAmJiB0aGlzLl9vcGNvZGUgPCAweDBiKSB7XG4gICAgICBpZiAoIXRoaXMuX2Zpbikge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnRklOIG11c3QgYmUgc2V0JyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9FWFBFQ1RFRF9GSU4nXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fcGF5bG9hZExlbmd0aCA+IDB4N2QgfHxcbiAgICAgICAgKHRoaXMuX29wY29kZSA9PT0gMHgwOCAmJiB0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIGBpbnZhbGlkIHBheWxvYWQgbGVuZ3RoICR7dGhpcy5fcGF5bG9hZExlbmd0aH1gLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfQ09OVFJPTF9QQVlMT0FEX0xFTkdUSCdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICBgaW52YWxpZCBvcGNvZGUgJHt0aGlzLl9vcGNvZGV9YCxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2ZpbiAmJiAhdGhpcy5fZnJhZ21lbnRlZCkgdGhpcy5fZnJhZ21lbnRlZCA9IHRoaXMuX29wY29kZTtcbiAgICB0aGlzLl9tYXNrZWQgPSAoYnVmWzFdICYgMHg4MCkgPT09IDB4ODA7XG5cbiAgICBpZiAodGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgIGlmICghdGhpcy5fbWFza2VkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdNQVNLIG11c3QgYmUgc2V0JyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9FWFBFQ1RFRF9NQVNLJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fbWFza2VkKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdNQVNLIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfTUFTSydcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI2KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF8xNjtcbiAgICBlbHNlIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjcpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzY0O1xuICAgIGVsc2UgdGhpcy5oYXZlTGVuZ3RoKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoICg3KzE2KS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGgxNihjYikge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSB0aGlzLmNvbnN1bWUoMikucmVhZFVJbnQxNkJFKDApO1xuICAgIHRoaXMuaGF2ZUxlbmd0aChjYik7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNys2NCkuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoNjQoY2IpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDgpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoOCk7XG4gICAgY29uc3QgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKTtcblxuICAgIC8vXG4gICAgLy8gVGhlIG1heGltdW0gc2FmZSBpbnRlZ2VyIGluIEphdmFTY3JpcHQgaXMgMl41MyAtIDEuIEFuIGVycm9yIGlzIHJldHVybmVkXG4gICAgLy8gaWYgcGF5bG9hZCBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIHRoaXMgbnVtYmVyLlxuICAgIC8vXG4gICAgaWYgKG51bSA+IE1hdGgucG93KDIsIDUzIC0gMzIpIC0gMSkge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnVW5zdXBwb3J0ZWQgV2ViU29ja2V0IGZyYW1lOiBwYXlsb2FkIGxlbmd0aCA+IDJeNTMgLSAxJyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIDEwMDksXG4gICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfREFUQV9QQVlMT0FEX0xFTkdUSCdcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gbnVtICogTWF0aC5wb3coMiwgMzIpICsgYnVmLnJlYWRVSW50MzJCRSg0KTtcbiAgICB0aGlzLmhhdmVMZW5ndGgoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBheWxvYWQgbGVuZ3RoIGhhcyBiZWVuIHJlYWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXZlTGVuZ3RoKGNiKSB7XG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggJiYgdGhpcy5fb3Bjb2RlIDwgMHgwOCkge1xuICAgICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoICs9IHRoaXMuX3BheWxvYWRMZW5ndGg7XG4gICAgICBpZiAodGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgMTAwOSxcbiAgICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9tYXNrZWQpIHRoaXMuX3N0YXRlID0gR0VUX01BU0s7XG4gICAgZWxzZSB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIG1hc2sgYnl0ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRNYXNrKCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgNCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX21hc2sgPSB0aGlzLmNvbnN1bWUoNCk7XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBkYXRhIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0RGF0YShjYikge1xuICAgIGxldCBkYXRhID0gRU1QVFlfQlVGRkVSO1xuXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgdGhpcy5fcGF5bG9hZExlbmd0aCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGF0YSA9IHRoaXMuY29uc3VtZSh0aGlzLl9wYXlsb2FkTGVuZ3RoKTtcblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9tYXNrZWQgJiZcbiAgICAgICAgKHRoaXMuX21hc2tbMF0gfCB0aGlzLl9tYXNrWzFdIHwgdGhpcy5fbWFza1syXSB8IHRoaXMuX21hc2tbM10pICE9PSAwXG4gICAgICApIHtcbiAgICAgICAgdW5tYXNrKGRhdGEsIHRoaXMuX21hc2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcGNvZGUgPiAweDA3KSB7XG4gICAgICB0aGlzLmNvbnRyb2xNZXNzYWdlKGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29tcHJlc3NlZCkge1xuICAgICAgdGhpcy5fc3RhdGUgPSBJTkZMQVRJTkc7XG4gICAgICB0aGlzLmRlY29tcHJlc3MoZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCkge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgbWVzc2FnZSBpcyBub3QgY29tcHJlc3NlZCBzbyBpdHMgbGVuZ3RoIGlzIHRoZSBzdW0gb2YgdGhlIHBheWxvYWRcbiAgICAgIC8vIGxlbmd0aCBvZiBhbGwgZnJhZ21lbnRzLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGg7XG4gICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChkYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGFNZXNzYWdlKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzZXMgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgcGVyTWVzc2FnZURlZmxhdGUuZGVjb21wcmVzcyhkYXRhLCB0aGlzLl9maW4sIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGlmIChidWYubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgMTAwOSxcbiAgICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChidWYpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRhdGFNZXNzYWdlKGNiKTtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gR0VUX0lORk8pIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGF0YU1lc3NhZ2UoY2IpIHtcbiAgICBpZiAoIXRoaXMuX2Zpbikge1xuICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZXNzYWdlTGVuZ3RoID0gdGhpcy5fbWVzc2FnZUxlbmd0aDtcbiAgICBjb25zdCBmcmFnbWVudHMgPSB0aGlzLl9mcmFnbWVudHM7XG5cbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMikge1xuICAgICAgbGV0IGRhdGE7XG5cbiAgICAgIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnbm9kZWJ1ZmZlcicpIHtcbiAgICAgICAgZGF0YSA9IGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgIGRhdGEgPSB0b0FycmF5QnVmZmVyKGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgQmxvYihmcmFnbWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IGZyYWdtZW50cztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEsIHRydWUpO1xuICAgICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICAgICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYnVmID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG5cbiAgICAgIGlmICghdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uICYmICFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDA3LFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9VVEY4J1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc3RhdGUgPT09IElORkxBVElORyB8fCB0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGJ1ZiwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBERUZFUl9FVkVOVDtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBidWYsIGZhbHNlKTtcbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBjb250cm9sIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIERhdGEgdG8gaGFuZGxlXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnRyb2xNZXNzYWdlKGRhdGEsIGNiKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb25jbHVkZScsIDEwMDUsIEVNUFRZX0JVRkZFUik7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMCk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICBgaW52YWxpZCBzdGF0dXMgY29kZSAke2NvZGV9YCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDAyLFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NMT1NFX0NPREUnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWYgPSBuZXcgRmFzdEJ1ZmZlcihcbiAgICAgICAgICBkYXRhLmJ1ZmZlcixcbiAgICAgICAgICBkYXRhLmJ5dGVPZmZzZXQgKyAyLFxuICAgICAgICAgIGRhdGEubGVuZ3RoIC0gMlxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uICYmICFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgICAgRXJyb3IsXG4gICAgICAgICAgICAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgMTAwNyxcbiAgICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9VVEY4J1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjYihlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXQoJ2NvbmNsdWRlJywgY29kZSwgYnVmKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYWxsb3dTeW5jaHJvbm91c0V2ZW50cykge1xuICAgICAgdGhpcy5lbWl0KHRoaXMuX29wY29kZSA9PT0gMHgwOSA/ICdwaW5nJyA6ICdwb25nJywgZGF0YSk7XG4gICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuX29wY29kZSA9PT0gMHgwOSA/ICdwaW5nJyA6ICdwb25nJywgZGF0YSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYW4gZXJyb3Igb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpFcnJvcnxSYW5nZUVycm9yKX0gRXJyb3JDdG9yIFRoZSBlcnJvciBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZpeCBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gYWRkIGEgZGVmYXVsdCBwcmVmaXggdG9cbiAgICogICAgIGBtZXNzYWdlYFxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzQ29kZSBUaGUgc3RhdHVzIGNvZGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVycm9yQ29kZSBUaGUgZXhwb3NlZCBlcnJvciBjb2RlXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yKX0gVGhlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVFcnJvcihFcnJvckN0b3IsIG1lc3NhZ2UsIHByZWZpeCwgc3RhdHVzQ29kZSwgZXJyb3JDb2RlKSB7XG4gICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgIHRoaXMuX2Vycm9yZWQgPSB0cnVlO1xuXG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yQ3RvcihcbiAgICAgIHByZWZpeCA/IGBJbnZhbGlkIFdlYlNvY2tldCBmcmFtZTogJHttZXNzYWdlfWAgOiBtZXNzYWdlXG4gICAgKTtcblxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgdGhpcy5jcmVhdGVFcnJvcik7XG4gICAgZXJyLmNvZGUgPSBlcnJvckNvZGU7XG4gICAgZXJyW2tTdGF0dXNDb2RlXSA9IHN0YXR1c0NvZGU7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY2VpdmVyO1xuIiwgIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXkR1cGxleFwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyByYW5kb21GaWxsU3luYyB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHsgRU1QVFlfQlVGRkVSLCBrV2ViU29ja2V0LCBOT09QIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBpc0Jsb2IsIGlzVmFsaWRTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcbmNvbnN0IHsgbWFzazogYXBwbHlNYXNrLCB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCBrQnl0ZUxlbmd0aCA9IFN5bWJvbCgna0J5dGVMZW5ndGgnKTtcbmNvbnN0IG1hc2tCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG5jb25zdCBSQU5ET01fUE9PTF9TSVpFID0gOCAqIDEwMjQ7XG5sZXQgcmFuZG9tUG9vbDtcbmxldCByYW5kb21Qb29sUG9pbnRlciA9IFJBTkRPTV9QT09MX1NJWkU7XG5cbmNvbnN0IERFRkFVTFQgPSAwO1xuY29uc3QgREVGTEFUSU5HID0gMTtcbmNvbnN0IEdFVF9CTE9CX0RBVEEgPSAyO1xuXG4vKipcbiAqIEh5QmkgU2VuZGVyIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBTZW5kZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFNlbmRlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgY29ubmVjdGlvbiBzb2NrZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRlbnNpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtnZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvY2tldCwgZXh0ZW5zaW9ucywgZ2VuZXJhdGVNYXNrKSB7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XG5cbiAgICBpZiAoZ2VuZXJhdGVNYXNrKSB7XG4gICAgICB0aGlzLl9nZW5lcmF0ZU1hc2sgPSBnZW5lcmF0ZU1hc2s7XG4gICAgICB0aGlzLl9tYXNrQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIH1cblxuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcblxuICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuICAgIHRoaXMuX2NvbXByZXNzID0gZmFsc2U7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX3N0YXRlID0gREVGQVVMVDtcbiAgICB0aGlzLm9uZXJyb3IgPSBOT09QO1xuICAgIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGEgcGllY2Ugb2YgZGF0YSBhY2NvcmRpbmcgdG8gdGhlIEh5QmkgV2ViU29ja2V0IHByb3RvY29sLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBUaGUgZGF0YSB0byBmcmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIEZJTiBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW29wdGlvbnMubWFza0J1ZmZlcl0gVGhlIGJ1ZmZlciB1c2VkIHRvIHN0b3JlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxuICAgKiAgICAgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgUlNWMSBiaXRcbiAgICogQHJldHVybiB7KEJ1ZmZlcnxTdHJpbmcpW119IFRoZSBmcmFtZWQgZGF0YVxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgZnJhbWUoZGF0YSwgb3B0aW9ucykge1xuICAgIGxldCBtYXNrO1xuICAgIGxldCBtZXJnZSA9IGZhbHNlO1xuICAgIGxldCBvZmZzZXQgPSAyO1xuICAgIGxldCBza2lwTWFza2luZyA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMubWFzaykge1xuICAgICAgbWFzayA9IG9wdGlvbnMubWFza0J1ZmZlciB8fCBtYXNrQnVmZmVyO1xuXG4gICAgICBpZiAob3B0aW9ucy5nZW5lcmF0ZU1hc2spIHtcbiAgICAgICAgb3B0aW9ucy5nZW5lcmF0ZU1hc2sobWFzayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmFuZG9tUG9vbFBvaW50ZXIgPT09IFJBTkRPTV9QT09MX1NJWkUpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cbiAgICAgICAgICBpZiAocmFuZG9tUG9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBsYXppbHkgaW5pdGlhbGl6ZWQgYmVjYXVzZSBzZXJ2ZXItc2VudCBmcmFtZXMgbXVzdCBub3RcbiAgICAgICAgICAgIC8vIGJlIG1hc2tlZCBzbyBpdCBtYXkgbmV2ZXIgYmUgdXNlZC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICByYW5kb21Qb29sID0gQnVmZmVyLmFsbG9jKFJBTkRPTV9QT09MX1NJWkUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJhbmRvbUZpbGxTeW5jKHJhbmRvbVBvb2wsIDAsIFJBTkRPTV9QT09MX1NJWkUpO1xuICAgICAgICAgIHJhbmRvbVBvb2xQb2ludGVyID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hc2tbMF0gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuICAgICAgICBtYXNrWzFdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcbiAgICAgICAgbWFza1syXSA9IHJhbmRvbVBvb2xbcmFuZG9tUG9vbFBvaW50ZXIrK107XG4gICAgICAgIG1hc2tbM10gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuICAgICAgfVxuXG4gICAgICBza2lwTWFza2luZyA9IChtYXNrWzBdIHwgbWFza1sxXSB8IG1hc2tbMl0gfCBtYXNrWzNdKSA9PT0gMDtcbiAgICAgIG9mZnNldCA9IDY7XG4gICAgfVxuXG4gICAgbGV0IGRhdGFMZW5ndGg7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoXG4gICAgICAgICghb3B0aW9ucy5tYXNrIHx8IHNraXBNYXNraW5nKSAmJlxuICAgICAgICBvcHRpb25zW2tCeXRlTGVuZ3RoXSAhPT0gdW5kZWZpbmVkXG4gICAgICApIHtcbiAgICAgICAgZGF0YUxlbmd0aCA9IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIG1lcmdlID0gb3B0aW9ucy5tYXNrICYmIG9wdGlvbnMucmVhZE9ubHkgJiYgIXNraXBNYXNraW5nO1xuICAgIH1cblxuICAgIGxldCBwYXlsb2FkTGVuZ3RoID0gZGF0YUxlbmd0aDtcblxuICAgIGlmIChkYXRhTGVuZ3RoID49IDY1NTM2KSB7XG4gICAgICBvZmZzZXQgKz0gODtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjc7XG4gICAgfSBlbHNlIGlmIChkYXRhTGVuZ3RoID4gMTI1KSB7XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjY7XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lcmdlID8gZGF0YUxlbmd0aCArIG9mZnNldCA6IG9mZnNldCk7XG5cbiAgICB0YXJnZXRbMF0gPSBvcHRpb25zLmZpbiA/IG9wdGlvbnMub3Bjb2RlIHwgMHg4MCA6IG9wdGlvbnMub3Bjb2RlO1xuICAgIGlmIChvcHRpb25zLnJzdjEpIHRhcmdldFswXSB8PSAweDQwO1xuXG4gICAgdGFyZ2V0WzFdID0gcGF5bG9hZExlbmd0aDtcblxuICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgIHRhcmdldC53cml0ZVVJbnQxNkJFKGRhdGFMZW5ndGgsIDIpO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICB0YXJnZXRbMl0gPSB0YXJnZXRbM10gPSAwO1xuICAgICAgdGFyZ2V0LndyaXRlVUludEJFKGRhdGFMZW5ndGgsIDQsIDYpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5tYXNrKSByZXR1cm4gW3RhcmdldCwgZGF0YV07XG5cbiAgICB0YXJnZXRbMV0gfD0gMHg4MDtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gNF0gPSBtYXNrWzBdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAzXSA9IG1hc2tbMV07XG4gICAgdGFyZ2V0W29mZnNldCAtIDJdID0gbWFza1syXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMV0gPSBtYXNrWzNdO1xuXG4gICAgaWYgKHNraXBNYXNraW5nKSByZXR1cm4gW3RhcmdldCwgZGF0YV07XG5cbiAgICBpZiAobWVyZ2UpIHtcbiAgICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCB0YXJnZXQsIG9mZnNldCwgZGF0YUxlbmd0aCk7XG4gICAgICByZXR1cm4gW3RhcmdldF07XG4gICAgfVxuXG4gICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIGRhdGEsIDAsIGRhdGFMZW5ndGgpO1xuICAgIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGNsb3NlIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29kZV0gVGhlIHN0YXR1cyBjb2RlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyKX0gW2RhdGFdIFRoZSBtZXNzYWdlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNvZGUsIGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgbGV0IGJ1ZjtcblxuICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJ1ZiA9IEVNUFRZX0JVRkZFUjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJyB8fCAhaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSB2YWxpZCBlcnJvciBjb2RlIG51bWJlcicpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkIHx8ICFkYXRhLmxlbmd0aCkge1xuICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpO1xuICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuXG4gICAgICBpZiAobGVuZ3RoID4gMTIzKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgbWVzc2FnZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTIzIGJ5dGVzJyk7XG4gICAgICB9XG5cbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyICsgbGVuZ3RoKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJ1Zi53cml0ZShkYXRhLCAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1Zi5zZXQoZGF0YSwgMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ1Zi5sZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlOiAweDA4LFxuICAgICAgcmVhZE9ubHk6IGZhbHNlLFxuICAgICAgcnN2MTogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGJ1ZiwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShidWYsIG9wdGlvbnMpLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcGluZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBwaW5nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEuc2l6ZTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDB4MDksXG4gICAgICByZWFkT25seSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgICB0aGlzLmVucXVldWUoW3RoaXMuZ2V0QmxvYkRhdGEsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nZXRCbG9iRGF0YShkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBvbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLnNpemU7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyLnJlYWRPbmx5O1xuICAgIH1cblxuICAgIGlmIChieXRlTGVuZ3RoID4gMTI1KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGRhdGEgc2l6ZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTI1IGJ5dGVzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlOiAweDBhLFxuICAgICAgcmVhZE9ubHksXG4gICAgICByc3YxOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgICBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmdldEJsb2JEYXRhLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2V0QmxvYkRhdGEoZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBkYXRhIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluYXJ5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5XG4gICAqICAgICBvciB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3M9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgY29tcHJlc3MgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlXG4gICAqICAgICBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuICAgIGxldCBvcGNvZGUgPSBvcHRpb25zLmJpbmFyeSA/IDIgOiAxO1xuICAgIGxldCByc3YxID0gb3B0aW9ucy5jb21wcmVzcztcblxuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLnNpemU7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyLnJlYWRPbmx5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9maXJzdEZyYWdtZW50KSB7XG4gICAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gZmFsc2U7XG4gICAgICBpZiAoXG4gICAgICAgIHJzdjEgJiZcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUgJiZcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUucGFyYW1zW1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLl9pc1NlcnZlclxuICAgICAgICAgICAgPyAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgICAgICA6ICdjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgXVxuICAgICAgKSB7XG4gICAgICAgIHJzdjEgPSBieXRlTGVuZ3RoID49IHBlck1lc3NhZ2VEZWZsYXRlLl90aHJlc2hvbGQ7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb21wcmVzcyA9IHJzdjE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJzdjEgPSBmYWxzZTtcbiAgICAgIG9wY29kZSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZmluKSB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcblxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxuICAgICAgZmluOiBvcHRpb25zLmZpbixcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzazogb3B0aW9ucy5tYXNrLFxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgIG9wY29kZSxcbiAgICAgIHJlYWRPbmx5LFxuICAgICAgcnN2MVxuICAgIH07XG5cbiAgICBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgICBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmdldEJsb2JEYXRhLCBkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2V0QmxvYkRhdGEoZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc3BhdGNoKGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGNvbnRlbnRzIG9mIGEgYmxvYiBhcyBiaW5hcnkgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCbG9ifSBibG9iIFRoZSBibG9iXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIHRoZSBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5tYXNrQnVmZmVyXSBUaGUgYnVmZmVyIHVzZWQgdG8gc3RvcmUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBSU1YxIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRCbG9iRGF0YShibG9iLCBjb21wcmVzcywgb3B0aW9ucywgY2IpIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgIHRoaXMuX3N0YXRlID0gR0VUX0JMT0JfREFUQTtcblxuICAgIGJsb2JcbiAgICAgIC5hcnJheUJ1ZmZlcigpXG4gICAgICAudGhlbigoYXJyYXlCdWZmZXIpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3NvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIHNvY2tldCB3YXMgY2xvc2VkIHdoaWxlIHRoZSBibG9iIHdhcyBiZWluZyByZWFkJ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIGBjYWxsQ2FsbGJhY2tzYCBpcyBjYWxsZWQgaW4gdGhlIG5leHQgdGljayB0byBlbnN1cmUgdGhhdCBlcnJvcnNcbiAgICAgICAgICAvLyB0aGF0IG1pZ2h0IGJlIHRocm93biBpbiB0aGUgY2FsbGJhY2tzIGJlaGF2ZSBsaWtlIGVycm9ycyB0aHJvd25cbiAgICAgICAgICAvLyBvdXRzaWRlIHRoZSBwcm9taXNlIGNoYWluLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsQ2FsbGJhY2tzLCB0aGlzLCBlcnIsIGNiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgICBjb25zdCBkYXRhID0gdG9CdWZmZXIoYXJyYXlCdWZmZXIpO1xuXG4gICAgICAgIGlmICghY29tcHJlc3MpIHtcbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IERFRkFVTFQ7XG4gICAgICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgICAgICAgdGhpcy5kZXF1ZXVlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaChkYXRhLCBjb21wcmVzcywgb3B0aW9ucywgY2IpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gYG9uRXJyb3JgIGlzIGNhbGxlZCBpbiB0aGUgbmV4dCB0aWNrIGZvciB0aGUgc2FtZSByZWFzb24gdGhhdFxuICAgICAgICAvLyBgY2FsbENhbGxiYWNrc2AgYWJvdmUgaXMuXG4gICAgICAgIC8vXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2sob25FcnJvciwgdGhpcywgZXJyLCBjYik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBGSU4gYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcbiAgICogICAgIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRpc3BhdGNoKGRhdGEsIGNvbXByZXNzLCBvcHRpb25zLCBjYikge1xuICAgIGlmICghY29tcHJlc3MpIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgdGhpcy5fc3RhdGUgPSBERUZMQVRJTkc7XG4gICAgcGVyTWVzc2FnZURlZmxhdGUuY29tcHJlc3MoZGF0YSwgb3B0aW9ucy5maW4sIChfLCBidWYpID0+IHtcbiAgICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIHNvY2tldCB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIGNvbXByZXNzZWQnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2FsbENhbGxiYWNrcyh0aGlzLCBlcnIsIGNiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgdGhpcy5fc3RhdGUgPSBERUZBVUxUO1xuICAgICAgb3B0aW9ucy5yZWFkT25seSA9IGZhbHNlO1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHF1ZXVlZCBzZW5kIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXF1ZXVlKCkge1xuICAgIHdoaWxlICh0aGlzLl9zdGF0ZSA9PT0gREVGQVVMVCAmJiB0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gcGFyYW1zWzNdW2tCeXRlTGVuZ3RoXTtcbiAgICAgIFJlZmxlY3QuYXBwbHkocGFyYW1zWzBdLCB0aGlzLCBwYXJhbXMuc2xpY2UoMSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHNlbmQgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgU2VuZCBvcGVyYXRpb24gcGFyYW1ldGVycy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVucXVldWUocGFyYW1zKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBwYXJhbXNbM11ba0J5dGVMZW5ndGhdO1xuICAgIHRoaXMuX3F1ZXVlLnB1c2gocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBmcmFtZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlbmRGcmFtZShsaXN0LCBjYikge1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhpcy5fc29ja2V0LmNvcmsoKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzFdLCBjYik7XG4gICAgICB0aGlzLl9zb2NrZXQudW5jb3JrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdLCBjYik7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyO1xuXG4vKipcbiAqIENhbGxzIHF1ZXVlZCBjYWxsYmFja3Mgd2l0aCBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1NlbmRlcn0gc2VuZGVyIFRoZSBgU2VuZGVyYCBpbnN0YW5jZVxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvciB0byBjYWxsIHRoZSBjYWxsYmFja3Mgd2l0aFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBUaGUgZmlyc3QgY2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGxDYWxsYmFja3Moc2VuZGVyLCBlcnIsIGNiKSB7XG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIGNiKGVycik7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZW5kZXIuX3F1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc2VuZGVyLl9xdWV1ZVtpXTtcbiAgICBjb25zdCBjYWxsYmFjayA9IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjayhlcnIpO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlcyBhIGBTZW5kZXJgIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U2VuZGVyfSBzZW5kZXIgVGhlIGBTZW5kZXJgIGluc3RhbmNlXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIFRoZSBmaXJzdCBwZW5kaW5nIGNhbGxiYWNrXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBvbkVycm9yKHNlbmRlciwgZXJyLCBjYikge1xuICBjYWxsQ2FsbGJhY2tzKHNlbmRlciwgZXJyLCBjYik7XG4gIHNlbmRlci5vbmVycm9yKGVycik7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IGtGb3JPbkV2ZW50QXR0cmlidXRlLCBrTGlzdGVuZXIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IGtDb2RlID0gU3ltYm9sKCdrQ29kZScpO1xuY29uc3Qga0RhdGEgPSBTeW1ib2woJ2tEYXRhJyk7XG5jb25zdCBrRXJyb3IgPSBTeW1ib2woJ2tFcnJvcicpO1xuY29uc3Qga01lc3NhZ2UgPSBTeW1ib2woJ2tNZXNzYWdlJyk7XG5jb25zdCBrUmVhc29uID0gU3ltYm9sKCdrUmVhc29uJyk7XG5jb25zdCBrVGFyZ2V0ID0gU3ltYm9sKCdrVGFyZ2V0Jyk7XG5jb25zdCBrVHlwZSA9IFN5bWJvbCgna1R5cGUnKTtcbmNvbnN0IGtXYXNDbGVhbiA9IFN5bWJvbCgna1dhc0NsZWFuJyk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGV2ZW50LlxuICovXG5jbGFzcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYEV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIGB0eXBlYCBhcmd1bWVudCBpcyBub3Qgc3BlY2lmaWVkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgdGhpc1trVGFyZ2V0XSA9IG51bGw7XG4gICAgdGhpc1trVHlwZV0gPSB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IHRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpc1trVGFyZ2V0XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXNba1R5cGVdO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsICd0YXJnZXQnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCAndHlwZScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBjbG9zZSBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICovXG5jbGFzcyBDbG9zZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBDbG9zZUV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9iamVjdCB0aGF0IGFsbG93cyBmb3Igc2V0dGluZ1xuICAgKiAgICAgYXR0cmlidXRlcyB2aWEgb2JqZWN0IG1lbWJlcnMgb2YgdGhlIHNhbWUgbmFtZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29kZT0wXSBUaGUgc3RhdHVzIGNvZGUgZXhwbGFpbmluZyB3aHkgdGhlXG4gICAqICAgICBjb25uZWN0aW9uIHdhcyBjbG9zZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnJlYXNvbj0nJ10gQSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgZXhwbGFpbmluZyB3aHlcbiAgICogICAgIHRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53YXNDbGVhbj1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZVxuICAgKiAgICAgY29ubmVjdGlvbiB3YXMgY2xlYW5seSBjbG9zZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgdGhpc1trQ29kZV0gPSBvcHRpb25zLmNvZGUgPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRpb25zLmNvZGU7XG4gICAgdGhpc1trUmVhc29uXSA9IG9wdGlvbnMucmVhc29uID09PSB1bmRlZmluZWQgPyAnJyA6IG9wdGlvbnMucmVhc29uO1xuICAgIHRoaXNba1dhc0NsZWFuXSA9IG9wdGlvbnMud2FzQ2xlYW4gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3B0aW9ucy53YXNDbGVhbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGNvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXNba0NvZGVdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgcmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzW2tSZWFzb25dO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IHdhc0NsZWFuKCkge1xuICAgIHJldHVybiB0aGlzW2tXYXNDbGVhbl07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAnY29kZScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbG9zZUV2ZW50LnByb3RvdHlwZSwgJ3JlYXNvbicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbG9zZUV2ZW50LnByb3RvdHlwZSwgJ3dhc0NsZWFuJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBlcnJvciBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICovXG5jbGFzcyBFcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFcnJvckV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9iamVjdCB0aGF0IGFsbG93cyBmb3Igc2V0dGluZ1xuICAgKiAgICAgYXR0cmlidXRlcyB2aWEgb2JqZWN0IG1lbWJlcnMgb2YgdGhlIHNhbWUgbmFtZVxuICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLmVycm9yPW51bGxdIFRoZSBlcnJvciB0aGF0IGdlbmVyYXRlZCB0aGlzIGV2ZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlPScnXSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICB0aGlzW2tFcnJvcl0gPSBvcHRpb25zLmVycm9yID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5lcnJvcjtcbiAgICB0aGlzW2tNZXNzYWdlXSA9IG9wdGlvbnMubWVzc2FnZSA9PT0gdW5kZWZpbmVkID8gJycgOiBvcHRpb25zLm1lc3NhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgZXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXNba0Vycm9yXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXNba01lc3NhZ2VdO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFcnJvckV2ZW50LnByb3RvdHlwZSwgJ2Vycm9yJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVycm9yRXZlbnQucHJvdG90eXBlLCAnbWVzc2FnZScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBtZXNzYWdlIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIE1lc3NhZ2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgTWVzc2FnZUV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9iamVjdCB0aGF0IGFsbG93cyBmb3Igc2V0dGluZ1xuICAgKiAgICAgYXR0cmlidXRlcyB2aWEgb2JqZWN0IG1lbWJlcnMgb2YgdGhlIHNhbWUgbmFtZVxuICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLmRhdGE9bnVsbF0gVGhlIG1lc3NhZ2UgY29udGVudFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICB0aGlzW2tEYXRhXSA9IG9wdGlvbnMuZGF0YSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMuZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzW2tEYXRhXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZUV2ZW50LnByb3RvdHlwZSwgJ2RhdGEnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogVGhpcyBwcm92aWRlcyBtZXRob2RzIGZvciBlbXVsYXRpbmcgdGhlIGBFdmVudFRhcmdldGAgaW50ZXJmYWNlLiBJdCdzIG5vdFxuICogbWVhbnQgdG8gYmUgdXNlZCBkaXJlY3RseS5cbiAqXG4gKiBAbWl4aW5cbiAqL1xuY29uc3QgRXZlbnRUYXJnZXQgPSB7XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhbiBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIGxpc3RlbiBmb3JcbiAgICogQHBhcmFtIHsoRnVuY3Rpb258T2JqZWN0KX0gaGFuZGxlciBUaGUgbGlzdGVuZXIgdG8gYWRkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW4gb3B0aW9ucyBvYmplY3Qgc3BlY2lmaWVzIGNoYXJhY3RlcmlzdGljcyBhYm91dFxuICAgKiAgICAgdGhlIGV2ZW50IGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub25jZT1mYWxzZV0gQSBgQm9vbGVhbmAgaW5kaWNhdGluZyB0aGF0IHRoZVxuICAgKiAgICAgbGlzdGVuZXIgc2hvdWxkIGJlIGludm9rZWQgYXQgbW9zdCBvbmNlIGFmdGVyIGJlaW5nIGFkZGVkLiBJZiBgdHJ1ZWAsXG4gICAqICAgICB0aGUgbGlzdGVuZXIgd291bGQgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIHdoZW4gaW52b2tlZC5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBvcHRpb25zID0ge30pIHtcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKHR5cGUpKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFvcHRpb25zW2tGb3JPbkV2ZW50QXR0cmlidXRlXSAmJlxuICAgICAgICBsaXN0ZW5lcltrTGlzdGVuZXJdID09PSBoYW5kbGVyICYmXG4gICAgICAgICFsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV1cbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHdyYXBwZXI7XG5cbiAgICBpZiAodHlwZSA9PT0gJ21lc3NhZ2UnKSB7XG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25NZXNzYWdlKGRhdGEsIGlzQmluYXJ5KSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IE1lc3NhZ2VFdmVudCgnbWVzc2FnZScsIHtcbiAgICAgICAgICBkYXRhOiBpc0JpbmFyeSA/IGRhdGEgOiBkYXRhLnRvU3RyaW5nKClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjbG9zZScpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbkNsb3NlKGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ2xvc2VFdmVudCgnY2xvc2UnLCB7XG4gICAgICAgICAgY29kZSxcbiAgICAgICAgICByZWFzb246IG1lc3NhZ2UudG9TdHJpbmcoKSxcbiAgICAgICAgICB3YXNDbGVhbjogdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkICYmIHRoaXMuX2Nsb3NlRnJhbWVTZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcbiAgICAgICAgY2FsbExpc3RlbmVyKGhhbmRsZXIsIHRoaXMsIGV2ZW50KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFcnJvckV2ZW50KCdlcnJvcicsIHtcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcbiAgICAgICAgY2FsbExpc3RlbmVyKGhhbmRsZXIsIHRoaXMsIGV2ZW50KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb3BlbicpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbk9wZW4oKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdvcGVuJyk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdyYXBwZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdID0gISFvcHRpb25zW2tGb3JPbkV2ZW50QXR0cmlidXRlXTtcbiAgICB3cmFwcGVyW2tMaXN0ZW5lcl0gPSBoYW5kbGVyO1xuXG4gICAgaWYgKG9wdGlvbnMub25jZSkge1xuICAgICAgdGhpcy5vbmNlKHR5cGUsIHdyYXBwZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKHR5cGUsIHdyYXBwZXIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSB7KEZ1bmN0aW9ufE9iamVjdCl9IGhhbmRsZXIgVGhlIGxpc3RlbmVyIHRvIHJlbW92ZVxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpIHtcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKHR5cGUpKSB7XG4gICAgICBpZiAobGlzdGVuZXJba0xpc3RlbmVyXSA9PT0gaGFuZGxlciAmJiAhbGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDbG9zZUV2ZW50LFxuICBFcnJvckV2ZW50LFxuICBFdmVudCxcbiAgRXZlbnRUYXJnZXQsXG4gIE1lc3NhZ2VFdmVudFxufTtcblxuLyoqXG4gKiBDYWxsIGFuIGV2ZW50IGxpc3RlbmVyXG4gKlxuICogQHBhcmFtIHsoRnVuY3Rpb258T2JqZWN0KX0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGNhbGxcbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgdmFsdWUgdG8gdXNlIGFzIGB0aGlzYGAgd2hlbiBjYWxsaW5nIHRoZSBsaXN0ZW5lclxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIHBhc3MgdG8gdGhlIGxpc3RlbmVyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjYWxsTGlzdGVuZXIobGlzdGVuZXIsIHRoaXNBcmcsIGV2ZW50KSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdvYmplY3QnICYmIGxpc3RlbmVyLmhhbmRsZUV2ZW50KSB7XG4gICAgbGlzdGVuZXIuaGFuZGxlRXZlbnQuY2FsbChsaXN0ZW5lciwgZXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGxpc3RlbmVyLmNhbGwodGhpc0FyZywgZXZlbnQpO1xuICB9XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IHRva2VuQ2hhcnMgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG4vKipcbiAqIEFkZHMgYW4gb2ZmZXIgdG8gdGhlIG1hcCBvZiBleHRlbnNpb24gb2ZmZXJzIG9yIGEgcGFyYW1ldGVyIHRvIHRoZSBtYXAgb2ZcbiAqIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3QgVGhlIG1hcCBvZiBleHRlbnNpb24gb2ZmZXJzIG9yIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBleHRlbnNpb24gb3IgcGFyYW1ldGVyIG5hbWVcbiAqIEBwYXJhbSB7KE9iamVjdHxCb29sZWFufFN0cmluZyl9IGVsZW0gVGhlIGV4dGVuc2lvbiBwYXJhbWV0ZXJzIG9yIHRoZVxuICogICAgIHBhcmFtZXRlciB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVzaChkZXN0LCBuYW1lLCBlbGVtKSB7XG4gIGlmIChkZXN0W25hbWVdID09PSB1bmRlZmluZWQpIGRlc3RbbmFtZV0gPSBbZWxlbV07XG4gIGVsc2UgZGVzdFtuYW1lXS5wdXNoKGVsZW0pO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGludG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHBhcnNlZCBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcGFyc2UoaGVhZGVyKSB7XG4gIGNvbnN0IG9mZmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBsZXQgbXVzdFVuZXNjYXBlID0gZmFsc2U7XG4gIGxldCBpc0VzY2FwaW5nID0gZmFsc2U7XG4gIGxldCBpblF1b3RlcyA9IGZhbHNlO1xuICBsZXQgZXh0ZW5zaW9uTmFtZTtcbiAgbGV0IHBhcmFtTmFtZTtcbiAgbGV0IHN0YXJ0ID0gLTE7XG4gIGxldCBjb2RlID0gLTE7XG4gIGxldCBlbmQgPSAtMTtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29kZSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBpICE9PSAwICYmXG4gICAgICAgIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5KSAvKiAnXFx0JyAqL1xuICAgICAgKSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiAvKiAnOycgKi8gfHwgY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIG5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiB8fCBjb2RlID09PSAweDJjKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgICBwdXNoKHBhcmFtcywgaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpLCB0cnVlKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNkIC8qICc9JyAqLyAmJiBzdGFydCAhPT0gLTEgJiYgZW5kID09PSAtMSkge1xuICAgICAgICBwYXJhbU5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgdmFsdWUgb2YgYSBxdW90ZWQtc3RyaW5nIGFmdGVyIHVuZXNjYXBpbmcgbXVzdCBjb25mb3JtIHRvIHRoZVxuICAgICAgLy8gdG9rZW4gQUJORiwgc28gb25seSB0b2tlbiBjaGFyYWN0ZXJzIGFyZSB2YWxpZC5cbiAgICAgIC8vIFJlZjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY0NTUjc2VjdGlvbi05LjFcbiAgICAgIC8vXG4gICAgICBpZiAoaXNFc2NhcGluZykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgZWxzZSBpZiAoIW11c3RVbmVzY2FwZSkgbXVzdFVuZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgaXNFc2NhcGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpblF1b3Rlcykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyIC8qICdcIicgKi8gJiYgc3RhcnQgIT09IC0xKSB7XG4gICAgICAgICAgaW5RdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4NWMgLyogJ1xcJyAqLykge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgJiYgaGVhZGVyLmNoYXJDb2RlQXQoaSAtIDEpID09PSAweDNkKSB7XG4gICAgICAgIGluUXVvdGVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQgIT09IC0xICYmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpKSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIGxldCB2YWx1ZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgICAgICAgbXVzdFVuZXNjYXBlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdmFsdWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgaW5RdW90ZXMgfHwgY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gIGNvbnN0IHRva2VuID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcHVzaChvZmZlcnMsIHRva2VuLCBwYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIGlmIChwYXJhbU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcHVzaChwYXJhbXMsIHRva2VuLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdG9rZW4ucmVwbGFjZSgvXFxcXC9nLCAnJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbik7XG4gICAgfVxuICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICB9XG5cbiAgcmV0dXJuIG9mZmVycztcbn1cblxuLyoqXG4gKiBCdWlsZHMgdGhlIGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgIGhlYWRlciBmaWVsZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBUaGUgbWFwIG9mIGV4dGVuc2lvbnMgYW5kIHBhcmFtZXRlcnMgdG8gZm9ybWF0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gb2JqZWN0XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdChleHRlbnNpb25zKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhleHRlbnNpb25zKVxuICAgIC5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgICAgbGV0IGNvbmZpZ3VyYXRpb25zID0gZXh0ZW5zaW9uc1tleHRlbnNpb25dO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZ3VyYXRpb25zKSkgY29uZmlndXJhdGlvbnMgPSBbY29uZmlndXJhdGlvbnNdO1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zXG4gICAgICAgIC5tYXAoKHBhcmFtcykgPT4ge1xuICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uXVxuICAgICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5tYXAoKGspID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVzID0gcGFyYW1zW2tdO1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzXG4gICAgICAgICAgICAgICAgICAubWFwKCh2KSA9PiAodiA9PT0gdHJ1ZSA/IGsgOiBgJHtrfT0ke3Z9YCkpXG4gICAgICAgICAgICAgICAgICAuam9pbignOyAnKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbignLCAnKTtcbiAgICB9KVxuICAgIC5qb2luKCcsICcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZm9ybWF0LCBwYXJzZSB9O1xuIiwgIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXkR1cGxleHxSZWFkYWJsZSRcIiwgXCJjYXVnaHRFcnJvcnNcIjogXCJub25lXCIgfV0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3QgeyByYW5kb21CeXRlcywgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCB7IER1cGxleCwgUmVhZGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBVUkwgfSA9IHJlcXVpcmUoJ3VybCcpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXInKTtcbmNvbnN0IFNlbmRlciA9IHJlcXVpcmUoJy4vc2VuZGVyJyk7XG5jb25zdCB7IGlzQmxvYiB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbmNvbnN0IHtcbiAgQklOQVJZX1RZUEVTLFxuICBFTVBUWV9CVUZGRVIsXG4gIEdVSUQsXG4gIGtGb3JPbkV2ZW50QXR0cmlidXRlLFxuICBrTGlzdGVuZXIsXG4gIGtTdGF0dXNDb2RlLFxuICBrV2ViU29ja2V0LFxuICBOT09QXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHtcbiAgRXZlbnRUYXJnZXQ6IHsgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciB9XG59ID0gcmVxdWlyZSgnLi9ldmVudC10YXJnZXQnKTtcbmNvbnN0IHsgZm9ybWF0LCBwYXJzZSB9ID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcbmNvbnN0IHsgdG9CdWZmZXIgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcblxuY29uc3QgY2xvc2VUaW1lb3V0ID0gMzAgKiAxMDAwO1xuY29uc3Qga0Fib3J0ZWQgPSBTeW1ib2woJ2tBYm9ydGVkJyk7XG5jb25zdCBwcm90b2NvbFZlcnNpb25zID0gWzgsIDEzXTtcbmNvbnN0IHJlYWR5U3RhdGVzID0gWydDT05ORUNUSU5HJywgJ09QRU4nLCAnQ0xPU0lORycsICdDTE9TRUQnXTtcbmNvbnN0IHN1YnByb3RvY29sUmVnZXggPSAvXlshIyQlJicqK1xcLS4wLTlBLVpeX2B8YS16fl0rJC87XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViU29ja2V0LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBXZWJTb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBXZWJTb2NrZXRgLlxuICAgKlxuICAgKiBAcGFyYW0geyhTdHJpbmd8VVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcbiAgICogQHBhcmFtIHsoU3RyaW5nfFN0cmluZ1tdKX0gW3Byb3RvY29sc10gVGhlIHN1YnByb3RvY29sc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbm5lY3Rpb24gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fY2xvc2VDb2RlID0gMTAwNjtcbiAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlTWVzc2FnZSA9IEVNUFRZX0JVRkZFUjtcbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9leHRlbnNpb25zID0ge307XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcHJvdG9jb2wgPSAnJztcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNPTk5FQ1RJTkc7XG4gICAgdGhpcy5fcmVjZWl2ZXIgPSBudWxsO1xuICAgIHRoaXMuX3NlbmRlciA9IG51bGw7XG4gICAgdGhpcy5fc29ja2V0ID0gbnVsbDtcblxuICAgIGlmIChhZGRyZXNzICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9idWZmZXJlZEFtb3VudCA9IDA7XG4gICAgICB0aGlzLl9pc1NlcnZlciA9IGZhbHNlO1xuICAgICAgdGhpcy5fcmVkaXJlY3RzID0gMDtcblxuICAgICAgaWYgKHByb3RvY29scyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG9jb2xzID09PSAnb2JqZWN0JyAmJiBwcm90b2NvbHMgIT09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gcHJvdG9jb2xzO1xuICAgICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluaXRBc0NsaWVudCh0aGlzLCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hdXRvUG9uZyA9IG9wdGlvbnMuYXV0b1Bvbmc7XG4gICAgICB0aGlzLl9pc1NlcnZlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvciBoaXN0b3JpY2FsIHJlYXNvbnMsIHRoZSBjdXN0b20gXCJub2RlYnVmZmVyXCIgdHlwZSBpcyB1c2VkIGJ5IHRoZSBkZWZhdWx0XG4gICAqIGluc3RlYWQgb2YgXCJibG9iXCIuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgYmluYXJ5VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmluYXJ5VHlwZTtcbiAgfVxuXG4gIHNldCBiaW5hcnlUeXBlKHR5cGUpIHtcbiAgICBpZiAoIUJJTkFSWV9UWVBFUy5pbmNsdWRlcyh0eXBlKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IHR5cGU7XG5cbiAgICAvL1xuICAgIC8vIEFsbG93IHRvIGNoYW5nZSBgYmluYXJ5VHlwZWAgb24gdGhlIGZseS5cbiAgICAvL1xuICAgIGlmICh0aGlzLl9yZWNlaXZlcikgdGhpcy5fcmVjZWl2ZXIuX2JpbmFyeVR5cGUgPSB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYnVmZmVyZWRBbW91bnQoKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHJldHVybiB0aGlzLl9idWZmZXJlZEFtb3VudDtcblxuICAgIHJldHVybiB0aGlzLl9zb2NrZXQuX3dyaXRhYmxlU3RhdGUubGVuZ3RoICsgdGhpcy5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgZXh0ZW5zaW9ucygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fZXh0ZW5zaW9ucykuam9pbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGlzUGF1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXVzZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9uY2xvc2UoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9uZXJyb3IoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9ub3BlbigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25tZXNzYWdlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgcHJvdG9jb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3RvY29sO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCB0aGUgc29ja2V0IGFuZCB0aGUgaW50ZXJuYWwgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlclxuICAgKiAgICAgYW55IG9mIHRoZSBgJ21lc3NhZ2UnYCwgYCdwaW5nJ2AsIGFuZCBgJ3BvbmcnYCBldmVudHMgY2FuIGJlIGVtaXR0ZWRcbiAgICogICAgIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIHRpY2tcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFNvY2tldChzb2NrZXQsIGhlYWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZWNlaXZlciA9IG5ldyBSZWNlaXZlcih7XG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiBvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHMsXG4gICAgICBiaW5hcnlUeXBlOiB0aGlzLmJpbmFyeVR5cGUsXG4gICAgICBleHRlbnNpb25zOiB0aGlzLl9leHRlbnNpb25zLFxuICAgICAgaXNTZXJ2ZXI6IHRoaXMuX2lzU2VydmVyLFxuICAgICAgbWF4UGF5bG9hZDogb3B0aW9ucy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiBvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvblxuICAgIH0pO1xuXG4gICAgY29uc3Qgc2VuZGVyID0gbmV3IFNlbmRlcihzb2NrZXQsIHRoaXMuX2V4dGVuc2lvbnMsIG9wdGlvbnMuZ2VuZXJhdGVNYXNrKTtcblxuICAgIHRoaXMuX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgdGhpcy5fc2VuZGVyID0gc2VuZGVyO1xuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcblxuICAgIHJlY2VpdmVyW2tXZWJTb2NrZXRdID0gdGhpcztcbiAgICBzZW5kZXJba1dlYlNvY2tldF0gPSB0aGlzO1xuICAgIHNvY2tldFtrV2ViU29ja2V0XSA9IHRoaXM7XG5cbiAgICByZWNlaXZlci5vbignY29uY2x1ZGUnLCByZWNlaXZlck9uQ29uY2x1ZGUpO1xuICAgIHJlY2VpdmVyLm9uKCdkcmFpbicsIHJlY2VpdmVyT25EcmFpbik7XG4gICAgcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkVycm9yKTtcbiAgICByZWNlaXZlci5vbignbWVzc2FnZScsIHJlY2VpdmVyT25NZXNzYWdlKTtcbiAgICByZWNlaXZlci5vbigncGluZycsIHJlY2VpdmVyT25QaW5nKTtcbiAgICByZWNlaXZlci5vbigncG9uZycsIHJlY2VpdmVyT25Qb25nKTtcblxuICAgIHNlbmRlci5vbmVycm9yID0gc2VuZGVyT25FcnJvcjtcblxuICAgIC8vXG4gICAgLy8gVGhlc2UgbWV0aG9kcyBtYXkgbm90IGJlIGF2YWlsYWJsZSBpZiBgc29ja2V0YCBpcyBqdXN0IGEgYER1cGxleGAuXG4gICAgLy9cbiAgICBpZiAoc29ja2V0LnNldFRpbWVvdXQpIHNvY2tldC5zZXRUaW1lb3V0KDApO1xuICAgIGlmIChzb2NrZXQuc2V0Tm9EZWxheSkgc29ja2V0LnNldE5vRGVsYXkoKTtcblxuICAgIGlmIChoZWFkLmxlbmd0aCA+IDApIHNvY2tldC51bnNoaWZ0KGhlYWQpO1xuXG4gICAgc29ja2V0Lm9uKCdjbG9zZScsIHNvY2tldE9uQ2xvc2UpO1xuICAgIHNvY2tldC5vbignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gICAgc29ja2V0Lm9uKCdlbmQnLCBzb2NrZXRPbkVuZCk7XG4gICAgc29ja2V0Lm9uKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5PUEVOO1xuICAgIHRoaXMuZW1pdCgnb3BlbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgdGhlIGAnY2xvc2UnYCBldmVudC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVtaXRDbG9zZSgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkge1xuICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgdGhpcy5fY2xvc2VDb2RlLCB0aGlzLl9jbG9zZU1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLmNsZWFudXAoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWNlaXZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgdGhpcy5fY2xvc2VDb2RlLCB0aGlzLl9jbG9zZU1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgY2xvc2luZyBoYW5kc2hha2UuXG4gICAqXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLStcbiAgICogICAgIC0gLSAtfHdzLmNsb3NlKCl8LS0+fGNsb3NlIGZyYW1lfC0tPnx3cy5jbG9zZSgpfC0gLSAtXG4gICAqICAgIHwgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLSsgICAgIHxcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICAgICAgIHxcbiAgICogQ0xPU0lORyAgfHdzLmNsb3NlKCl8PC0tfGNsb3NlIGZyYW1lfDwtLSstLS0tLSsgICAgICAgQ0xPU0lOR1xuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgfFxuICAgKiAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICstLS0rICAgICAgICB8XG4gICAqICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0+fGZpbnwgLSAtIC0gLVxuICAgKiAgICB8ICAgICAgICAgKy0tLSsgICAgICAgICAgICAgICAgICAgICAgfCAgICstLS0rXG4gICAqICAgICAtIC0gLSAtIC18ZmlufDwtLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAqICAgICAgICAgICAgICArLS0tK1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIFN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmdcbiAgICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcil9IFtkYXRhXSBUaGUgcmVhc29uIHdoeSB0aGUgY29ubmVjdGlvbiBpc1xuICAgKiAgICAgY2xvc2luZ1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjb2RlLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICBjb25zdCBtc2cgPSAnV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NJTkcpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgJiZcbiAgICAgICAgKHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCB8fCB0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHRoaXMuX3NlbmRlci5jbG9zZShjb2RlLCBkYXRhLCAhdGhpcy5faXNTZXJ2ZXIsIChlcnIpID0+IHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIGhhbmRsZWQgYnkgdGhlIGAnZXJyb3InYCBsaXN0ZW5lciBvbiB0aGUgc29ja2V0LiBXZSBvbmx5XG4gICAgICAvLyB3YW50IHRvIGtub3cgaWYgdGhlIGNsb3NlIGZyYW1lIGhhcyBiZWVuIHNlbnQgaGVyZS5cbiAgICAgIC8vXG4gICAgICBpZiAoZXJyKSByZXR1cm47XG5cbiAgICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gdHJ1ZTtcblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgfHxcbiAgICAgICAgdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgc2V0Q2xvc2VUaW1lcih0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZSB0aGUgc29ja2V0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBwYXVzZSgpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HIHx8XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRURcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMuX3NvY2tldC5wYXVzZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwaW5nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBpbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwaW5nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG1hc2s7XG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBpbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgcG9uZy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIHRoZSBwb25nIGlzIHNlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBkYXRhO1xuICAgICAgZGF0YSA9IG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBtYXNrO1xuICAgICAgbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWFzayA9PT0gdW5kZWZpbmVkKSBtYXNrID0gIXRoaXMuX2lzU2VydmVyO1xuICAgIHRoaXMuX3NlbmRlci5wb25nKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBtYXNrLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogUmVzdW1lIHRoZSBzb2NrZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlc3VtZSgpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HIHx8XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRURcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLm5lZWREcmFpbikgdGhpcy5fc29ja2V0LnJlc3VtZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBkYXRhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iaW5hcnldIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBpcyBiaW5hcnkgb3JcbiAgICogICAgIHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb21wcmVzc10gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZyYWdtZW50IGlzIHRoZVxuICAgKiAgICAgbGFzdCBvbmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIGRhdGEgaXMgd3JpdHRlbiBvdXRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2VuZChkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBiaW5hcnk6IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyxcbiAgICAgIG1hc2s6ICF0aGlzLl9pc1NlcnZlcixcbiAgICAgIGNvbXByZXNzOiB0cnVlLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAoIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZW5kZXIuc2VuZChkYXRhIHx8IEVNUFRZX0JVRkZFUiwgb3B0cywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNpYmx5IGNsb3NlIHRoZSBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0ZXJtaW5hdGUoKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICBjb25zdCBtc2cgPSAnV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NvY2tldCkge1xuICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgICAgdGhpcy5fc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ09OTkVDVElOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnQ09OTkVDVElORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NPTk5FQ1RJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENPTk5FQ1RJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnQ09OTkVDVElORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NPTk5FQ1RJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IE9QRU5cbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ09QRU4nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdPUEVOJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBPUEVOXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ09QRU4nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdPUEVOJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDTE9TSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0lORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0lOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDTE9TSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0lORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0VEXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDTE9TRUQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TRUQnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NFRFxuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDTE9TRUQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TRUQnKVxufSk7XG5cbltcbiAgJ2JpbmFyeVR5cGUnLFxuICAnYnVmZmVyZWRBbW91bnQnLFxuICAnZXh0ZW5zaW9ucycsXG4gICdpc1BhdXNlZCcsXG4gICdwcm90b2NvbCcsXG4gICdyZWFkeVN0YXRlJyxcbiAgJ3VybCdcbl0uZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsIHByb3BlcnR5LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG59KTtcblxuLy9cbi8vIEFkZCB0aGUgYG9ub3BlbmAsIGBvbmVycm9yYCwgYG9uY2xvc2VgLCBhbmQgYG9ubWVzc2FnZWAgYXR0cmlidXRlcy5cbi8vIFNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9jb21tcy5odG1sI3RoZS13ZWJzb2NrZXQtaW50ZXJmYWNlXG4vL1xuWydvcGVuJywgJ2Vycm9yJywgJ2Nsb3NlJywgJ21lc3NhZ2UnXS5mb3JFYWNoKChtZXRob2QpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsIGBvbiR7bWV0aG9kfWAsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldCgpIHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnMobWV0aG9kKSkge1xuICAgICAgICBpZiAobGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdKSByZXR1cm4gbGlzdGVuZXJba0xpc3RlbmVyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBzZXQoaGFuZGxlcikge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyhtZXRob2QpKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKG1ldGhvZCwgbGlzdGVuZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIobWV0aG9kLCBoYW5kbGVyLCB7XG4gICAgICAgIFtrRm9yT25FdmVudEF0dHJpYnV0ZV06IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59KTtcblxuV2ViU29ja2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcjtcbldlYlNvY2tldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBXZWJTb2NrZXQgY2xpZW50LlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIGNsaWVudCB0byBpbml0aWFsaXplXG4gKiBAcGFyYW0geyhTdHJpbmd8VVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3RvY29scyBUaGUgc3VicHJvdG9jb2xzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIGFueVxuICogICAgIG9mIHRoZSBgJ21lc3NhZ2UnYCwgYCdwaW5nJ2AsIGFuZCBgJ3BvbmcnYCBldmVudHMgY2FuIGJlIGVtaXR0ZWQgbXVsdGlwbGVcbiAqICAgICB0aW1lcyBpbiB0aGUgc2FtZSB0aWNrXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9Qb25nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICogICAgIGF1dG9tYXRpY2FsbHkgc2VuZCBhIHBvbmcgaW4gcmVzcG9uc2UgdG8gYSBwaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5maW5pc2hSZXF1ZXN0XSBBIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSB1c2VkIHRvXG4gKiAgICAgY3VzdG9taXplIHRoZSBoZWFkZXJzIG9mIGVhY2ggaHR0cCByZXF1ZXN0IGJlZm9yZSBpdCBpcyBzZW50XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZvbGxvd1JlZGlyZWN0cz1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gZm9sbG93XG4gKiAgICAgcmVkaXJlY3RzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICogICAgIG1hc2tpbmcga2V5XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGFuZHNoYWtlVGltZW91dF0gVGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZVxuICogICAgIGhhbmRzaGFrZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0xMDQ4NTc2MDBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZVxuICogICAgIHNpemVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhSZWRpcmVjdHM9MTBdIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZWRpcmVjdHNcbiAqICAgICBhbGxvd2VkXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMub3JpZ2luXSBWYWx1ZSBvZiB0aGUgYE9yaWdpbmAgb3JcbiAqICAgICBgU2VjLVdlYlNvY2tldC1PcmlnaW5gIGhlYWRlclxuICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBbb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZT10cnVlXSBFbmFibGUvZGlzYWJsZVxuICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnByb3RvY29sVmVyc2lvbj0xM10gVmFsdWUgb2YgdGhlXG4gKiAgICAgYFNlYy1XZWJTb2NrZXQtVmVyc2lvbmAgaGVhZGVyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5pdEFzQ2xpZW50KHdlYnNvY2tldCwgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogdHJ1ZSxcbiAgICBhdXRvUG9uZzogdHJ1ZSxcbiAgICBwcm90b2NvbFZlcnNpb246IHByb3RvY29sVmVyc2lvbnNbMV0sXG4gICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgc2tpcFVURjhWYWxpZGF0aW9uOiBmYWxzZSxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdHJ1ZSxcbiAgICBmb2xsb3dSZWRpcmVjdHM6IGZhbHNlLFxuICAgIG1heFJlZGlyZWN0czogMTAsXG4gICAgLi4ub3B0aW9ucyxcbiAgICBzb2NrZXRQYXRoOiB1bmRlZmluZWQsXG4gICAgaG9zdG5hbWU6IHVuZGVmaW5lZCxcbiAgICBwcm90b2NvbDogdW5kZWZpbmVkLFxuICAgIHRpbWVvdXQ6IHVuZGVmaW5lZCxcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIGhvc3Q6IHVuZGVmaW5lZCxcbiAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgcG9ydDogdW5kZWZpbmVkXG4gIH07XG5cbiAgd2Vic29ja2V0Ll9hdXRvUG9uZyA9IG9wdHMuYXV0b1Bvbmc7XG5cbiAgaWYgKCFwcm90b2NvbFZlcnNpb25zLmluY2x1ZGVzKG9wdHMucHJvdG9jb2xWZXJzaW9uKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgYFVuc3VwcG9ydGVkIHByb3RvY29sIHZlcnNpb246ICR7b3B0cy5wcm90b2NvbFZlcnNpb259IGAgK1xuICAgICAgICBgKHN1cHBvcnRlZCB2ZXJzaW9uczogJHtwcm90b2NvbFZlcnNpb25zLmpvaW4oJywgJyl9KWBcbiAgICApO1xuICB9XG5cbiAgbGV0IHBhcnNlZFVybDtcblxuICBpZiAoYWRkcmVzcyBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHBhcnNlZFVybCA9IGFkZHJlc3M7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFVybCA9IG5ldyBVUkwoYWRkcmVzcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIFVSTDogJHthZGRyZXNzfWApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICBwYXJzZWRVcmwucHJvdG9jb2wgPSAnd3M6JztcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgcGFyc2VkVXJsLnByb3RvY29sID0gJ3dzczonO1xuICB9XG5cbiAgd2Vic29ja2V0Ll91cmwgPSBwYXJzZWRVcmwuaHJlZjtcblxuICBjb25zdCBpc1NlY3VyZSA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ3dzczonO1xuICBjb25zdCBpc0lwY1VybCA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ3dzK3VuaXg6JztcbiAgbGV0IGludmFsaWRVcmxNZXNzYWdlO1xuXG4gIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgIT09ICd3czonICYmICFpc1NlY3VyZSAmJiAhaXNJcGNVcmwpIHtcbiAgICBpbnZhbGlkVXJsTWVzc2FnZSA9XG4gICAgICAnVGhlIFVSTFxcJ3MgcHJvdG9jb2wgbXVzdCBiZSBvbmUgb2YgXCJ3czpcIiwgXCJ3c3M6XCIsICcgK1xuICAgICAgJ1wiaHR0cDpcIiwgXCJodHRwc1wiLCBvciBcIndzK3VuaXg6XCInO1xuICB9IGVsc2UgaWYgKGlzSXBjVXJsICYmICFwYXJzZWRVcmwucGF0aG5hbWUpIHtcbiAgICBpbnZhbGlkVXJsTWVzc2FnZSA9IFwiVGhlIFVSTCdzIHBhdGhuYW1lIGlzIGVtcHR5XCI7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLmhhc2gpIHtcbiAgICBpbnZhbGlkVXJsTWVzc2FnZSA9ICdUaGUgVVJMIGNvbnRhaW5zIGEgZnJhZ21lbnQgaWRlbnRpZmllcic7XG4gIH1cblxuICBpZiAoaW52YWxpZFVybE1lc3NhZ2UpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgU3ludGF4RXJyb3IoaW52YWxpZFVybE1lc3NhZ2UpO1xuXG4gICAgaWYgKHdlYnNvY2tldC5fcmVkaXJlY3RzID09PSAwKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZWZhdWx0UG9ydCA9IGlzU2VjdXJlID8gNDQzIDogODA7XG4gIGNvbnN0IGtleSA9IHJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnYmFzZTY0Jyk7XG4gIGNvbnN0IHJlcXVlc3QgPSBpc1NlY3VyZSA/IGh0dHBzLnJlcXVlc3QgOiBodHRwLnJlcXVlc3Q7XG4gIGNvbnN0IHByb3RvY29sU2V0ID0gbmV3IFNldCgpO1xuICBsZXQgcGVyTWVzc2FnZURlZmxhdGU7XG5cbiAgb3B0cy5jcmVhdGVDb25uZWN0aW9uID1cbiAgICBvcHRzLmNyZWF0ZUNvbm5lY3Rpb24gfHwgKGlzU2VjdXJlID8gdGxzQ29ubmVjdCA6IG5ldENvbm5lY3QpO1xuICBvcHRzLmRlZmF1bHRQb3J0ID0gb3B0cy5kZWZhdWx0UG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0cy5wb3J0ID0gcGFyc2VkVXJsLnBvcnQgfHwgZGVmYXVsdFBvcnQ7XG4gIG9wdHMuaG9zdCA9IHBhcnNlZFVybC5ob3N0bmFtZS5zdGFydHNXaXRoKCdbJylcbiAgICA/IHBhcnNlZFVybC5ob3N0bmFtZS5zbGljZSgxLCAtMSlcbiAgICA6IHBhcnNlZFVybC5ob3N0bmFtZTtcbiAgb3B0cy5oZWFkZXJzID0ge1xuICAgIC4uLm9wdHMuaGVhZGVycyxcbiAgICAnU2VjLVdlYlNvY2tldC1WZXJzaW9uJzogb3B0cy5wcm90b2NvbFZlcnNpb24sXG4gICAgJ1NlYy1XZWJTb2NrZXQtS2V5Jzoga2V5LFxuICAgIENvbm5lY3Rpb246ICdVcGdyYWRlJyxcbiAgICBVcGdyYWRlOiAnd2Vic29ja2V0J1xuICB9O1xuICBvcHRzLnBhdGggPSBwYXJzZWRVcmwucGF0aG5hbWUgKyBwYXJzZWRVcmwuc2VhcmNoO1xuICBvcHRzLnRpbWVvdXQgPSBvcHRzLmhhbmRzaGFrZVRpbWVvdXQ7XG5cbiAgaWYgKG9wdHMucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgIG9wdHMucGVyTWVzc2FnZURlZmxhdGUgIT09IHRydWUgPyBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIDoge30sXG4gICAgICBmYWxzZSxcbiAgICAgIG9wdHMubWF4UGF5bG9hZFxuICAgICk7XG4gICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMnXSA9IGZvcm1hdCh7XG4gICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IHBlck1lc3NhZ2VEZWZsYXRlLm9mZmVyKClcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvdG9jb2xzLmxlbmd0aCkge1xuICAgIGZvciAoY29uc3QgcHJvdG9jb2wgb2YgcHJvdG9jb2xzKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBwcm90b2NvbCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgIXN1YnByb3RvY29sUmVnZXgudGVzdChwcm90b2NvbCkgfHxcbiAgICAgICAgcHJvdG9jb2xTZXQuaGFzKHByb3RvY29sKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICAnQW4gaW52YWxpZCBvciBkdXBsaWNhdGVkIHN1YnByb3RvY29sIHdhcyBzcGVjaWZpZWQnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvY29sU2V0LmFkZChwcm90b2NvbCk7XG4gICAgfVxuXG4gICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LVByb3RvY29sJ10gPSBwcm90b2NvbHMuam9pbignLCcpO1xuICB9XG4gIGlmIChvcHRzLm9yaWdpbikge1xuICAgIGlmIChvcHRzLnByb3RvY29sVmVyc2lvbiA8IDEzKSB7XG4gICAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtT3JpZ2luJ10gPSBvcHRzLm9yaWdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cy5oZWFkZXJzLk9yaWdpbiA9IG9wdHMub3JpZ2luO1xuICAgIH1cbiAgfVxuICBpZiAocGFyc2VkVXJsLnVzZXJuYW1lIHx8IHBhcnNlZFVybC5wYXNzd29yZCkge1xuICAgIG9wdHMuYXV0aCA9IGAke3BhcnNlZFVybC51c2VybmFtZX06JHtwYXJzZWRVcmwucGFzc3dvcmR9YDtcbiAgfVxuXG4gIGlmIChpc0lwY1VybCkge1xuICAgIGNvbnN0IHBhcnRzID0gb3B0cy5wYXRoLnNwbGl0KCc6Jyk7XG5cbiAgICBvcHRzLnNvY2tldFBhdGggPSBwYXJ0c1swXTtcbiAgICBvcHRzLnBhdGggPSBwYXJ0c1sxXTtcbiAgfVxuXG4gIGxldCByZXE7XG5cbiAgaWYgKG9wdHMuZm9sbG93UmVkaXJlY3RzKSB7XG4gICAgaWYgKHdlYnNvY2tldC5fcmVkaXJlY3RzID09PSAwKSB7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjID0gaXNJcGNVcmw7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsU2VjdXJlID0gaXNTZWN1cmU7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aCA9IGlzSXBjVXJsXG4gICAgICAgID8gb3B0cy5zb2NrZXRQYXRoXG4gICAgICAgIDogcGFyc2VkVXJsLmhvc3Q7XG5cbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRpb25zICYmIG9wdGlvbnMuaGVhZGVycztcblxuICAgICAgLy9cbiAgICAgIC8vIFNoYWxsb3cgY29weSB0aGUgdXNlciBwcm92aWRlZCBvcHRpb25zIHNvIHRoYXQgaGVhZGVycyBjYW4gYmUgY2hhbmdlZFxuICAgICAgLy8gd2l0aG91dCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgLy9cbiAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGhlYWRlcnM6IHt9IH07XG5cbiAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgb3B0aW9ucy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh3ZWJzb2NrZXQubGlzdGVuZXJDb3VudCgncmVkaXJlY3QnKSA9PT0gMCkge1xuICAgICAgY29uc3QgaXNTYW1lSG9zdCA9IGlzSXBjVXJsXG4gICAgICAgID8gd2Vic29ja2V0Ll9vcmlnaW5hbElwY1xuICAgICAgICAgID8gb3B0cy5zb2NrZXRQYXRoID09PSB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aFxuICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgOiB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjXG4gICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgIDogcGFyc2VkVXJsLmhvc3QgPT09IHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoO1xuXG4gICAgICBpZiAoIWlzU2FtZUhvc3QgfHwgKHdlYnNvY2tldC5fb3JpZ2luYWxTZWN1cmUgJiYgIWlzU2VjdXJlKSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBNYXRjaCBjdXJsIDcuNzcuMCBiZWhhdmlvciBhbmQgZHJvcCB0aGUgZm9sbG93aW5nIGhlYWRlcnMuIFRoZXNlXG4gICAgICAgIC8vIGhlYWRlcnMgYXJlIGFsc28gZHJvcHBlZCB3aGVuIGZvbGxvd2luZyBhIHJlZGlyZWN0IHRvIGEgc3ViZG9tYWluLlxuICAgICAgICAvL1xuICAgICAgICBkZWxldGUgb3B0cy5oZWFkZXJzLmF1dGhvcml6YXRpb247XG4gICAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuY29va2llO1xuXG4gICAgICAgIGlmICghaXNTYW1lSG9zdCkgZGVsZXRlIG9wdHMuaGVhZGVycy5ob3N0O1xuXG4gICAgICAgIG9wdHMuYXV0aCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIE1hdGNoIGN1cmwgNy43Ny4wIGJlaGF2aW9yIGFuZCBtYWtlIHRoZSBmaXJzdCBgQXV0aG9yaXphdGlvbmAgaGVhZGVyIHdpbi5cbiAgICAvLyBJZiB0aGUgYEF1dGhvcml6YXRpb25gIGhlYWRlciBpcyBzZXQsIHRoZW4gdGhlcmUgaXMgbm90aGluZyB0byBkbyBhcyBpdFxuICAgIC8vIHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICAgIC8vXG4gICAgaWYgKG9wdHMuYXV0aCAmJiAhb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24pIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVycy5hdXRob3JpemF0aW9uID1cbiAgICAgICAgJ0Jhc2ljICcgKyBCdWZmZXIuZnJvbShvcHRzLmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IHJlcXVlc3Qob3B0cyk7XG5cbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMpIHtcbiAgICAgIC8vXG4gICAgICAvLyBVbmxpa2Ugd2hhdCBpcyBkb25lIGZvciB0aGUgYCd1cGdyYWRlJ2AgZXZlbnQsIG5vIGVhcmx5IGV4aXQgaXNcbiAgICAgIC8vIHRyaWdnZXJlZCBoZXJlIGlmIHRoZSB1c2VyIGNhbGxzIGB3ZWJzb2NrZXQuY2xvc2UoKWAgb3JcbiAgICAgIC8vIGB3ZWJzb2NrZXQudGVybWluYXRlKClgIGZyb20gYSBsaXN0ZW5lciBvZiB0aGUgYCdyZWRpcmVjdCdgIGV2ZW50LiBUaGlzXG4gICAgICAvLyBpcyBiZWNhdXNlIHRoZSB1c2VyIGNhbiBhbHNvIGNhbGwgYHJlcXVlc3QuZGVzdHJveSgpYCB3aXRoIGFuIGVycm9yXG4gICAgICAvLyBiZWZvcmUgY2FsbGluZyBgd2Vic29ja2V0LmNsb3NlKClgIG9yIGB3ZWJzb2NrZXQudGVybWluYXRlKClgIGFuZCB0aGlzXG4gICAgICAvLyB3b3VsZCByZXN1bHQgaW4gYW4gZXJyb3IgYmVpbmcgZW1pdHRlZCBvbiB0aGUgYHJlcXVlc3RgIG9iamVjdCB3aXRoIG5vXG4gICAgICAvLyBgJ2Vycm9yJ2AgZXZlbnQgbGlzdGVuZXJzIGF0dGFjaGVkLlxuICAgICAgLy9cbiAgICAgIHdlYnNvY2tldC5lbWl0KCdyZWRpcmVjdCcsIHdlYnNvY2tldC51cmwsIHJlcSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gcmVxdWVzdChvcHRzKTtcbiAgfVxuXG4gIGlmIChvcHRzLnRpbWVvdXQpIHtcbiAgICByZXEub24oJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHJlcSwgJ09wZW5pbmcgaGFuZHNoYWtlIGhhcyB0aW1lZCBvdXQnKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlcS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgaWYgKHJlcSA9PT0gbnVsbCB8fCByZXFba0Fib3J0ZWRdKSByZXR1cm47XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XG4gICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICB9KTtcblxuICByZXEub24oJ3Jlc3BvbnNlJywgKHJlcykgPT4ge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzLmhlYWRlcnMubG9jYXRpb247XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXNDb2RlO1xuXG4gICAgaWYgKFxuICAgICAgbG9jYXRpb24gJiZcbiAgICAgIG9wdHMuZm9sbG93UmVkaXJlY3RzICYmXG4gICAgICBzdGF0dXNDb2RlID49IDMwMCAmJlxuICAgICAgc3RhdHVzQ29kZSA8IDQwMFxuICAgICkge1xuICAgICAgaWYgKCsrd2Vic29ja2V0Ll9yZWRpcmVjdHMgPiBvcHRzLm1heFJlZGlyZWN0cykge1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHJlcSwgJ01heGltdW0gcmVkaXJlY3RzIGV4Y2VlZGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVxLmFib3J0KCk7XG5cbiAgICAgIGxldCBhZGRyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhZGRyID0gbmV3IFVSTChsb2NhdGlvbiwgYWRkcmVzcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBVUkw6ICR7bG9jYXRpb259YCk7XG4gICAgICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoIXdlYnNvY2tldC5lbWl0KCd1bmV4cGVjdGVkLXJlc3BvbnNlJywgcmVxLCByZXMpKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZShcbiAgICAgICAgd2Vic29ja2V0LFxuICAgICAgICByZXEsXG4gICAgICAgIGBVbmV4cGVjdGVkIHNlcnZlciByZXNwb25zZTogJHtyZXMuc3RhdHVzQ29kZX1gXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmVxLm9uKCd1cGdyYWRlJywgKHJlcywgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgd2Vic29ja2V0LmVtaXQoJ3VwZ3JhZGUnLCByZXMpO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgdXNlciBtYXkgaGF2ZSBjbG9zZWQgdGhlIGNvbm5lY3Rpb24gZnJvbSBhIGxpc3RlbmVyIG9mIHRoZVxuICAgIC8vIGAndXBncmFkZSdgIGV2ZW50LlxuICAgIC8vXG4gICAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuQ09OTkVDVElORykgcmV0dXJuO1xuXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSBudWxsO1xuXG4gICAgY29uc3QgdXBncmFkZSA9IHJlcy5oZWFkZXJzLnVwZ3JhZGU7XG5cbiAgICBpZiAodXBncmFkZSA9PT0gdW5kZWZpbmVkIHx8IHVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCAnSW52YWxpZCBVcGdyYWRlIGhlYWRlcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgLnVwZGF0ZShrZXkgKyBHVUlEKVxuICAgICAgLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgICBpZiAocmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtYWNjZXB0J10gIT09IGRpZ2VzdCkge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcnZlclByb3QgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIGxldCBwcm90RXJyb3I7XG5cbiAgICBpZiAoc2VydmVyUHJvdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXByb3RvY29sU2V0LnNpemUpIHtcbiAgICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IGEgc3VicHJvdG9jb2wgYnV0IG5vbmUgd2FzIHJlcXVlc3RlZCc7XG4gICAgICB9IGVsc2UgaWYgKCFwcm90b2NvbFNldC5oYXMoc2VydmVyUHJvdCkpIHtcbiAgICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IGFuIGludmFsaWQgc3VicHJvdG9jb2wnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvdG9jb2xTZXQuc2l6ZSkge1xuICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IG5vIHN1YnByb3RvY29sJztcbiAgICB9XG5cbiAgICBpZiAocHJvdEVycm9yKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgcHJvdEVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VydmVyUHJvdCkgd2Vic29ja2V0Ll9wcm90b2NvbCA9IHNlcnZlclByb3Q7XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuXG4gICAgaWYgKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCFwZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAnU2VydmVyIHNlbnQgYSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyIGJ1dCBubyBleHRlbnNpb24gJyArXG4gICAgICAgICAgJ3dhcyByZXF1ZXN0ZWQnO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGV4dGVuc2lvbnM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGV4dGVuc2lvbnMgPSBwYXJzZShzZWNXZWJTb2NrZXRFeHRlbnNpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBleHRlbnNpb25OYW1lcyA9IE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGV4dGVuc2lvbk5hbWVzLmxlbmd0aCAhPT0gMSB8fFxuICAgICAgICBleHRlbnNpb25OYW1lc1swXSAhPT0gUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnU2VydmVyIGluZGljYXRlZCBhbiBleHRlbnNpb24gdGhhdCB3YXMgbm90IHJlcXVlc3RlZCc7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXInO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2Vic29ja2V0Ll9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID1cbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgfVxuXG4gICAgd2Vic29ja2V0LnNldFNvY2tldChzb2NrZXQsIGhlYWQsIHtcbiAgICAgIGFsbG93U3luY2hyb25vdXNFdmVudHM6IG9wdHMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyxcbiAgICAgIGdlbmVyYXRlTWFzazogb3B0cy5nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXhQYXlsb2FkOiBvcHRzLm1heFBheWxvYWQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IG9wdHMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG4gIH0pO1xuXG4gIGlmIChvcHRzLmZpbmlzaFJlcXVlc3QpIHtcbiAgICBvcHRzLmZpbmlzaFJlcXVlc3QocmVxLCB3ZWJzb2NrZXQpO1xuICB9IGVsc2Uge1xuICAgIHJlcS5lbmQoKTtcbiAgfVxufVxuXG4vKipcbiAqIEVtaXQgdGhlIGAnZXJyb3InYCBhbmQgYCdjbG9zZSdgIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RXJyb3J9IFRoZSBlcnJvciB0byBlbWl0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycikge1xuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBhc3NpZ25tZW50IGlzIHByYWN0aWNhbGx5IHVzZWxlc3MgYW5kIGlzIGRvbmUgb25seSBmb3JcbiAgLy8gY29uc2lzdGVuY3kuXG4gIC8vXG4gIHdlYnNvY2tldC5fZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgd2Vic29ja2V0LmVtaXRDbG9zZSgpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGBuZXQuU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHJldHVybiB7bmV0LlNvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5ldENvbm5lY3Qob3B0aW9ucykge1xuICBvcHRpb25zLnBhdGggPSBvcHRpb25zLnNvY2tldFBhdGg7XG4gIHJldHVybiBuZXQuY29ubmVjdChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgdGxzLlRMU1NvY2tldGAgYW5kIGluaXRpYXRlIGEgY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm4ge3Rscy5UTFNTb2NrZXR9IFRoZSBuZXdseSBjcmVhdGVkIHNvY2tldCB1c2VkIHRvIHN0YXJ0IHRoZSBjb25uZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0bHNDb25uZWN0KG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5wYXRoID0gdW5kZWZpbmVkO1xuXG4gIGlmICghb3B0aW9ucy5zZXJ2ZXJuYW1lICYmIG9wdGlvbnMuc2VydmVybmFtZSAhPT0gJycpIHtcbiAgICBvcHRpb25zLnNlcnZlcm5hbWUgPSBuZXQuaXNJUChvcHRpb25zLmhvc3QpID8gJycgOiBvcHRpb25zLmhvc3Q7XG4gIH1cblxuICByZXR1cm4gdGxzLmNvbm5lY3Qob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQWJvcnQgdGhlIGhhbmRzaGFrZSBhbmQgZW1pdCBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7KGh0dHAuQ2xpZW50UmVxdWVzdHxuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzdHJlYW0gVGhlIHJlcXVlc3QgdG9cbiAqICAgICBhYm9ydCBvciB0aGUgc29ja2V0IHRvIGRlc3Ryb3lcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHN0cmVhbSwgbWVzc2FnZSkge1xuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcblxuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgYWJvcnRIYW5kc2hha2UpO1xuXG4gIGlmIChzdHJlYW0uc2V0SGVhZGVyKSB7XG4gICAgc3RyZWFtW2tBYm9ydGVkXSA9IHRydWU7XG4gICAgc3RyZWFtLmFib3J0KCk7XG5cbiAgICBpZiAoc3RyZWFtLnNvY2tldCAmJiAhc3RyZWFtLnNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgIC8vXG4gICAgICAvLyBPbiBOb2RlLmpzID49IDE0LjMuMCBgcmVxdWVzdC5hYm9ydCgpYCBkb2VzIG5vdCBkZXN0cm95IHRoZSBzb2NrZXQgaWZcbiAgICAgIC8vIGNhbGxlZCBhZnRlciB0aGUgcmVxdWVzdCBjb21wbGV0ZWQuIFNlZVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzE4NjkuXG4gICAgICAvL1xuICAgICAgc3RyZWFtLnNvY2tldC5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZSwgd2Vic29ja2V0LCBlcnIpO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5kZXN0cm95KGVycik7XG4gICAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgd2Vic29ja2V0LmVtaXQuYmluZCh3ZWJzb2NrZXQsICdlcnJvcicpKTtcbiAgICBzdHJlYW0ub25jZSgnY2xvc2UnLCB3ZWJzb2NrZXQuZW1pdENsb3NlLmJpbmQod2Vic29ja2V0KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgY2FzZXMgd2hlcmUgdGhlIGBwaW5nKClgLCBgcG9uZygpYCwgb3IgYHNlbmQoKWAgbWV0aG9kcyBhcmUgY2FsbGVkXG4gKiB3aGVuIHRoZSBgcmVhZHlTdGF0ZWAgYXR0cmlidXRlIGlzIGBDTE9TSU5HYCBvciBgQ0xPU0VEYC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNlbmRBZnRlckNsb3NlKHdlYnNvY2tldCwgZGF0YSwgY2IpIHtcbiAgaWYgKGRhdGEpIHtcbiAgICBjb25zdCBsZW5ndGggPSBpc0Jsb2IoZGF0YSkgPyBkYXRhLnNpemUgOiB0b0J1ZmZlcihkYXRhKS5sZW5ndGg7XG5cbiAgICAvL1xuICAgIC8vIFRoZSBgX2J1ZmZlcmVkQW1vdW50YCBwcm9wZXJ0eSBpcyB1c2VkIG9ubHkgd2hlbiB0aGUgcGVlciBpcyBhIGNsaWVudCBhbmRcbiAgICAvLyB0aGUgb3BlbmluZyBoYW5kc2hha2UgZmFpbHMuIFVuZGVyIHRoZXNlIGNpcmN1bXN0YW5jZXMsIGluIGZhY3QsIHRoZVxuICAgIC8vIGBzZXRTb2NrZXQoKWAgbWV0aG9kIGlzIG5vdCBjYWxsZWQsIHNvIHRoZSBgX3NvY2tldGAgYW5kIGBfc2VuZGVyYFxuICAgIC8vIHByb3BlcnRpZXMgYXJlIHNldCB0byBgbnVsbGAuXG4gICAgLy9cbiAgICBpZiAod2Vic29ja2V0Ll9zb2NrZXQpIHdlYnNvY2tldC5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzICs9IGxlbmd0aDtcbiAgICBlbHNlIHdlYnNvY2tldC5fYnVmZmVyZWRBbW91bnQgKz0gbGVuZ3RoO1xuICB9XG5cbiAgaWYgKGNiKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgYFdlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAke3dlYnNvY2tldC5yZWFkeVN0YXRlfSBgICtcbiAgICAgICAgYCgke3JlYWR5U3RhdGVzW3dlYnNvY2tldC5yZWFkeVN0YXRlXX0pYFxuICAgICk7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2NvbmNsdWRlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcmVhc29uIFRoZSByZWFzb24gZm9yIGNsb3NpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25Db25jbHVkZShjb2RlLCByZWFzb24pIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IHRydWU7XG4gIHdlYnNvY2tldC5fY2xvc2VNZXNzYWdlID0gcmVhc29uO1xuICB3ZWJzb2NrZXQuX2Nsb3NlQ29kZSA9IGNvZGU7XG5cbiAgaWYgKHdlYnNvY2tldC5fc29ja2V0W2tXZWJTb2NrZXRdID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XG5cbiAgaWYgKGNvZGUgPT09IDEwMDUpIHdlYnNvY2tldC5jbG9zZSgpO1xuICBlbHNlIHdlYnNvY2tldC5jbG9zZShjb2RlLCByZWFzb24pO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2RyYWluJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkRyYWluKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICghd2Vic29ja2V0LmlzUGF1c2VkKSB3ZWJzb2NrZXQuX3NvY2tldC5yZXN1bWUoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFJhbmdlRXJyb3J8RXJyb3IpfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25FcnJvcihlcnIpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICBpZiAod2Vic29ja2V0Ll9zb2NrZXRba1dlYlNvY2tldF0gIT09IHVuZGVmaW5lZCkge1xuICAgIHdlYnNvY2tldC5fc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcblxuICAgIC8vXG4gICAgLy8gT24gTm9kZS5qcyA8IDE0LjAuMCB0aGUgYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQgc3luY2hyb25vdXNseS4gU2VlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzE5NDAuXG4gICAgLy9cbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZSwgd2Vic29ja2V0Ll9zb2NrZXQpO1xuXG4gICAgd2Vic29ja2V0LmNsb3NlKGVycltrU3RhdHVzQ29kZV0pO1xuICB9XG5cbiAgaWYgKCF3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCkge1xuICAgIHdlYnNvY2tldC5fZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZmluaXNoJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkZpbmlzaCgpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0Q2xvc2UoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdtZXNzYWdlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXlCdWZmZXJ8QnVmZmVyW10pfSBkYXRhIFRoZSBtZXNzYWdlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmluYXJ5IFNwZWNpZmllcyB3aGV0aGVyIHRoZSBtZXNzYWdlIGlzIGJpbmFyeSBvciBub3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25NZXNzYWdlKGRhdGEsIGlzQmluYXJ5KSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdCgnbWVzc2FnZScsIGRhdGEsIGlzQmluYXJ5KTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdwaW5nJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhlIHBpbmcgZnJhbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25QaW5nKGRhdGEpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICBpZiAod2Vic29ja2V0Ll9hdXRvUG9uZykgd2Vic29ja2V0LnBvbmcoZGF0YSwgIXRoaXMuX2lzU2VydmVyLCBOT09QKTtcbiAgd2Vic29ja2V0LmVtaXQoJ3BpbmcnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdwb25nJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhlIHBvbmcgZnJhbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25Qb25nKGRhdGEpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdwb25nJywgZGF0YSk7XG59XG5cbi8qKlxuICogUmVzdW1lIGEgcmVhZGFibGUgc3RyZWFtXG4gKlxuICogQHBhcmFtIHtSZWFkYWJsZX0gc3RyZWFtIFRoZSByZWFkYWJsZSBzdHJlYW1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0pIHtcbiAgc3RyZWFtLnJlc3VtZSgpO1xufVxuXG4vKipcbiAqIFRoZSBgU2VuZGVyYCBlcnJvciBldmVudCBoYW5kbGVyLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IFRoZSBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2VuZGVyT25FcnJvcihlcnIpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICBpZiAod2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHNldENsb3NlVGltZXIod2Vic29ja2V0KTtcbiAgfVxuXG4gIC8vXG4gIC8vIGBzb2NrZXQuZW5kKClgIGlzIHVzZWQgaW5zdGVhZCBvZiBgc29ja2V0LmRlc3Ryb3koKWAgdG8gYWxsb3cgdGhlIG90aGVyXG4gIC8vIHBlZXIgdG8gZmluaXNoIHNlbmRpbmcgcXVldWVkIGRhdGEuIFRoZXJlIGlzIG5vIG5lZWQgdG8gc2V0IGEgdGltZXIgaGVyZVxuICAvLyBiZWNhdXNlIGBDTE9TSU5HYCBtZWFucyB0aGF0IGl0IGlzIGFscmVhZHkgc2V0IG9yIG5vdCBuZWVkZWQuXG4gIC8vXG4gIHRoaXMuX3NvY2tldC5lbmQoKTtcblxuICBpZiAoIXdlYnNvY2tldC5fZXJyb3JFbWl0dGVkKSB7XG4gICAgd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgYSB0aW1lciB0byBkZXN0cm95IHRoZSB1bmRlcmx5aW5nIHJhdyBzb2NrZXQgb2YgYSBXZWJTb2NrZXQuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRDbG9zZVRpbWVyKHdlYnNvY2tldCkge1xuICB3ZWJzb2NrZXQuX2Nsb3NlVGltZXIgPSBzZXRUaW1lb3V0KFxuICAgIHdlYnNvY2tldC5fc29ja2V0LmRlc3Ryb3kuYmluZCh3ZWJzb2NrZXQuX3NvY2tldCksXG4gICAgY2xvc2VUaW1lb3V0XG4gICk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdjbG9zZSdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uQ2xvc2UoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHNvY2tldE9uRW5kKTtcblxuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcblxuICBsZXQgY2h1bms7XG5cbiAgLy9cbiAgLy8gVGhlIGNsb3NlIGZyYW1lIG1pZ2h0IG5vdCBoYXZlIGJlZW4gcmVjZWl2ZWQgb3IgdGhlIGAnZW5kJ2AgZXZlbnQgZW1pdHRlZCxcbiAgLy8gZm9yIGV4YW1wbGUsIGlmIHRoZSBzb2NrZXQgd2FzIGRlc3Ryb3llZCBkdWUgdG8gYW4gZXJyb3IuIEVuc3VyZSB0aGF0IHRoZVxuICAvLyBgcmVjZWl2ZXJgIHN0cmVhbSBpcyBjbG9zZWQgYWZ0ZXIgd3JpdGluZyBhbnkgcmVtYWluaW5nIGJ1ZmZlcmVkIGRhdGEgdG9cbiAgLy8gaXQuIElmIHRoZSByZWFkYWJsZSBzaWRlIG9mIHRoZSBzb2NrZXQgaXMgaW4gZmxvd2luZyBtb2RlIHRoZW4gdGhlcmUgaXMgbm9cbiAgLy8gYnVmZmVyZWQgZGF0YSBhcyBldmVyeXRoaW5nIGhhcyBiZWVuIGFscmVhZHkgd3JpdHRlbiBhbmQgYHJlYWRhYmxlLnJlYWQoKWBcbiAgLy8gd2lsbCByZXR1cm4gYG51bGxgLiBJZiBpbnN0ZWFkLCB0aGUgc29ja2V0IGlzIHBhdXNlZCwgYW55IHBvc3NpYmxlIGJ1ZmZlcmVkXG4gIC8vIGRhdGEgd2lsbCBiZSByZWFkIGFzIGEgc2luZ2xlIGNodW5rLlxuICAvL1xuICBpZiAoXG4gICAgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCAmJlxuICAgICF3ZWJzb2NrZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCAmJlxuICAgICF3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCAmJlxuICAgIChjaHVuayA9IHdlYnNvY2tldC5fc29ja2V0LnJlYWQoKSkgIT09IG51bGxcbiAgKSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci53cml0ZShjaHVuayk7XG4gIH1cblxuICB3ZWJzb2NrZXQuX3JlY2VpdmVyLmVuZCgpO1xuXG4gIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG5cbiAgY2xlYXJUaW1lb3V0KHdlYnNvY2tldC5fY2xvc2VUaW1lcik7XG5cbiAgaWYgKFxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgfHxcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxuICApIHtcbiAgICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZXJyb3InLCByZWNlaXZlck9uRmluaXNoKTtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdmaW5pc2gnLCByZWNlaXZlck9uRmluaXNoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgc29ja2V0IGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRGF0YShjaHVuaykge1xuICBpZiAoIXRoaXNba1dlYlNvY2tldF0uX3JlY2VpdmVyLndyaXRlKGNodW5rKSkge1xuICAgIHRoaXMucGF1c2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgc29ja2V0IGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FbmQoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG4gIHRoaXMuZW5kKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcbiAgdGhpcy5vbignZXJyb3InLCBOT09QKTtcblxuICBpZiAod2Vic29ja2V0KSB7XG4gICAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRHVwbGV4IH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuLyoqXG4gKiBFbWl0cyB0aGUgYCdjbG9zZSdgIGV2ZW50IG9uIGEgc3RyZWFtLlxuICpcbiAqIEBwYXJhbSB7RHVwbGV4fSBzdHJlYW0gVGhlIHN0cmVhbS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVtaXRDbG9zZShzdHJlYW0pIHtcbiAgc3RyZWFtLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2VuZCdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGR1cGxleE9uRW5kKCkge1xuICBpZiAoIXRoaXMuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQpIHtcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGR1cGxleE9uRXJyb3IoZXJyKSB7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZHVwbGV4T25FcnJvcik7XG4gIHRoaXMuZGVzdHJveSgpO1xuICBpZiAodGhpcy5saXN0ZW5lckNvdW50KCdlcnJvcicpID09PSAwKSB7XG4gICAgLy8gRG8gbm90IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvci5cbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIFdyYXBzIGEgYFdlYlNvY2tldGAgaW4gYSBkdXBsZXggc3RyZWFtLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3cyBUaGUgYFdlYlNvY2tldGAgdG8gd3JhcFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBmb3IgdGhlIGBEdXBsZXhgIGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJuIHtEdXBsZXh9IFRoZSBkdXBsZXggc3RyZWFtXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVdlYlNvY2tldFN0cmVhbSh3cywgb3B0aW9ucykge1xuICBsZXQgdGVybWluYXRlT25EZXN0cm95ID0gdHJ1ZTtcblxuICBjb25zdCBkdXBsZXggPSBuZXcgRHVwbGV4KHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGF1dG9EZXN0cm95OiBmYWxzZSxcbiAgICBlbWl0Q2xvc2U6IGZhbHNlLFxuICAgIG9iamVjdE1vZGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlT2JqZWN0TW9kZTogZmFsc2VcbiAgfSk7XG5cbiAgd3Mub24oJ21lc3NhZ2UnLCBmdW5jdGlvbiBtZXNzYWdlKG1zZywgaXNCaW5hcnkpIHtcbiAgICBjb25zdCBkYXRhID1cbiAgICAgICFpc0JpbmFyeSAmJiBkdXBsZXguX3JlYWRhYmxlU3RhdGUub2JqZWN0TW9kZSA/IG1zZy50b1N0cmluZygpIDogbXNnO1xuXG4gICAgaWYgKCFkdXBsZXgucHVzaChkYXRhKSkgd3MucGF1c2UoKTtcbiAgfSk7XG5cbiAgd3Mub25jZSgnZXJyb3InLCBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICBpZiAoZHVwbGV4LmRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgLy8gUHJldmVudCBgd3MudGVybWluYXRlKClgIGZyb20gYmVpbmcgY2FsbGVkIGJ5IGBkdXBsZXguX2Rlc3Ryb3koKWAuXG4gICAgLy9cbiAgICAvLyAtIElmIHRoZSBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCBiZWZvcmUgdGhlIGAnb3BlbidgIGV2ZW50LCB0aGVuXG4gICAgLy8gICBgd3MudGVybWluYXRlKClgIGlzIGEgbm9vcCBhcyBubyBzb2NrZXQgaXMgYXNzaWduZWQuXG4gICAgLy8gLSBPdGhlcndpc2UsIHRoZSBlcnJvciBpcyByZS1lbWl0dGVkIGJ5IHRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlcnJvcidgXG4gICAgLy8gICBldmVudCBvZiB0aGUgYFJlY2VpdmVyYCBvYmplY3QuIFRoZSBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlcyB0aGVcbiAgICAvLyAgIGNvbm5lY3Rpb24gYnkgY2FsbGluZyBgd3MuY2xvc2UoKWAuIFRoaXMgYWxsb3dzIGEgY2xvc2UgZnJhbWUgdG8gYmVcbiAgICAvLyAgIHNlbnQgdG8gdGhlIG90aGVyIHBlZXIuIElmIGB3cy50ZXJtaW5hdGUoKWAgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIHRoaXMsXG4gICAgLy8gICB0aGVuIHRoZSBjbG9zZSBmcmFtZSBtaWdodCBub3QgYmUgc2VudC5cbiAgICB0ZXJtaW5hdGVPbkRlc3Ryb3kgPSBmYWxzZTtcbiAgICBkdXBsZXguZGVzdHJveShlcnIpO1xuICB9KTtcblxuICB3cy5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmIChkdXBsZXguZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICBkdXBsZXgucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgZHVwbGV4Ll9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ0xPU0VEKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIGR1cGxleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuXG4gICAgd3Mub25jZSgnZXJyb3InLCBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuXG4gICAgd3Mub25jZSgnY2xvc2UnLCBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIGlmICghY2FsbGVkKSBjYWxsYmFjayhlcnIpO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIGR1cGxleCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGVybWluYXRlT25EZXN0cm95KSB3cy50ZXJtaW5hdGUoKTtcbiAgfTtcblxuICBkdXBsZXguX2ZpbmFsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcbiAgICAgIHdzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBkdXBsZXguX2ZpbmFsKGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgYF9zb2NrZXRgIHByb3BlcnR5IGlzIGBudWxsYCBpdCBtZWFucyB0aGF0IGB3c2AgaXMgYVxuICAgIC8vIGNsaWVudCB3ZWJzb2NrZXQgYW5kIHRoZSBoYW5kc2hha2UgZmFpbGVkLiBJbiBmYWN0LCB3aGVuIHRoaXMgaGFwcGVucywgYVxuICAgIC8vIHNvY2tldCBpcyBuZXZlciBhc3NpZ25lZCB0byB0aGUgd2Vic29ja2V0LiBXYWl0IGZvciB0aGUgYCdlcnJvcidgIGV2ZW50XG4gICAgLy8gdGhhdCB3aWxsIGJlIGVtaXR0ZWQgYnkgdGhlIHdlYnNvY2tldC5cbiAgICBpZiAod3MuX3NvY2tldCA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgaWYgKHdzLl9zb2NrZXQuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICBpZiAoZHVwbGV4Ll9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIGR1cGxleC5kZXN0cm95KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdzLl9zb2NrZXQub25jZSgnZmluaXNoJywgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgICAvLyBgZHVwbGV4YCBpcyBub3QgZGVzdHJveWVkIGhlcmUgYmVjYXVzZSB0aGUgYCdlbmQnYCBldmVudCB3aWxsIGJlXG4gICAgICAgIC8vIGVtaXR0ZWQgb24gYGR1cGxleGAgYWZ0ZXIgdGhpcyBgJ2ZpbmlzaCdgIGV2ZW50LiBUaGUgRU9GIHNpZ25hbGluZ1xuICAgICAgICAvLyBgbnVsbGAgY2h1bmsgaXMsIGluIGZhY3QsIHB1c2hlZCB3aGVuIHRoZSB3ZWJzb2NrZXQgZW1pdHMgYCdjbG9zZSdgLlxuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgICB3cy5jbG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICBkdXBsZXguX3JlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHdzLmlzUGF1c2VkKSB3cy5yZXN1bWUoKTtcbiAgfTtcblxuICBkdXBsZXguX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ09OTkVDVElORykge1xuICAgICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIGR1cGxleC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3cy5zZW5kKGNodW5rLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgZHVwbGV4Lm9uKCdlbmQnLCBkdXBsZXhPbkVuZCk7XG4gIGR1cGxleC5vbignZXJyb3InLCBkdXBsZXhPbkVycm9yKTtcbiAgcmV0dXJuIGR1cGxleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVXZWJTb2NrZXRTdHJlYW07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IHRva2VuQ2hhcnMgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgIGhlYWRlciBpbnRvIGEgc2V0IG9mIHN1YnByb3RvY29sIG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge1NldH0gVGhlIHN1YnByb3RvY29sIG5hbWVzXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKGhlYWRlcikge1xuICBjb25zdCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKGk7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGkgIT09IDAgJiZcbiAgICAgIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5KSAvKiAnXFx0JyAqL1xuICAgICkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcbiAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuXG4gICAgICBjb25zdCBwcm90b2NvbCA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcblxuICAgICAgaWYgKHByb3RvY29scy5oYXMocHJvdG9jb2wpKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvY29scy5hZGQocHJvdG9jb2wpO1xuICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgIT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG5cbiAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuXG4gIGlmIChwcm90b2NvbHMuaGFzKHByb3RvY29sKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gIH1cblxuICBwcm90b2NvbHMuYWRkKHByb3RvY29sKTtcbiAgcmV0dXJuIHByb3RvY29scztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IHBhcnNlIH07XG4iLCAiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeRHVwbGV4JFwiLCBcImNhdWdodEVycm9yc1wiOiBcIm5vbmVcIiB9XSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IHsgRHVwbGV4IH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IGV4dGVuc2lvbiA9IHJlcXVpcmUoJy4vZXh0ZW5zaW9uJyk7XG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBzdWJwcm90b2NvbCA9IHJlcXVpcmUoJy4vc3VicHJvdG9jb2wnKTtcbmNvbnN0IFdlYlNvY2tldCA9IHJlcXVpcmUoJy4vd2Vic29ja2V0Jyk7XG5jb25zdCB7IEdVSUQsIGtXZWJTb2NrZXQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IGtleVJlZ2V4ID0gL15bKy8wLTlBLVphLXpdezIyfT09JC87XG5cbmNvbnN0IFJVTk5JTkcgPSAwO1xuY29uc3QgQ0xPU0lORyA9IDE7XG5jb25zdCBDTE9TRUQgPSAyO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldCBzZXJ2ZXIuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldFNlcnZlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBgV2ViU29ja2V0U2VydmVyYCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz10cnVlXSBTcGVjaWZpZXMgd2hldGhlclxuICAgKiAgICAgYW55IG9mIHRoZSBgJ21lc3NhZ2UnYCwgYCdwaW5nJ2AsIGFuZCBgJ3BvbmcnYCBldmVudHMgY2FuIGJlIGVtaXR0ZWRcbiAgICogICAgIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIHRpY2tcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvUG9uZz10cnVlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cbiAgICogICAgIGF1dG9tYXRpY2FsbHkgc2VuZCBhIHBvbmcgaW4gcmVzcG9uc2UgdG8gYSBwaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5iYWNrbG9nPTUxMV0gVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBxdWV1ZSBvZlxuICAgKiAgICAgcGVuZGluZyBjb25uZWN0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudFRyYWNraW5nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgdHJhY2sgY2xpZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5oYW5kbGVQcm90b2NvbHNdIEEgaG9vayB0byBoYW5kbGUgcHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ob3N0XSBUaGUgaG9zdG5hbWUgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTEwNDg1NzYwMF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlXG4gICAqICAgICBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubm9TZXJ2ZXI9ZmFsc2VdIEVuYWJsZSBubyBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGF0aF0gQWNjZXB0IG9ubHkgY29ubmVjdGlvbnMgbWF0Y2hpbmcgdGhpcyBwYXRoXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gW29wdGlvbnMucGVyTWVzc2FnZURlZmxhdGU9ZmFsc2VdIEVuYWJsZS9kaXNhYmxlXG4gICAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvcnRdIFRoZSBwb3J0IHdoZXJlIHRvIGJpbmQgdGhlIHNlcnZlclxuICAgKiBAcGFyYW0geyhodHRwLlNlcnZlcnxodHRwcy5TZXJ2ZXIpfSBbb3B0aW9ucy5zZXJ2ZXJdIEEgcHJlLWNyZWF0ZWQgSFRUUC9TXG4gICAqICAgICBzZXJ2ZXIgdG8gdXNlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudmVyaWZ5Q2xpZW50XSBBIGhvb2sgdG8gcmVqZWN0IGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLldlYlNvY2tldD1XZWJTb2NrZXRdIFNwZWNpZmllcyB0aGUgYFdlYlNvY2tldGBcbiAgICogICAgIGNsYXNzIHRvIHVzZS4gSXQgbXVzdCBiZSB0aGUgYFdlYlNvY2tldGAgY2xhc3Mgb3IgY2xhc3MgdGhhdCBleHRlbmRzIGl0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQSBsaXN0ZW5lciBmb3IgdGhlIGBsaXN0ZW5pbmdgIGV2ZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogdHJ1ZSxcbiAgICAgIGF1dG9Qb25nOiB0cnVlLFxuICAgICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxuICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IGZhbHNlLFxuICAgICAgaGFuZGxlUHJvdG9jb2xzOiBudWxsLFxuICAgICAgY2xpZW50VHJhY2tpbmc6IHRydWUsXG4gICAgICB2ZXJpZnlDbGllbnQ6IG51bGwsXG4gICAgICBub1NlcnZlcjogZmFsc2UsXG4gICAgICBiYWNrbG9nOiBudWxsLCAvLyB1c2UgZGVmYXVsdCAoNTExIGFzIGltcGxlbWVudGVkIGluIG5ldC5qcylcbiAgICAgIHNlcnZlcjogbnVsbCxcbiAgICAgIGhvc3Q6IG51bGwsXG4gICAgICBwYXRoOiBudWxsLFxuICAgICAgcG9ydDogbnVsbCxcbiAgICAgIFdlYlNvY2tldCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKFxuICAgICAgKG9wdGlvbnMucG9ydCA9PSBudWxsICYmICFvcHRpb25zLnNlcnZlciAmJiAhb3B0aW9ucy5ub1NlcnZlcikgfHxcbiAgICAgIChvcHRpb25zLnBvcnQgIT0gbnVsbCAmJiAob3B0aW9ucy5zZXJ2ZXIgfHwgb3B0aW9ucy5ub1NlcnZlcikpIHx8XG4gICAgICAob3B0aW9ucy5zZXJ2ZXIgJiYgb3B0aW9ucy5ub1NlcnZlcilcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdPbmUgYW5kIG9ubHkgb25lIG9mIHRoZSBcInBvcnRcIiwgXCJzZXJ2ZXJcIiwgb3IgXCJub1NlcnZlclwiIG9wdGlvbnMgJyArXG4gICAgICAgICAgJ211c3QgYmUgc3BlY2lmaWVkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKChyZXEsIHJlcykgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID0gaHR0cC5TVEFUVVNfQ09ERVNbNDI2XTtcblxuICAgICAgICByZXMud3JpdGVIZWFkKDQyNiwge1xuICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IGJvZHkubGVuZ3RoLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9wbGFpbidcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcy5lbmQoYm9keSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NlcnZlci5saXN0ZW4oXG4gICAgICAgIG9wdGlvbnMucG9ydCxcbiAgICAgICAgb3B0aW9ucy5ob3N0LFxuICAgICAgICBvcHRpb25zLmJhY2tsb2csXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgIGNvbnN0IGVtaXRDb25uZWN0aW9uID0gdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Nvbm5lY3Rpb24nKTtcblxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gYWRkTGlzdGVuZXJzKHRoaXMuX3NlcnZlciwge1xuICAgICAgICBsaXN0ZW5pbmc6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdsaXN0ZW5pbmcnKSxcbiAgICAgICAgZXJyb3I6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdlcnJvcicpLFxuICAgICAgICB1cGdyYWRlOiAocmVxLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsIGVtaXRDb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPT09IHRydWUpIG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5jbGllbnRUcmFja2luZykge1xuICAgICAgdGhpcy5jbGllbnRzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5fc2hvdWxkRW1pdENsb3NlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9zdGF0ZSA9IFJVTk5JTkc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmQgYWRkcmVzcywgdGhlIGFkZHJlc3MgZmFtaWx5IG5hbWUsIGFuZCBwb3J0IG9mIHRoZSBzZXJ2ZXJcbiAgICogYXMgcmVwb3J0ZWQgYnkgdGhlIG9wZXJhdGluZyBzeXN0ZW0gaWYgbGlzdGVuaW5nIG9uIGFuIElQIHNvY2tldC5cbiAgICogSWYgdGhlIHNlcnZlciBpcyBsaXN0ZW5pbmcgb24gYSBwaXBlIG9yIFVOSVggZG9tYWluIHNvY2tldCwgdGhlIG5hbWUgaXNcbiAgICogcmV0dXJuZWQgYXMgYSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4geyhPYmplY3R8U3RyaW5nfG51bGwpfSBUaGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG9wZXJhdGluZyBpbiBcIm5vU2VydmVyXCIgbW9kZScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fc2VydmVyKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5fc2VydmVyLmFkZHJlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHRoZSBzZXJ2ZXIgZnJvbSBhY2NlcHRpbmcgbmV3IGNvbm5lY3Rpb25zIGFuZCBlbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcbiAgICogd2hlbiBhbGwgZXhpc3RpbmcgY29ubmVjdGlvbnMgYXJlIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBBIG9uZS10aW1lIGxpc3RlbmVyIGZvciB0aGUgYCdjbG9zZSdgIGV2ZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNiKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBDTE9TRUQpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgIGNiKG5ldyBFcnJvcignVGhlIHNlcnZlciBpcyBub3QgcnVubmluZycpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2IpIHRoaXMub25jZSgnY2xvc2UnLCBjYik7XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NJTkcpIHJldHVybjtcbiAgICB0aGlzLl9zdGF0ZSA9IENMT1NJTkc7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyIHx8IHRoaXMub3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNsaWVudHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudHMuc2l6ZSkge1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zaG91bGRFbWl0Q2xvc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNlcnZlciA9IHRoaXMuX3NlcnZlcjtcblxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xuXG4gICAgICAvL1xuICAgICAgLy8gVGhlIEhUVFAvUyBzZXJ2ZXIgd2FzIGNyZWF0ZWQgaW50ZXJuYWxseS4gQ2xvc2UgaXQsIGFuZCByZWx5IG9uIGl0c1xuICAgICAgLy8gYCdjbG9zZSdgIGV2ZW50LlxuICAgICAgLy9cbiAgICAgIHNlcnZlci5jbG9zZSgoKSA9PiB7XG4gICAgICAgIGVtaXRDbG9zZSh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZWUgaWYgYSBnaXZlbiByZXF1ZXN0IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoaXMgc2VydmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgUmVxdWVzdCBvYmplY3QgdG8gaW5zcGVjdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHJlcXVlc3QgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzaG91bGRIYW5kbGUocmVxKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXRoKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHJlcS51cmwuaW5kZXhPZignPycpO1xuICAgICAgY29uc3QgcGF0aG5hbWUgPSBpbmRleCAhPT0gLTEgPyByZXEudXJsLnNsaWNlKDAsIGluZGV4KSA6IHJlcS51cmw7XG5cbiAgICAgIGlmIChwYXRobmFtZSAhPT0gdGhpcy5vcHRpb25zLnBhdGgpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBIVFRQIFVwZ3JhZGUgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICBjb25zdCBrZXkgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXTtcbiAgICBjb25zdCB1cGdyYWRlID0gcmVxLmhlYWRlcnMudXBncmFkZTtcbiAgICBjb25zdCB2ZXJzaW9uID0gK3JlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXZlcnNpb24nXTtcblxuICAgIGlmIChyZXEubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIEhUVFAgbWV0aG9kJztcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDA1LCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSA9PT0gdW5kZWZpbmVkIHx8IHVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBVcGdyYWRlIGhlYWRlcic7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8ICFrZXlSZWdleC50ZXN0KGtleSkpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTWlzc2luZyBvciBpbnZhbGlkIFNlYy1XZWJTb2NrZXQtS2V5IGhlYWRlcic7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHZlcnNpb24gIT09IDggJiYgdmVyc2lvbiAhPT0gMTMpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTWlzc2luZyBvciBpbnZhbGlkIFNlYy1XZWJTb2NrZXQtVmVyc2lvbiBoZWFkZXInO1xuICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zaG91bGRIYW5kbGUocmVxKSkge1xuICAgICAgYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldFByb3RvY29sID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXTtcbiAgICBsZXQgcHJvdG9jb2xzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHNlY1dlYlNvY2tldFByb3RvY29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHByb3RvY29scyA9IHN1YnByb3RvY29sLnBhcnNlKHNlY1dlYlNvY2tldFByb3RvY29sKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1Qcm90b2NvbCBoZWFkZXInO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB7fTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSAmJlxuICAgICAgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgICAgICB0cnVlLFxuICAgICAgICB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZFxuICAgICAgKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2ZmZXJzID0gZXh0ZW5zaW9uLnBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xuXG4gICAgICAgIGlmIChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQob2ZmZXJzW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgICAgICBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID0gcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAnSW52YWxpZCBvciB1bmFjY2VwdGFibGUgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gT3B0aW9uYWxseSBjYWxsIGV4dGVybmFsIGNsaWVudCB2ZXJpZmljYXRpb24gaGFuZGxlci5cbiAgICAvL1xuICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KSB7XG4gICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICBvcmlnaW46XG4gICAgICAgICAgcmVxLmhlYWRlcnNbYCR7dmVyc2lvbiA9PT0gOCA/ICdzZWMtd2Vic29ja2V0LW9yaWdpbicgOiAnb3JpZ2luJ31gXSxcbiAgICAgICAgc2VjdXJlOiAhIShyZXEuc29ja2V0LmF1dGhvcml6ZWQgfHwgcmVxLnNvY2tldC5lbmNyeXB0ZWQpLFxuICAgICAgICByZXFcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KGluZm8sICh2ZXJpZmllZCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykgPT4ge1xuICAgICAgICAgIGlmICghdmVyaWZpZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUgfHwgNDAxLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShcbiAgICAgICAgICAgIGV4dGVuc2lvbnMsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBwcm90b2NvbHMsXG4gICAgICAgICAgICByZXEsXG4gICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICBoZWFkLFxuICAgICAgICAgICAgY2JcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbykpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogVXBncmFkZSB0aGUgY29ubmVjdGlvbiB0byBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBhY2NlcHRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIHZhbHVlIG9mIHRoZSBgU2VjLVdlYlNvY2tldC1LZXlgIGhlYWRlclxuICAgKiBAcGFyYW0ge1NldH0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lIHNvY2tldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29tcGxldGVVcGdyYWRlKGV4dGVuc2lvbnMsIGtleSwgcHJvdG9jb2xzLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICAvL1xuICAgIC8vIERlc3Ryb3kgdGhlIHNvY2tldCBpZiB0aGUgY2xpZW50IGhhcyBhbHJlYWR5IHNlbnQgYSBGSU4gcGFja2V0LlxuICAgIC8vXG4gICAgaWYgKCFzb2NrZXQucmVhZGFibGUgfHwgIXNvY2tldC53cml0YWJsZSkgcmV0dXJuIHNvY2tldC5kZXN0cm95KCk7XG5cbiAgICBpZiAoc29ja2V0W2tXZWJTb2NrZXRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdzZXJ2ZXIuaGFuZGxlVXBncmFkZSgpIHdhcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugd2l0aCB0aGUgc2FtZSAnICtcbiAgICAgICAgICAnc29ja2V0LCBwb3NzaWJseSBkdWUgdG8gYSBtaXNjb25maWd1cmF0aW9uJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPiBSVU5OSU5HKSByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA1MDMpO1xuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGNvbnN0IGhlYWRlcnMgPSBbXG4gICAgICAnSFRUUC8xLjEgMTAxIFN3aXRjaGluZyBQcm90b2NvbHMnLFxuICAgICAgJ1VwZ3JhZGU6IHdlYnNvY2tldCcsXG4gICAgICAnQ29ubmVjdGlvbjogVXBncmFkZScsXG4gICAgICBgU2VjLVdlYlNvY2tldC1BY2NlcHQ6ICR7ZGlnZXN0fWBcbiAgICBdO1xuXG4gICAgY29uc3Qgd3MgPSBuZXcgdGhpcy5vcHRpb25zLldlYlNvY2tldChudWxsLCB1bmRlZmluZWQsIHRoaXMub3B0aW9ucyk7XG5cbiAgICBpZiAocHJvdG9jb2xzLnNpemUpIHtcbiAgICAgIC8vXG4gICAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgcHJvdG9jb2wgc2VsZWN0aW9uIGhhbmRsZXIuXG4gICAgICAvL1xuICAgICAgY29uc3QgcHJvdG9jb2wgPSB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzXG4gICAgICAgID8gdGhpcy5vcHRpb25zLmhhbmRsZVByb3RvY29scyhwcm90b2NvbHMsIHJlcSlcbiAgICAgICAgOiBwcm90b2NvbHMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuXG4gICAgICBpZiAocHJvdG9jb2wpIHtcbiAgICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LVByb3RvY29sOiAke3Byb3RvY29sfWApO1xuICAgICAgICB3cy5fcHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgY29uc3QgcGFyYW1zID0gZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXS5wYXJhbXM7XG4gICAgICBjb25zdCB2YWx1ZSA9IGV4dGVuc2lvbi5mb3JtYXQoe1xuICAgICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IFtwYXJhbXNdXG4gICAgICB9KTtcbiAgICAgIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zOiAke3ZhbHVlfWApO1xuICAgICAgd3MuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gQWxsb3cgZXh0ZXJuYWwgbW9kaWZpY2F0aW9uL2luc3BlY3Rpb24gb2YgaGFuZHNoYWtlIGhlYWRlcnMuXG4gICAgLy9cbiAgICB0aGlzLmVtaXQoJ2hlYWRlcnMnLCBoZWFkZXJzLCByZXEpO1xuXG4gICAgc29ja2V0LndyaXRlKGhlYWRlcnMuY29uY2F0KCdcXHJcXG4nKS5qb2luKCdcXHJcXG4nKSk7XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuXG4gICAgd3Muc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogdGhpcy5vcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHMsXG4gICAgICBtYXhQYXlsb2FkOiB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogdGhpcy5vcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvblxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgdGhpcy5jbGllbnRzLmFkZCh3cyk7XG4gICAgICB3cy5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xpZW50cy5kZWxldGUod3MpO1xuXG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRFbWl0Q2xvc2UgJiYgIXRoaXMuY2xpZW50cy5zaXplKSB7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjYih3cywgcmVxKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFNlcnZlcjtcblxuLyoqXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXJzIG9uIGFuIGBFdmVudEVtaXR0ZXJgIHVzaW5nIGEgbWFwIG9mIDxldmVudCwgbGlzdGVuZXI+XG4gKiBwYWlycy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBGdW5jdGlvbj59IG1hcCBUaGUgbGlzdGVuZXJzIHRvIGFkZFxuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlbW92ZSB0aGUgYWRkZWQgbGlzdGVuZXJzIHdoZW5cbiAqICAgICBjYWxsZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVycyhzZXJ2ZXIsIG1hcCkge1xuICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHNlcnZlci5vbihldmVudCwgbWFwW2V2ZW50XSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHtcbiAgICAgIHNlcnZlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgbWFwW2V2ZW50XSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEVtaXQgYSBgJ2Nsb3NlJ2AgZXZlbnQgb24gYW4gYEV2ZW50RW1pdHRlcmAuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHNlcnZlciBUaGUgZXZlbnQgZW1pdHRlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdENsb3NlKHNlcnZlcikge1xuICBzZXJ2ZXIuX3N0YXRlID0gQ0xPU0VEO1xuICBzZXJ2ZXIuZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgc29ja2V0IGVycm9ycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVycm9yKCkge1xuICB0aGlzLmRlc3Ryb3koKTtcbn1cblxuLyoqXG4gKiBDbG9zZSB0aGUgY29ubmVjdGlvbiB3aGVuIHByZWNvbmRpdGlvbnMgYXJlIG5vdCBmdWxmaWxsZWQuXG4gKlxuICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgc29ja2V0IG9mIHRoZSB1cGdyYWRlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIFRoZSBIVFRQIHJlc3BvbnNlIGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGVhZGVyc10gQWRkaXRpb25hbCBIVFRQIHJlc3BvbnNlIGhlYWRlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykge1xuICAvL1xuICAvLyBUaGUgc29ja2V0IGlzIHdyaXRhYmxlIHVubGVzcyB0aGUgdXNlciBkZXN0cm95ZWQgb3IgZW5kZWQgaXQgYmVmb3JlIGNhbGxpbmdcbiAgLy8gYHNlcnZlci5oYW5kbGVVcGdyYWRlKClgIG9yIGluIHRoZSBgdmVyaWZ5Q2xpZW50YCBmdW5jdGlvbiwgd2hpY2ggaXMgYSB1c2VyXG4gIC8vIGVycm9yLiBIYW5kbGluZyB0aGlzIGRvZXMgbm90IG1ha2UgbXVjaCBzZW5zZSBhcyB0aGUgd29yc3QgdGhhdCBjYW4gaGFwcGVuXG4gIC8vIGlzIHRoYXQgc29tZSBvZiB0aGUgZGF0YSB3cml0dGVuIGJ5IHRoZSB1c2VyIG1pZ2h0IGJlIGRpc2NhcmRlZCBkdWUgdG8gdGhlXG4gIC8vIGNhbGwgdG8gYHNvY2tldC5lbmQoKWAgYmVsb3csIHdoaWNoIHRyaWdnZXJzIGFuIGAnZXJyb3InYCBldmVudCB0aGF0IGluXG4gIC8vIHR1cm4gY2F1c2VzIHRoZSBzb2NrZXQgdG8gYmUgZGVzdHJveWVkLlxuICAvL1xuICBtZXNzYWdlID0gbWVzc2FnZSB8fCBodHRwLlNUQVRVU19DT0RFU1tjb2RlXTtcbiAgaGVhZGVycyA9IHtcbiAgICBDb25uZWN0aW9uOiAnY2xvc2UnLFxuICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9odG1sJyxcbiAgICAnQ29udGVudC1MZW5ndGgnOiBCdWZmZXIuYnl0ZUxlbmd0aChtZXNzYWdlKSxcbiAgICAuLi5oZWFkZXJzXG4gIH07XG5cbiAgc29ja2V0Lm9uY2UoJ2ZpbmlzaCcsIHNvY2tldC5kZXN0cm95KTtcblxuICBzb2NrZXQuZW5kKFxuICAgIGBIVFRQLzEuMSAke2NvZGV9ICR7aHR0cC5TVEFUVVNfQ09ERVNbY29kZV19XFxyXFxuYCArXG4gICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgICAgICAubWFwKChoKSA9PiBgJHtofTogJHtoZWFkZXJzW2hdfWApXG4gICAgICAgIC5qb2luKCdcXHJcXG4nKSArXG4gICAgICAnXFxyXFxuXFxyXFxuJyArXG4gICAgICBtZXNzYWdlXG4gICk7XG59XG5cbi8qKlxuICogRW1pdCBhIGAnd3NDbGllbnRFcnJvcidgIGV2ZW50IG9uIGEgYFdlYlNvY2tldFNlcnZlcmAgaWYgdGhlcmUgaXMgYXQgbGVhc3RcbiAqIG9uZSBsaXN0ZW5lciBmb3IgaXQsIG90aGVyd2lzZSBjYWxsIGBhYm9ydEhhbmRzaGFrZSgpYC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldFNlcnZlcn0gc2VydmVyIFRoZSBXZWJTb2NrZXQgc2VydmVyXG4gKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBzb2NrZXQgb2YgdGhlIHVwZ3JhZGUgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBIVFRQIHJlc3BvbnNlIGJvZHlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcihzZXJ2ZXIsIHJlcSwgc29ja2V0LCBjb2RlLCBtZXNzYWdlKSB7XG4gIGlmIChzZXJ2ZXIubGlzdGVuZXJDb3VudCgnd3NDbGllbnRFcnJvcicpKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKTtcblxuICAgIHNlcnZlci5lbWl0KCd3c0NsaWVudEVycm9yJywgZXJyLCBzb2NrZXQsIHJlcSk7XG4gIH0gZWxzZSB7XG4gICAgYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlLCBtZXNzYWdlKTtcbiAgfVxufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZSgnLi9saWIvd2Vic29ja2V0Jyk7XG5cbldlYlNvY2tldC5jcmVhdGVXZWJTb2NrZXRTdHJlYW0gPSByZXF1aXJlKCcuL2xpYi9zdHJlYW0nKTtcbldlYlNvY2tldC5TZXJ2ZXIgPSByZXF1aXJlKCcuL2xpYi93ZWJzb2NrZXQtc2VydmVyJyk7XG5XZWJTb2NrZXQuUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2xpYi9yZWNlaXZlcicpO1xuV2ViU29ja2V0LlNlbmRlciA9IHJlcXVpcmUoJy4vbGliL3NlbmRlcicpO1xuXG5XZWJTb2NrZXQuV2ViU29ja2V0ID0gV2ViU29ja2V0O1xuV2ViU29ja2V0LldlYlNvY2tldFNlcnZlciA9IFdlYlNvY2tldC5TZXJ2ZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ3dzJyk7IiwgIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRyb290LkNyeXB0b0pTID0gZmFjdG9yeSgpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuXHQvKmdsb2JhbHMgd2luZG93LCBnbG9iYWwsIHJlcXVpcmUqL1xuXG5cdC8qKlxuXHQgKiBDcnlwdG9KUyBjb3JlIGNvbXBvbmVudHMuXG5cdCAqL1xuXHR2YXIgQ3J5cHRvSlMgPSBDcnlwdG9KUyB8fCAoZnVuY3Rpb24gKE1hdGgsIHVuZGVmaW5lZCkge1xuXG5cdCAgICB2YXIgY3J5cHRvO1xuXG5cdCAgICAvLyBOYXRpdmUgY3J5cHRvIGZyb20gd2luZG93IChCcm93c2VyKVxuXHQgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jcnlwdG8pIHtcblx0ICAgICAgICBjcnlwdG8gPSB3aW5kb3cuY3J5cHRvO1xuXHQgICAgfVxuXG5cdCAgICAvLyBOYXRpdmUgY3J5cHRvIGluIHdlYiB3b3JrZXIgKEJyb3dzZXIpXG5cdCAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuY3J5cHRvKSB7XG5cdCAgICAgICAgY3J5cHRvID0gc2VsZi5jcnlwdG87XG5cdCAgICB9XG5cblx0ICAgIC8vIE5hdGl2ZSBjcnlwdG8gZnJvbSB3b3JrZXJcblx0ICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcy5jcnlwdG8pIHtcblx0ICAgICAgICBjcnlwdG8gPSBnbG9iYWxUaGlzLmNyeXB0bztcblx0ICAgIH1cblxuXHQgICAgLy8gTmF0aXZlIChleHBlcmltZW50YWwgSUUgMTEpIGNyeXB0byBmcm9tIHdpbmRvdyAoQnJvd3Nlcilcblx0ICAgIGlmICghY3J5cHRvICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5tc0NyeXB0bykge1xuXHQgICAgICAgIGNyeXB0byA9IHdpbmRvdy5tc0NyeXB0bztcblx0ICAgIH1cblxuXHQgICAgLy8gTmF0aXZlIGNyeXB0byBmcm9tIGdsb2JhbCAoTm9kZUpTKVxuXHQgICAgaWYgKCFjcnlwdG8gJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLmNyeXB0bykge1xuXHQgICAgICAgIGNyeXB0byA9IGdsb2JhbC5jcnlwdG87XG5cdCAgICB9XG5cblx0ICAgIC8vIE5hdGl2ZSBjcnlwdG8gaW1wb3J0IHZpYSByZXF1aXJlIChOb2RlSlMpXG5cdCAgICBpZiAoIWNyeXB0byAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgIH1cblxuXHQgICAgLypcblx0ICAgICAqIENyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwc2V1ZG9yYW5kb20gbnVtYmVyIGdlbmVyYXRvclxuXHQgICAgICpcblx0ICAgICAqIEFzIE1hdGgucmFuZG9tKCkgaXMgY3J5cHRvZ3JhcGhpY2FsbHkgbm90IHNhZmUgdG8gdXNlXG5cdCAgICAgKi9cblx0ICAgIHZhciBjcnlwdG9TZWN1cmVSYW5kb21JbnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKGNyeXB0bykge1xuXHQgICAgICAgICAgICAvLyBVc2UgZ2V0UmFuZG9tVmFsdWVzIG1ldGhvZCAoQnJvd3Nlcilcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgxKSlbMF07XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBVc2UgcmFuZG9tQnl0ZXMgbWV0aG9kIChOb2RlSlMpXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvLnJhbmRvbUJ5dGVzID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMoNCkucmVhZEludDMyTEUoKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignTmF0aXZlIGNyeXB0byBtb2R1bGUgY291bGQgbm90IGJlIHVzZWQgdG8gZ2V0IHNlY3VyZSByYW5kb20gbnVtYmVyLicpO1xuXHQgICAgfTtcblxuXHQgICAgLypcblx0ICAgICAqIExvY2FsIHBvbHlmaWxsIG9mIE9iamVjdC5jcmVhdGVcblxuXHQgICAgICovXG5cdCAgICB2YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIEYoKSB7fVxuXG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICAgICAgdmFyIHN1YnR5cGU7XG5cblx0ICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBvYmo7XG5cblx0ICAgICAgICAgICAgc3VidHlwZSA9IG5ldyBGKCk7XG5cblx0ICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBudWxsO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuXHQgICAgICAgIH07XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIENyeXB0b0pTIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBMaWJyYXJ5IG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfbGliID0gQy5saWIgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCYXNlIG9iamVjdCBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlID0gKGZ1bmN0aW9uICgpIHtcblxuXG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlcyBQcm9wZXJ0aWVzIHRvIGNvcHkgaW50byB0aGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZScsXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgfVxuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNwYXduXG5cdCAgICAgICAgICAgICAgICB2YXIgc3VidHlwZSA9IGNyZWF0ZSh0aGlzKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gQXVnbWVudFxuXHQgICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlcykge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUubWl4SW4ob3ZlcnJpZGVzKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgaW5pdGlhbGl6ZXJcblx0ICAgICAgICAgICAgICAgIGlmICghc3VidHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5pdCcpIHx8IHRoaXMuaW5pdCA9PT0gc3VidHlwZS5pbml0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlci5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZXIncyBwcm90b3R5cGUgaXMgdGhlIHN1YnR5cGUgb2JqZWN0XG5cdCAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQucHJvdG90eXBlID0gc3VidHlwZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVmZXJlbmNlIHN1cGVydHlwZVxuXHQgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIgPSB0aGlzO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogRXh0ZW5kcyB0aGlzIG9iamVjdCBhbmQgcnVucyB0aGUgaW5pdCBtZXRob2QuXG5cdCAgICAgICAgICAgICAqIEFyZ3VtZW50cyB0byBjcmVhdGUoKSB3aWxsIGJlIHBhc3NlZCB0byBpbml0KCkuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBpbnN0YW5jZSA9IE15VHlwZS5jcmVhdGUoKTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5leHRlbmQoKTtcblx0ICAgICAgICAgICAgICAgIGluc3RhbmNlLmluaXQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG9iamVjdC5cblx0ICAgICAgICAgICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYWRkIHNvbWUgbG9naWMgd2hlbiB5b3VyIG9iamVjdHMgYXJlIGNyZWF0ZWQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgICAgIC8vIC4uLlxuXHQgICAgICAgICAgICAgKiAgICAgICAgIH1cblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBpbnRvIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBUaGUgcHJvcGVydGllcyB0byBtaXggaW4uXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICBNeVR5cGUubWl4SW4oe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnXG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIG1peEluOiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHByb3BlcnRpZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IHByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIElFIHdvbid0IGNvcHkgdG9TdHJpbmcgdXNpbmcgdGhlIGxvb3AgYWJvdmVcblx0ICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KCd0b1N0cmluZycpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b1N0cmluZyA9IHByb3BlcnRpZXMudG9TdHJpbmc7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGluc3RhbmNlLmNsb25lKCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdC5wcm90b3R5cGUuZXh0ZW5kKHRoaXMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHdvcmRzIFRoZSBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc2lnQnl0ZXMgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgKi9cblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXkgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2lnQnl0ZXMgKE9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoZSB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKCk7XG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10pO1xuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddLCA2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAod29yZHMsIHNpZ0J5dGVzKSB7XG5cdCAgICAgICAgICAgIHdvcmRzID0gdGhpcy53b3JkcyA9IHdvcmRzIHx8IFtdO1xuXG5cdCAgICAgICAgICAgIGlmIChzaWdCeXRlcyAhPSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSB3b3Jkcy5sZW5ndGggKiA0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoaXMgd29yZCBhcnJheSB0byBhIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlciAoT3B0aW9uYWwpIFRoZSBlbmNvZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IENyeXB0b0pTLmVuYy5IZXhcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkgKyAnJztcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZygpO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKGVuY29kZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChlbmNvZGVyIHx8IEhleCkuc3RyaW5naWZ5KHRoaXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25jYXRlbmF0ZXMgYSB3b3JkIGFycmF5IHRvIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheTEuY29uY2F0KHdvcmRBcnJheTIpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbmNhdDogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHRoaXNXb3JkcyA9IHRoaXMud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB0aGF0V29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB0aGlzU2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgdGhhdFNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIHRoaXMuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDb25jYXRcblx0ICAgICAgICAgICAgaWYgKHRoaXNTaWdCeXRlcyAlIDQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIGJ5dGUgYXQgYSB0aW1lXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXRCeXRlID0gKHRoYXRXb3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gfD0gdGhhdEJ5dGUgPDwgKDI0IC0gKCh0aGlzU2lnQnl0ZXMgKyBpKSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSB3b3JkIGF0IGEgdGltZVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGF0U2lnQnl0ZXM7IGogKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaikgPj4+IDJdID0gdGhhdFdvcmRzW2ogPj4+IDJdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgKz0gdGhhdFNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVtb3ZlcyBpbnNpZ25pZmljYW50IGJpdHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsYW1wOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wXG5cdCAgICAgICAgICAgIHdvcmRzW3NpZ0J5dGVzID4+PiAyXSAmPSAweGZmZmZmZmZmIDw8ICgzMiAtIChzaWdCeXRlcyAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIHdvcmRzLmxlbmd0aCA9IE1hdGguY2VpbChzaWdCeXRlcyAvIDQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gd29yZEFycmF5LmNsb25lKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS53b3JkcyA9IHRoaXMud29yZHMuc2xpY2UoMCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgd29yZCBhcnJheSBmaWxsZWQgd2l0aCByYW5kb20gYnl0ZXMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbkJ5dGVzIFRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcmFuZG9tIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxNik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmFuZG9tOiBmdW5jdGlvbiAobkJ5dGVzKSB7XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkJ5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goY3J5cHRvU2VjdXJlUmFuZG9tSW50KCkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbkJ5dGVzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBFbmNvZGVyIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBIZXggZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBIZXggPSBDX2VuYy5IZXggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGV4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkhleC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGhleENoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgJiAweDBmKS50b1N0cmluZygxNikpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhleENoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhleFN0ciBUaGUgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGhleFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChoZXhTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhleFN0ckxlbmd0aCA9IGhleFN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZXhTdHJMZW5ndGg7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gM10gfD0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cihpLCAyKSwgMTYpIDw8ICgyNCAtIChpICUgOCkgKiA0KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGhleFN0ckxlbmd0aCAvIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogTGF0aW4xIGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgTGF0aW4xID0gQ19lbmMuTGF0aW4xID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGxhdGluMVN0cmluZyA9IENyeXB0b0pTLmVuYy5MYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBsYXRpbjFDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGxhdGluMUNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiaXRlKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbGF0aW4xQ2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgTGF0aW4xIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF0aW4xU3RyIFRoZSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5MYXRpbjEucGFyc2UobGF0aW4xU3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGxhdGluMVN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgbGF0aW4xU3RyTGVuZ3RoID0gbGF0aW4xU3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGluMVN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAyXSB8PSAobGF0aW4xU3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmKSA8PCAoMjQgLSAoaSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBsYXRpbjFTdHJMZW5ndGgpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogVVRGLTggZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmOCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgdXRmOFN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGY4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpKSk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFVURi04IGRhdGEnKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi04IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmOFN0ciBUaGUgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKHV0ZjhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodXRmOFN0cikge1xuXHQgICAgICAgICAgICByZXR1cm4gTGF0aW4xLnBhcnNlKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh1dGY4U3RyKSkpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYnVmZmVyZWQgYmxvY2sgYWxnb3JpdGhtIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIFRoZSBwcm9wZXJ0eSBibG9ja1NpemUgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBhIGNvbmNyZXRlIHN1YnR5cGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9taW5CdWZmZXJTaXplIFRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgc2hvdWxkIGJlIGtlcHQgdW5wcm9jZXNzZWQgaW4gdGhlIGJ1ZmZlci4gRGVmYXVsdDogMFxuXHQgICAgICovXG5cdCAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgZGF0YSBidWZmZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLl9kYXRhID0gbmV3IFdvcmRBcnJheS5pbml0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgPSAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIG5ldyBkYXRhIHRvIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgYnVmZmVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGFwcGVuZC4gU3RyaW5ncyBhcmUgY29udmVydGVkIHRvIGEgV29yZEFycmF5IHVzaW5nIFVURi04LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2FwcGVuZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gV29yZEFycmF5LCBlbHNlIGFzc3VtZSBXb3JkQXJyYXkgYWxyZWFkeVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIGRhdGEgPSBVdGY4LnBhcnNlKGRhdGEpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2RhdGEuY29uY2F0KGRhdGEpO1xuXHQgICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzICs9IGRhdGEuc2lnQnl0ZXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFByb2Nlc3NlcyBhdmFpbGFibGUgZGF0YSBibG9ja3MuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIF9kb1Byb2Nlc3NCbG9jayhvZmZzZXQpLCB3aGljaCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGEgY29uY3JldGUgc3VidHlwZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9GbHVzaCBXaGV0aGVyIGFsbCBibG9ja3MgYW5kIHBhcnRpYWwgYmxvY2tzIHNob3VsZCBiZSBwcm9jZXNzZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwcm9jZXNzZWQgZGF0YS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCk7XG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcyghISdmbHVzaCcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9wcm9jZXNzOiBmdW5jdGlvbiAoZG9GbHVzaCkge1xuXHQgICAgICAgICAgICB2YXIgcHJvY2Vzc2VkV29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBkYXRhU2lnQnl0ZXMgPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gdGhpcy5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYmxvY2tzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuQmxvY2tzUmVhZHkgPSBkYXRhU2lnQnl0ZXMgLyBibG9ja1NpemVCeXRlcztcblx0ICAgICAgICAgICAgaWYgKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRvIGluY2x1ZGUgcGFydGlhbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGguY2VpbChuQmxvY2tzUmVhZHkpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgZG93biB0byBpbmNsdWRlIG9ubHkgZnVsbCBibG9ja3MsXG5cdCAgICAgICAgICAgICAgICAvLyBsZXNzIHRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgbXVzdCByZW1haW4gaW4gdGhlIGJ1ZmZlclxuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5tYXgoKG5CbG9ja3NSZWFkeSB8IDApIC0gdGhpcy5fbWluQnVmZmVyU2l6ZSwgMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb3VudCB3b3JkcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbldvcmRzUmVhZHkgPSBuQmxvY2tzUmVhZHkgKiBibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYnl0ZXMgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5CeXRlc1JlYWR5ID0gTWF0aC5taW4obldvcmRzUmVhZHkgKiA0LCBkYXRhU2lnQnl0ZXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgYmxvY2tzXG5cdCAgICAgICAgICAgIGlmIChuV29yZHNSZWFkeSkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbldvcmRzUmVhZHk7IG9mZnNldCArPSBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWFsZ29yaXRobSBsb2dpY1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUHJvY2Vzc0Jsb2NrKGRhdGFXb3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICAgICAgcHJvY2Vzc2VkV29yZHMgPSBkYXRhV29yZHMuc3BsaWNlKDAsIG5Xb3Jkc1JlYWR5KTtcblx0ICAgICAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gbkJ5dGVzUmVhZHk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gcHJvY2Vzc2VkIHdvcmRzXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQocHJvY2Vzc2VkV29yZHMsIG5CeXRlc1JlYWR5KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2RhdGEgPSB0aGlzLl9kYXRhLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfbWluQnVmZmVyU2l6ZTogMFxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgaGFzaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBoYXNoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDE2ICg1MTIgYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGhhc2hlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBoYXNoIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaGVyID0gQ3J5cHRvSlMuYWxnby5TSEEyNTYuY3JlYXRlKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBoYXNoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG5cdCAgICAgICAgICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuXHQgICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVwZGF0ZXMgdGhpcyBoYXNoZXIgd2l0aCBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7SGFzaGVyfSBUaGlzIGhhc2hlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaGFzaFxuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIGhhc2ggY29tcHV0YXRpb24uXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBGaW5hbCBtZXNzYWdlIHVwZGF0ZVxuXHQgICAgICAgICAgICBpZiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogNTEyLzMyLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIGEgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIFNIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGNmZykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBoYXNoZXIuaW5pdChjZmcpLmZpbmFsaXplKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIHVzZSBpbiB0aGlzIEhNQUMgaGVscGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIEhtYWNTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSG1hY0hlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDX2FsZ28uSE1BQy5pbml0KGhhc2hlciwga2V5KS5maW5hbGl6ZShtZXNzYWdlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbGdvcml0aG0gbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvID0ge307XG5cblx0ICAgIHJldHVybiBDO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUztcblxufSkpOyIsICI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIEluaXRpYWxpemF0aW9uIGFuZCByb3VuZCBjb25zdGFudHMgdGFibGVzXG5cdCAgICB2YXIgSCA9IFtdO1xuXHQgICAgdmFyIEsgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBjb25zdGFudHNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gaXNQcmltZShuKSB7XG5cdCAgICAgICAgICAgIHZhciBzcXJ0TiA9IE1hdGguc3FydChuKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgZmFjdG9yID0gMjsgZmFjdG9yIDw9IHNxcnROOyBmYWN0b3IrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKCEobiAlIGZhY3RvcikpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmdW5jdGlvbiBnZXRGcmFjdGlvbmFsQml0cyhuKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoKG4gLSAobiB8IDApKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIG4gPSAyO1xuXHQgICAgICAgIHZhciBuUHJpbWUgPSAwO1xuXHQgICAgICAgIHdoaWxlIChuUHJpbWUgPCA2NCkge1xuXHQgICAgICAgICAgICBpZiAoaXNQcmltZShuKSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG5QcmltZSA8IDgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBIW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhNYXRoLnBvdyhuLCAxIC8gMikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgS1tuUHJpbWVdID0gZ2V0RnJhY3Rpb25hbEJpdHMoTWF0aC5wb3cobiwgMSAvIDMpKTtcblxuXHQgICAgICAgICAgICAgICAgblByaW1lKys7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBuKys7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLy8gUmV1c2FibGUgb2JqZWN0XG5cdCAgICB2YXIgVyA9IFtdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNIQS0yNTYgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEEyNTYgPSBDX2FsZ28uU0hBMjU2ID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChILnNsaWNlKDApKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuXHQgICAgICAgICAgICB2YXIgYSA9IEhbMF07XG5cdCAgICAgICAgICAgIHZhciBiID0gSFsxXTtcblx0ICAgICAgICAgICAgdmFyIGMgPSBIWzJdO1xuXHQgICAgICAgICAgICB2YXIgZCA9IEhbM107XG5cdCAgICAgICAgICAgIHZhciBlID0gSFs0XTtcblx0ICAgICAgICAgICAgdmFyIGYgPSBIWzVdO1xuXHQgICAgICAgICAgICB2YXIgZyA9IEhbNl07XG5cdCAgICAgICAgICAgIHZhciBoID0gSFs3XTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMTYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gTVtvZmZzZXQgKyBpXSB8IDA7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTB4ID0gV1tpIC0gMTVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTAgID0gKChnYW1tYTB4IDw8IDI1KSB8IChnYW1tYTB4ID4+PiA3KSkgIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoZ2FtbWEweCA8PCAxNCkgfCAoZ2FtbWEweCA+Pj4gMTgpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdhbW1hMHggPj4+IDMpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMXggPSBXW2kgLSAyXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExICA9ICgoZ2FtbWExeCA8PCAxNSkgfCAoZ2FtbWExeCA+Pj4gMTcpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGdhbW1hMXggPDwgMTMpIHwgKGdhbW1hMXggPj4+IDE5KSkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnYW1tYTF4ID4+PiAxMCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciBjaCAgPSAoZSAmIGYpIF4gKH5lICYgZyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWFqID0gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWEwID0gKChhIDw8IDMwKSB8IChhID4+PiAyKSkgXiAoKGEgPDwgMTkpIHwgKGEgPj4+IDEzKSkgXiAoKGEgPDwgMTApIHwgKGEgPj4+IDIyKSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWExID0gKChlIDw8IDI2KSB8IChlID4+PiA2KSkgXiAoKGUgPDwgMjEpIHwgKGUgPj4+IDExKSkgXiAoKGUgPDwgNykgIHwgKGUgPj4+IDI1KSk7XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbaV0gKyBXW2ldO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQyID0gc2lnbWEwICsgbWFqO1xuXG5cdCAgICAgICAgICAgICAgICBoID0gZztcblx0ICAgICAgICAgICAgICAgIGcgPSBmO1xuXHQgICAgICAgICAgICAgICAgZiA9IGU7XG5cdCAgICAgICAgICAgICAgICBlID0gKGQgKyB0MSkgfCAwO1xuXHQgICAgICAgICAgICAgICAgZCA9IGM7XG5cdCAgICAgICAgICAgICAgICBjID0gYjtcblx0ICAgICAgICAgICAgICAgIGIgPSBhO1xuXHQgICAgICAgICAgICAgICAgYSA9ICh0MSArIHQyKSB8IDA7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcblx0ICAgICAgICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuXHQgICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNF0gPSAoSFs0XSArIGUpIHwgMDtcblx0ICAgICAgICAgICAgSFs1XSA9IChIWzVdICsgZikgfCAwO1xuXHQgICAgICAgICAgICBIWzZdID0gKEhbNl0gKyBnKSB8IDA7XG5cdCAgICAgICAgICAgIEhbN10gPSAoSFs3XSArIGgpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSBuQml0c1RvdGFsO1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjU2KCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEEyNTYgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEEyNTYpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTI1NihtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEEyNTYgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMjU2KTtcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMjU2O1xuXG59KSk7IiwgIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEJhc2U2NCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJhc2U2NCA9IENfZW5jLkJhc2U2NCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBiYXNlNjRTdHJpbmcgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblx0ICAgICAgICAgICAgd29yZEFycmF5LmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgYmFzZTY0Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTEgPSAod29yZHNbaSA+Pj4gMl0gICAgICAgPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgICAgICAgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUyID0gKHdvcmRzWyhpICsgMSkgPj4+IDJdID4+PiAoMjQgLSAoKGkgKyAxKSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMyA9ICh3b3Jkc1soaSArIDIpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMikgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0cmlwbGV0ID0gKGJ5dGUxIDw8IDE2KSB8IChieXRlMiA8PCA4KSB8IGJ5dGUzO1xuXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgKGogPCA0KSAmJiAoaSArIGogKiAwLjc1IDwgc2lnQnl0ZXMpOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRDaGFycy5wdXNoKG1hcC5jaGFyQXQoKHRyaXBsZXQgPj4+ICg2ICogKDMgLSBqKSkpICYgMHgzZikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdDaGFyID0gbWFwLmNoYXJBdCg2NCk7XG5cdCAgICAgICAgICAgIGlmIChwYWRkaW5nQ2hhcikge1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKGJhc2U2NENoYXJzLmxlbmd0aCAlIDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRDaGFycy5wdXNoKHBhZGRpbmdDaGFyKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBiYXNlNjRDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBCYXNlNjQgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRTdHIgVGhlIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5wYXJzZShiYXNlNjRTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoYmFzZTY0U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgYmFzZTY0U3RyTGVuZ3RoID0gYmFzZTY0U3RyLmxlbmd0aDtcblx0ICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblx0ICAgICAgICAgICAgdmFyIHJldmVyc2VNYXAgPSB0aGlzLl9yZXZlcnNlTWFwO1xuXG5cdCAgICAgICAgICAgIGlmICghcmV2ZXJzZU1hcCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXAgPSB0aGlzLl9yZXZlcnNlTWFwID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXAubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU1hcFttYXAuY2hhckNvZGVBdChqKV0gPSBqO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIElnbm9yZSBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuXHQgICAgICAgICAgICBpZiAocGFkZGluZ0NoYXIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nSW5kZXggPSBiYXNlNjRTdHIuaW5kZXhPZihwYWRkaW5nQ2hhcik7XG5cdCAgICAgICAgICAgICAgICBpZiAocGFkZGluZ0luZGV4ICE9PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJhc2U2NFN0ckxlbmd0aCA9IHBhZGRpbmdJbmRleDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgcmV0dXJuIHBhcnNlTG9vcChiYXNlNjRTdHIsIGJhc2U2NFN0ckxlbmd0aCwgcmV2ZXJzZU1hcCk7XG5cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX21hcDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89J1xuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gcGFyc2VMb29wKGJhc2U2NFN0ciwgYmFzZTY0U3RyTGVuZ3RoLCByZXZlcnNlTWFwKSB7XG5cdCAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICB2YXIgbkJ5dGVzID0gMDtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlNjRTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgaWYgKGkgJSA0KSB7XG5cdCAgICAgICAgICAgICAgdmFyIGJpdHMxID0gcmV2ZXJzZU1hcFtiYXNlNjRTdHIuY2hhckNvZGVBdChpIC0gMSldIDw8ICgoaSAlIDQpICogMik7XG5cdCAgICAgICAgICAgICAgdmFyIGJpdHMyID0gcmV2ZXJzZU1hcFtiYXNlNjRTdHIuY2hhckNvZGVBdChpKV0gPj4+ICg2IC0gKGkgJSA0KSAqIDIpO1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzQ29tYmluZWQgPSBiaXRzMSB8IGJpdHMyO1xuXHQgICAgICAgICAgICAgIHdvcmRzW25CeXRlcyA+Pj4gMl0gfD0gYml0c0NvbWJpbmVkIDw8ICgyNCAtIChuQnl0ZXMgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICAgIG5CeXRlcysrO1xuXHQgICAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCBuQnl0ZXMpO1xuXHQgICAgfVxuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmVuYy5CYXNlNjQ7XG5cbn0pKTsiLCBudWxsLCAiLy8gSW50ZWdlciBVdGlsaXR5XG5cbmV4cG9ydCBjb25zdCBVSU5UMzJfTUFYID0gMHhmZmZmX2ZmZmY7XG5cbi8vIERhdGFWaWV3IGV4dGVuc2lvbiB0byBoYW5kbGUgaW50NjQgLyB1aW50NjQsXG4vLyB3aGVyZSB0aGUgYWN0dWFsIHJhbmdlIGlzIDUzLWJpdHMgaW50ZWdlciAoYS5rLmEuIHNhZmUgaW50ZWdlcilcblxuZXhwb3J0IGZ1bmN0aW9uIHNldFVpbnQ2NCh2aWV3OiBEYXRhVmlldywgb2Zmc2V0OiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiB2b2lkIHtcbiAgY29uc3QgaGlnaCA9IHZhbHVlIC8gMHgxXzAwMDBfMDAwMDtcbiAgY29uc3QgbG93ID0gdmFsdWU7IC8vIGhpZ2ggYml0cyBhcmUgdHJ1bmNhdGVkIGJ5IERhdGFWaWV3XG4gIHZpZXcuc2V0VWludDMyKG9mZnNldCwgaGlnaCk7XG4gIHZpZXcuc2V0VWludDMyKG9mZnNldCArIDQsIGxvdyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRJbnQ2NCh2aWV3OiBEYXRhVmlldywgb2Zmc2V0OiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiB2b2lkIHtcbiAgY29uc3QgaGlnaCA9IE1hdGguZmxvb3IodmFsdWUgLyAweDFfMDAwMF8wMDAwKTtcbiAgY29uc3QgbG93ID0gdmFsdWU7IC8vIGhpZ2ggYml0cyBhcmUgdHJ1bmNhdGVkIGJ5IERhdGFWaWV3XG4gIHZpZXcuc2V0VWludDMyKG9mZnNldCwgaGlnaCk7XG4gIHZpZXcuc2V0VWludDMyKG9mZnNldCArIDQsIGxvdyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnQ2NCh2aWV3OiBEYXRhVmlldywgb2Zmc2V0OiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCBoaWdoID0gdmlldy5nZXRJbnQzMihvZmZzZXQpO1xuICBjb25zdCBsb3cgPSB2aWV3LmdldFVpbnQzMihvZmZzZXQgKyA0KTtcbiAgcmV0dXJuIGhpZ2ggKiAweDFfMDAwMF8wMDAwICsgbG93O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VWludDY0KHZpZXc6IERhdGFWaWV3LCBvZmZzZXQ6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IGhpZ2ggPSB2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICBjb25zdCBsb3cgPSB2aWV3LmdldFVpbnQzMihvZmZzZXQgKyA0KTtcbiAgcmV0dXJuIGhpZ2ggKiAweDFfMDAwMF8wMDAwICsgbG93O1xufVxuIiwgIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24gKi9cbmltcG9ydCB7IFVJTlQzMl9NQVggfSBmcm9tIFwiLi9pbnRcIjtcblxuY29uc3QgVEVYVF9FTkNPRElOR19BVkFJTEFCTEUgPVxuICAodHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJvY2Vzcz8uZW52Py5bXCJURVhUX0VOQ09ESU5HXCJdICE9PSBcIm5ldmVyXCIpICYmXG4gIHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICB0eXBlb2YgVGV4dERlY29kZXIgIT09IFwidW5kZWZpbmVkXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB1dGY4Q291bnQoc3RyOiBzdHJpbmcpOiBudW1iZXIge1xuICBjb25zdCBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuXG4gIGxldCBieXRlTGVuZ3RoID0gMDtcbiAgbGV0IHBvcyA9IDA7XG4gIHdoaWxlIChwb3MgPCBzdHJMZW5ndGgpIHtcbiAgICBsZXQgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChwb3MrKyk7XG5cbiAgICBpZiAoKHZhbHVlICYgMHhmZmZmZmY4MCkgPT09IDApIHtcbiAgICAgIC8vIDEtYnl0ZVxuICAgICAgYnl0ZUxlbmd0aCsrO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmICgodmFsdWUgJiAweGZmZmZmODAwKSA9PT0gMCkge1xuICAgICAgLy8gMi1ieXRlc1xuICAgICAgYnl0ZUxlbmd0aCArPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYW5kbGUgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGlmICh2YWx1ZSA+PSAweGQ4MDAgJiYgdmFsdWUgPD0gMHhkYmZmKSB7XG4gICAgICAgIC8vIGhpZ2ggc3Vycm9nYXRlXG4gICAgICAgIGlmIChwb3MgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBleHRyYSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgaWYgKChleHRyYSAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICAgICAgKytwb3M7XG4gICAgICAgICAgICB2YWx1ZSA9ICgodmFsdWUgJiAweDNmZikgPDwgMTApICsgKGV4dHJhICYgMHgzZmYpICsgMHgxMDAwMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCh2YWx1ZSAmIDB4ZmZmZjAwMDApID09PSAwKSB7XG4gICAgICAgIC8vIDMtYnl0ZVxuICAgICAgICBieXRlTGVuZ3RoICs9IDM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyA0LWJ5dGVcbiAgICAgICAgYnl0ZUxlbmd0aCArPSA0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYnl0ZUxlbmd0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhFbmNvZGVKcyhzdHI6IHN0cmluZywgb3V0cHV0OiBVaW50OEFycmF5LCBvdXRwdXRPZmZzZXQ6IG51bWJlcik6IHZvaWQge1xuICBjb25zdCBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICBsZXQgb2Zmc2V0ID0gb3V0cHV0T2Zmc2V0O1xuICBsZXQgcG9zID0gMDtcbiAgd2hpbGUgKHBvcyA8IHN0ckxlbmd0aCkge1xuICAgIGxldCB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcysrKTtcblxuICAgIGlmICgodmFsdWUgJiAweGZmZmZmZjgwKSA9PT0gMCkge1xuICAgICAgLy8gMS1ieXRlXG4gICAgICBvdXRwdXRbb2Zmc2V0KytdID0gdmFsdWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKCh2YWx1ZSAmIDB4ZmZmZmY4MDApID09PSAwKSB7XG4gICAgICAvLyAyLWJ5dGVzXG4gICAgICBvdXRwdXRbb2Zmc2V0KytdID0gKCh2YWx1ZSA+PiA2KSAmIDB4MWYpIHwgMHhjMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaGFuZGxlIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBpZiAodmFsdWUgPj0gMHhkODAwICYmIHZhbHVlIDw9IDB4ZGJmZikge1xuICAgICAgICAvLyBoaWdoIHN1cnJvZ2F0ZVxuICAgICAgICBpZiAocG9zIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgZXh0cmEgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgIGlmICgoZXh0cmEgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgICAgICsrcG9zO1xuICAgICAgICAgICAgdmFsdWUgPSAoKHZhbHVlICYgMHgzZmYpIDw8IDEwKSArIChleHRyYSAmIDB4M2ZmKSArIDB4MTAwMDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgodmFsdWUgJiAweGZmZmYwMDAwKSA9PT0gMCkge1xuICAgICAgICAvLyAzLWJ5dGVcbiAgICAgICAgb3V0cHV0W29mZnNldCsrXSA9ICgodmFsdWUgPj4gMTIpICYgMHgwZikgfCAweGUwO1xuICAgICAgICBvdXRwdXRbb2Zmc2V0KytdID0gKCh2YWx1ZSA+PiA2KSAmIDB4M2YpIHwgMHg4MDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDQtYnl0ZVxuICAgICAgICBvdXRwdXRbb2Zmc2V0KytdID0gKCh2YWx1ZSA+PiAxOCkgJiAweDA3KSB8IDB4ZjA7XG4gICAgICAgIG91dHB1dFtvZmZzZXQrK10gPSAoKHZhbHVlID4+IDEyKSAmIDB4M2YpIHwgMHg4MDtcbiAgICAgICAgb3V0cHV0W29mZnNldCsrXSA9ICgodmFsdWUgPj4gNikgJiAweDNmKSB8IDB4ODA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3V0cHV0W29mZnNldCsrXSA9ICh2YWx1ZSAmIDB4M2YpIHwgMHg4MDtcbiAgfVxufVxuXG5jb25zdCBzaGFyZWRUZXh0RW5jb2RlciA9IFRFWFRfRU5DT0RJTkdfQVZBSUxBQkxFID8gbmV3IFRleHRFbmNvZGVyKCkgOiB1bmRlZmluZWQ7XG5leHBvcnQgY29uc3QgVEVYVF9FTkNPREVSX1RIUkVTSE9MRCA9ICFURVhUX0VOQ09ESU5HX0FWQUlMQUJMRVxuICA/IFVJTlQzMl9NQVhcbiAgOiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzPy5lbnY/LltcIlRFWFRfRU5DT0RJTkdcIl0gIT09IFwiZm9yY2VcIlxuICA/IDIwMFxuICA6IDA7XG5cbmZ1bmN0aW9uIHV0ZjhFbmNvZGVURWVuY29kZShzdHI6IHN0cmluZywgb3V0cHV0OiBVaW50OEFycmF5LCBvdXRwdXRPZmZzZXQ6IG51bWJlcik6IHZvaWQge1xuICBvdXRwdXQuc2V0KHNoYXJlZFRleHRFbmNvZGVyIS5lbmNvZGUoc3RyKSwgb3V0cHV0T2Zmc2V0KTtcbn1cblxuZnVuY3Rpb24gdXRmOEVuY29kZVRFZW5jb2RlSW50byhzdHI6IHN0cmluZywgb3V0cHV0OiBVaW50OEFycmF5LCBvdXRwdXRPZmZzZXQ6IG51bWJlcik6IHZvaWQge1xuICBzaGFyZWRUZXh0RW5jb2RlciEuZW5jb2RlSW50byhzdHIsIG91dHB1dC5zdWJhcnJheShvdXRwdXRPZmZzZXQpKTtcbn1cblxuZXhwb3J0IGNvbnN0IHV0ZjhFbmNvZGVURSA9IHNoYXJlZFRleHRFbmNvZGVyPy5lbmNvZGVJbnRvID8gdXRmOEVuY29kZVRFZW5jb2RlSW50byA6IHV0ZjhFbmNvZGVURWVuY29kZTtcblxuY29uc3QgQ0hVTktfU0laRSA9IDB4MV8wMDA7XG5cbmV4cG9ydCBmdW5jdGlvbiB1dGY4RGVjb2RlSnMoYnl0ZXM6IFVpbnQ4QXJyYXksIGlucHV0T2Zmc2V0OiBudW1iZXIsIGJ5dGVMZW5ndGg6IG51bWJlcik6IHN0cmluZyB7XG4gIGxldCBvZmZzZXQgPSBpbnB1dE9mZnNldDtcbiAgY29uc3QgZW5kID0gb2Zmc2V0ICsgYnl0ZUxlbmd0aDtcblxuICBjb25zdCB1bml0czogQXJyYXk8bnVtYmVyPiA9IFtdO1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgd2hpbGUgKG9mZnNldCA8IGVuZCkge1xuICAgIGNvbnN0IGJ5dGUxID0gYnl0ZXNbb2Zmc2V0KytdITtcbiAgICBpZiAoKGJ5dGUxICYgMHg4MCkgPT09IDApIHtcbiAgICAgIC8vIDEgYnl0ZVxuICAgICAgdW5pdHMucHVzaChieXRlMSk7XG4gICAgfSBlbHNlIGlmICgoYnl0ZTEgJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgLy8gMiBieXRlc1xuICAgICAgY29uc3QgYnl0ZTIgPSBieXRlc1tvZmZzZXQrK10hICYgMHgzZjtcbiAgICAgIHVuaXRzLnB1c2goKChieXRlMSAmIDB4MWYpIDw8IDYpIHwgYnl0ZTIpO1xuICAgIH0gZWxzZSBpZiAoKGJ5dGUxICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgIC8vIDMgYnl0ZXNcbiAgICAgIGNvbnN0IGJ5dGUyID0gYnl0ZXNbb2Zmc2V0KytdISAmIDB4M2Y7XG4gICAgICBjb25zdCBieXRlMyA9IGJ5dGVzW29mZnNldCsrXSEgJiAweDNmO1xuICAgICAgdW5pdHMucHVzaCgoKGJ5dGUxICYgMHgxZikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTMpO1xuICAgIH0gZWxzZSBpZiAoKGJ5dGUxICYgMHhmOCkgPT09IDB4ZjApIHtcbiAgICAgIC8vIDQgYnl0ZXNcbiAgICAgIGNvbnN0IGJ5dGUyID0gYnl0ZXNbb2Zmc2V0KytdISAmIDB4M2Y7XG4gICAgICBjb25zdCBieXRlMyA9IGJ5dGVzW29mZnNldCsrXSEgJiAweDNmO1xuICAgICAgY29uc3QgYnl0ZTQgPSBieXRlc1tvZmZzZXQrK10hICYgMHgzZjtcbiAgICAgIGxldCB1bml0ID0gKChieXRlMSAmIDB4MDcpIDw8IDB4MTIpIHwgKGJ5dGUyIDw8IDB4MGMpIHwgKGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG4gICAgICBpZiAodW5pdCA+IDB4ZmZmZikge1xuICAgICAgICB1bml0IC09IDB4MTAwMDA7XG4gICAgICAgIHVuaXRzLnB1c2goKCh1bml0ID4+PiAxMCkgJiAweDNmZikgfCAweGQ4MDApO1xuICAgICAgICB1bml0ID0gMHhkYzAwIHwgKHVuaXQgJiAweDNmZik7XG4gICAgICB9XG4gICAgICB1bml0cy5wdXNoKHVuaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bml0cy5wdXNoKGJ5dGUxKTtcbiAgICB9XG5cbiAgICBpZiAodW5pdHMubGVuZ3RoID49IENIVU5LX1NJWkUpIHtcbiAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLnVuaXRzKTtcbiAgICAgIHVuaXRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG5cbiAgaWYgKHVuaXRzLmxlbmd0aCA+IDApIHtcbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSguLi51bml0cyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBzaGFyZWRUZXh0RGVjb2RlciA9IFRFWFRfRU5DT0RJTkdfQVZBSUxBQkxFID8gbmV3IFRleHREZWNvZGVyKCkgOiBudWxsO1xuZXhwb3J0IGNvbnN0IFRFWFRfREVDT0RFUl9USFJFU0hPTEQgPSAhVEVYVF9FTkNPRElOR19BVkFJTEFCTEVcbiAgPyBVSU5UMzJfTUFYXG4gIDogdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcz8uZW52Py5bXCJURVhUX0RFQ09ERVJcIl0gIT09IFwiZm9yY2VcIlxuICA/IDIwMFxuICA6IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiB1dGY4RGVjb2RlVEQoYnl0ZXM6IFVpbnQ4QXJyYXksIGlucHV0T2Zmc2V0OiBudW1iZXIsIGJ5dGVMZW5ndGg6IG51bWJlcik6IHN0cmluZyB7XG4gIGNvbnN0IHN0cmluZ0J5dGVzID0gYnl0ZXMuc3ViYXJyYXkoaW5wdXRPZmZzZXQsIGlucHV0T2Zmc2V0ICsgYnl0ZUxlbmd0aCk7XG4gIHJldHVybiBzaGFyZWRUZXh0RGVjb2RlciEuZGVjb2RlKHN0cmluZ0J5dGVzKTtcbn1cbiIsICIvKipcbiAqIEV4dERhdGEgaXMgdXNlZCB0byBoYW5kbGUgRXh0ZW5zaW9uIFR5cGVzIHRoYXQgYXJlIG5vdCByZWdpc3RlcmVkIHRvIEV4dGVuc2lvbkNvZGVjLlxuICovXG5leHBvcnQgY2xhc3MgRXh0RGF0YSB7XG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IHR5cGU6IG51bWJlciwgcmVhZG9ubHkgZGF0YTogVWludDhBcnJheSkge31cbn1cbiIsICJleHBvcnQgY2xhc3MgRGVjb2RlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuXG4gICAgLy8gZml4IHRoZSBwcm90b3R5cGUgY2hhaW4gaW4gYSBjcm9zcy1wbGF0Zm9ybSB3YXlcbiAgICBjb25zdCBwcm90bzogdHlwZW9mIERlY29kZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRGVjb2RlRXJyb3IucHJvdG90eXBlKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgcHJvdG8pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBEZWNvZGVFcnJvci5uYW1lLFxuICAgIH0pO1xuICB9XG59XG4iLCAiLy8gaHR0cHM6Ly9naXRodWIuY29tL21zZ3BhY2svbXNncGFjay9ibG9iL21hc3Rlci9zcGVjLm1kI3RpbWVzdGFtcC1leHRlbnNpb24tdHlwZVxuaW1wb3J0IHsgRGVjb2RlRXJyb3IgfSBmcm9tIFwiLi9EZWNvZGVFcnJvclwiO1xuaW1wb3J0IHsgZ2V0SW50NjQsIHNldEludDY0IH0gZnJvbSBcIi4vdXRpbHMvaW50XCI7XG5cbmV4cG9ydCBjb25zdCBFWFRfVElNRVNUQU1QID0gLTE7XG5cbmV4cG9ydCB0eXBlIFRpbWVTcGVjID0ge1xuICBzZWM6IG51bWJlcjtcbiAgbnNlYzogbnVtYmVyO1xufTtcblxuY29uc3QgVElNRVNUQU1QMzJfTUFYX1NFQyA9IDB4MTAwMDAwMDAwIC0gMTsgLy8gMzItYml0IHVuc2lnbmVkIGludFxuY29uc3QgVElNRVNUQU1QNjRfTUFYX1NFQyA9IDB4NDAwMDAwMDAwIC0gMTsgLy8gMzQtYml0IHVuc2lnbmVkIGludFxuXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlVGltZVNwZWNUb1RpbWVzdGFtcCh7IHNlYywgbnNlYyB9OiBUaW1lU3BlYyk6IFVpbnQ4QXJyYXkge1xuICBpZiAoc2VjID49IDAgJiYgbnNlYyA+PSAwICYmIHNlYyA8PSBUSU1FU1RBTVA2NF9NQVhfU0VDKSB7XG4gICAgLy8gSGVyZSBzZWMgPj0gMCAmJiBuc2VjID49IDBcbiAgICBpZiAobnNlYyA9PT0gMCAmJiBzZWMgPD0gVElNRVNUQU1QMzJfTUFYX1NFQykge1xuICAgICAgLy8gdGltZXN0YW1wIDMyID0geyBzZWMzMiAodW5zaWduZWQpIH1cbiAgICAgIGNvbnN0IHJ2ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KHJ2LmJ1ZmZlcik7XG4gICAgICB2aWV3LnNldFVpbnQzMigwLCBzZWMpO1xuICAgICAgcmV0dXJuIHJ2O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aW1lc3RhbXAgNjQgPSB7IG5zZWMzMCAodW5zaWduZWQpLCBzZWMzNCAodW5zaWduZWQpIH1cbiAgICAgIGNvbnN0IHNlY0hpZ2ggPSBzZWMgLyAweDEwMDAwMDAwMDtcbiAgICAgIGNvbnN0IHNlY0xvdyA9IHNlYyAmIDB4ZmZmZmZmZmY7XG4gICAgICBjb25zdCBydiA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhydi5idWZmZXIpO1xuICAgICAgLy8gbnNlYzMwIHwgc2VjSGlnaDJcbiAgICAgIHZpZXcuc2V0VWludDMyKDAsIChuc2VjIDw8IDIpIHwgKHNlY0hpZ2ggJiAweDMpKTtcbiAgICAgIC8vIHNlY0xvdzMyXG4gICAgICB2aWV3LnNldFVpbnQzMig0LCBzZWNMb3cpO1xuICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyB0aW1lc3RhbXAgOTYgPSB7IG5zZWMzMiAodW5zaWduZWQpLCBzZWM2NCAoc2lnbmVkKSB9XG4gICAgY29uc3QgcnYgPSBuZXcgVWludDhBcnJheSgxMik7XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhydi5idWZmZXIpO1xuICAgIHZpZXcuc2V0VWludDMyKDAsIG5zZWMpO1xuICAgIHNldEludDY0KHZpZXcsIDQsIHNlYyk7XG4gICAgcmV0dXJuIHJ2O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVEYXRlVG9UaW1lU3BlYyhkYXRlOiBEYXRlKTogVGltZVNwZWMge1xuICBjb25zdCBtc2VjID0gZGF0ZS5nZXRUaW1lKCk7XG4gIGNvbnN0IHNlYyA9IE1hdGguZmxvb3IobXNlYyAvIDFlMyk7XG4gIGNvbnN0IG5zZWMgPSAobXNlYyAtIHNlYyAqIDFlMykgKiAxZTY7XG5cbiAgLy8gTm9ybWFsaXplcyB7IHNlYywgbnNlYyB9IHRvIGVuc3VyZSBuc2VjIGlzIHVuc2lnbmVkLlxuICBjb25zdCBuc2VjSW5TZWMgPSBNYXRoLmZsb29yKG5zZWMgLyAxZTkpO1xuICByZXR1cm4ge1xuICAgIHNlYzogc2VjICsgbnNlY0luU2VjLFxuICAgIG5zZWM6IG5zZWMgLSBuc2VjSW5TZWMgKiAxZTksXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVUaW1lc3RhbXBFeHRlbnNpb24ob2JqZWN0OiB1bmtub3duKTogVWludDhBcnJheSB8IG51bGwge1xuICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIGNvbnN0IHRpbWVTcGVjID0gZW5jb2RlRGF0ZVRvVGltZVNwZWMob2JqZWN0KTtcbiAgICByZXR1cm4gZW5jb2RlVGltZVNwZWNUb1RpbWVzdGFtcCh0aW1lU3BlYyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVRpbWVzdGFtcFRvVGltZVNwZWMoZGF0YTogVWludDhBcnJheSk6IFRpbWVTcGVjIHtcbiAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuXG4gIC8vIGRhdGEgbWF5IGJlIDMyLCA2NCwgb3IgOTYgYml0c1xuICBzd2l0Y2ggKGRhdGEuYnl0ZUxlbmd0aCkge1xuICAgIGNhc2UgNDoge1xuICAgICAgLy8gdGltZXN0YW1wIDMyID0geyBzZWMzMiB9XG4gICAgICBjb25zdCBzZWMgPSB2aWV3LmdldFVpbnQzMigwKTtcbiAgICAgIGNvbnN0IG5zZWMgPSAwO1xuICAgICAgcmV0dXJuIHsgc2VjLCBuc2VjIH07XG4gICAgfVxuICAgIGNhc2UgODoge1xuICAgICAgLy8gdGltZXN0YW1wIDY0ID0geyBuc2VjMzAsIHNlYzM0IH1cbiAgICAgIGNvbnN0IG5zZWMzMEFuZFNlY0hpZ2gyID0gdmlldy5nZXRVaW50MzIoMCk7XG4gICAgICBjb25zdCBzZWNMb3czMiA9IHZpZXcuZ2V0VWludDMyKDQpO1xuICAgICAgY29uc3Qgc2VjID0gKG5zZWMzMEFuZFNlY0hpZ2gyICYgMHgzKSAqIDB4MTAwMDAwMDAwICsgc2VjTG93MzI7XG4gICAgICBjb25zdCBuc2VjID0gbnNlYzMwQW5kU2VjSGlnaDIgPj4+IDI7XG4gICAgICByZXR1cm4geyBzZWMsIG5zZWMgfTtcbiAgICB9XG4gICAgY2FzZSAxMjoge1xuICAgICAgLy8gdGltZXN0YW1wIDk2ID0geyBuc2VjMzIgKHVuc2lnbmVkKSwgc2VjNjQgKHNpZ25lZCkgfVxuXG4gICAgICBjb25zdCBzZWMgPSBnZXRJbnQ2NCh2aWV3LCA0KTtcbiAgICAgIGNvbnN0IG5zZWMgPSB2aWV3LmdldFVpbnQzMigwKTtcbiAgICAgIHJldHVybiB7IHNlYywgbnNlYyB9O1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IERlY29kZUVycm9yKGBVbnJlY29nbml6ZWQgZGF0YSBzaXplIGZvciB0aW1lc3RhbXAgKGV4cGVjdGVkIDQsIDgsIG9yIDEyKTogJHtkYXRhLmxlbmd0aH1gKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVGltZXN0YW1wRXh0ZW5zaW9uKGRhdGE6IFVpbnQ4QXJyYXkpOiBEYXRlIHtcbiAgY29uc3QgdGltZVNwZWMgPSBkZWNvZGVUaW1lc3RhbXBUb1RpbWVTcGVjKGRhdGEpO1xuICByZXR1cm4gbmV3IERhdGUodGltZVNwZWMuc2VjICogMWUzICsgdGltZVNwZWMubnNlYyAvIDFlNik7XG59XG5cbmV4cG9ydCBjb25zdCB0aW1lc3RhbXBFeHRlbnNpb24gPSB7XG4gIHR5cGU6IEVYVF9USU1FU1RBTVAsXG4gIGVuY29kZTogZW5jb2RlVGltZXN0YW1wRXh0ZW5zaW9uLFxuICBkZWNvZGU6IGRlY29kZVRpbWVzdGFtcEV4dGVuc2lvbixcbn07XG4iLCAiLy8gRXh0ZW5zaW9uQ29kZWMgdG8gaGFuZGxlIE1lc3NhZ2VQYWNrIGV4dGVuc2lvbnNcblxuaW1wb3J0IHsgRXh0RGF0YSB9IGZyb20gXCIuL0V4dERhdGFcIjtcbmltcG9ydCB7IHRpbWVzdGFtcEV4dGVuc2lvbiB9IGZyb20gXCIuL3RpbWVzdGFtcFwiO1xuXG5leHBvcnQgdHlwZSBFeHRlbnNpb25EZWNvZGVyVHlwZTxDb250ZXh0VHlwZT4gPSAoXG4gIGRhdGE6IFVpbnQ4QXJyYXksXG4gIGV4dGVuc2lvblR5cGU6IG51bWJlcixcbiAgY29udGV4dDogQ29udGV4dFR5cGUsXG4pID0+IHVua25vd247XG5cbmV4cG9ydCB0eXBlIEV4dGVuc2lvbkVuY29kZXJUeXBlPENvbnRleHRUeXBlPiA9IChpbnB1dDogdW5rbm93biwgY29udGV4dDogQ29udGV4dFR5cGUpID0+IFVpbnQ4QXJyYXkgfCBudWxsO1xuXG4vLyBpbW11dGFibGUgaW50ZXJmYWNlIHRvIEV4dGVuc2lvbkNvZGVjXG5leHBvcnQgdHlwZSBFeHRlbnNpb25Db2RlY1R5cGU8Q29udGV4dFR5cGU+ID0ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gIF9fYnJhbmQ/OiBDb250ZXh0VHlwZTtcbiAgdHJ5VG9FbmNvZGUob2JqZWN0OiB1bmtub3duLCBjb250ZXh0OiBDb250ZXh0VHlwZSk6IEV4dERhdGEgfCBudWxsO1xuICBkZWNvZGUoZGF0YTogVWludDhBcnJheSwgZXh0VHlwZTogbnVtYmVyLCBjb250ZXh0OiBDb250ZXh0VHlwZSk6IHVua25vd247XG59O1xuXG5leHBvcnQgY2xhc3MgRXh0ZW5zaW9uQ29kZWM8Q29udGV4dFR5cGUgPSB1bmRlZmluZWQ+IGltcGxlbWVudHMgRXh0ZW5zaW9uQ29kZWNUeXBlPENvbnRleHRUeXBlPiB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgZGVmYXVsdENvZGVjOiBFeHRlbnNpb25Db2RlY1R5cGU8dW5kZWZpbmVkPiA9IG5ldyBFeHRlbnNpb25Db2RlYygpO1xuXG4gIC8vIGVuc3VyZXMgRXh0ZW5zaW9uQ29kZWNUeXBlPFg+IG1hdGNoZXMgRXh0ZW5zaW9uQ29kZWM8WD5cbiAgLy8gdGhpcyB3aWxsIG1ha2UgdHlwZSBlcnJvcnMgYSBsb3QgbW9yZSBjbGVhclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gIF9fYnJhbmQ/OiBDb250ZXh0VHlwZTtcblxuICAvLyBidWlsdC1pbiBleHRlbnNpb25zXG4gIHByaXZhdGUgcmVhZG9ubHkgYnVpbHRJbkVuY29kZXJzOiBBcnJheTxFeHRlbnNpb25FbmNvZGVyVHlwZTxDb250ZXh0VHlwZT4gfCB1bmRlZmluZWQgfCBudWxsPiA9IFtdO1xuICBwcml2YXRlIHJlYWRvbmx5IGJ1aWx0SW5EZWNvZGVyczogQXJyYXk8RXh0ZW5zaW9uRGVjb2RlclR5cGU8Q29udGV4dFR5cGU+IHwgdW5kZWZpbmVkIHwgbnVsbD4gPSBbXTtcblxuICAvLyBjdXN0b20gZXh0ZW5zaW9uc1xuICBwcml2YXRlIHJlYWRvbmx5IGVuY29kZXJzOiBBcnJheTxFeHRlbnNpb25FbmNvZGVyVHlwZTxDb250ZXh0VHlwZT4gfCB1bmRlZmluZWQgfCBudWxsPiA9IFtdO1xuICBwcml2YXRlIHJlYWRvbmx5IGRlY29kZXJzOiBBcnJheTxFeHRlbnNpb25EZWNvZGVyVHlwZTxDb250ZXh0VHlwZT4gfCB1bmRlZmluZWQgfCBudWxsPiA9IFtdO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJlZ2lzdGVyKHRpbWVzdGFtcEV4dGVuc2lvbik7XG4gIH1cblxuICBwdWJsaWMgcmVnaXN0ZXIoe1xuICAgIHR5cGUsXG4gICAgZW5jb2RlLFxuICAgIGRlY29kZSxcbiAgfToge1xuICAgIHR5cGU6IG51bWJlcjtcbiAgICBlbmNvZGU6IEV4dGVuc2lvbkVuY29kZXJUeXBlPENvbnRleHRUeXBlPjtcbiAgICBkZWNvZGU6IEV4dGVuc2lvbkRlY29kZXJUeXBlPENvbnRleHRUeXBlPjtcbiAgfSk6IHZvaWQge1xuICAgIGlmICh0eXBlID49IDApIHtcbiAgICAgIC8vIGN1c3RvbSBleHRlbnNpb25zXG4gICAgICB0aGlzLmVuY29kZXJzW3R5cGVdID0gZW5jb2RlO1xuICAgICAgdGhpcy5kZWNvZGVyc1t0eXBlXSA9IGRlY29kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYnVpbHQtaW4gZXh0ZW5zaW9uc1xuICAgICAgY29uc3QgaW5kZXggPSAxICsgdHlwZTtcbiAgICAgIHRoaXMuYnVpbHRJbkVuY29kZXJzW2luZGV4XSA9IGVuY29kZTtcbiAgICAgIHRoaXMuYnVpbHRJbkRlY29kZXJzW2luZGV4XSA9IGRlY29kZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdHJ5VG9FbmNvZGUob2JqZWN0OiB1bmtub3duLCBjb250ZXh0OiBDb250ZXh0VHlwZSk6IEV4dERhdGEgfCBudWxsIHtcbiAgICAvLyBidWlsdC1pbiBleHRlbnNpb25zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJ1aWx0SW5FbmNvZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZW5jb2RlRXh0ID0gdGhpcy5idWlsdEluRW5jb2RlcnNbaV07XG4gICAgICBpZiAoZW5jb2RlRXh0ICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGVuY29kZUV4dChvYmplY3QsIGNvbnRleHQpO1xuICAgICAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IC0xIC0gaTtcbiAgICAgICAgICByZXR1cm4gbmV3IEV4dERhdGEodHlwZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjdXN0b20gZXh0ZW5zaW9uc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lbmNvZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZW5jb2RlRXh0ID0gdGhpcy5lbmNvZGVyc1tpXTtcbiAgICAgIGlmIChlbmNvZGVFeHQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkYXRhID0gZW5jb2RlRXh0KG9iamVjdCwgY29udGV4dCk7XG4gICAgICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCB0eXBlID0gaTtcbiAgICAgICAgICByZXR1cm4gbmV3IEV4dERhdGEodHlwZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRXh0RGF0YSkge1xuICAgICAgLy8gdG8ga2VlcCBFeHREYXRhIGFzIGlzXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHB1YmxpYyBkZWNvZGUoZGF0YTogVWludDhBcnJheSwgdHlwZTogbnVtYmVyLCBjb250ZXh0OiBDb250ZXh0VHlwZSk6IHVua25vd24ge1xuICAgIGNvbnN0IGRlY29kZUV4dCA9IHR5cGUgPCAwID8gdGhpcy5idWlsdEluRGVjb2RlcnNbLTEgLSB0eXBlXSA6IHRoaXMuZGVjb2RlcnNbdHlwZV07XG4gICAgaWYgKGRlY29kZUV4dCkge1xuICAgICAgcmV0dXJuIGRlY29kZUV4dChkYXRhLCB0eXBlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGVjb2RlKCkgZG9lcyBub3QgZmFpbCwgcmV0dXJucyBFeHREYXRhIGluc3RlYWQuXG4gICAgICByZXR1cm4gbmV3IEV4dERhdGEodHlwZSwgZGF0YSk7XG4gICAgfVxuICB9XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVVpbnQ4QXJyYXkoYnVmZmVyOiBBcnJheUxpa2U8bnVtYmVyPiB8IFVpbnQ4QXJyYXkgfCBBcnJheUJ1ZmZlclZpZXcgfCBBcnJheUJ1ZmZlcik6IFVpbnQ4QXJyYXkge1xuICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBidWZmZXI7XG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmJ1ZmZlciwgYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIEFycmF5TGlrZTxudW1iZXI+XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShidWZmZXIpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEYXRhVmlldyhidWZmZXI6IEFycmF5TGlrZTxudW1iZXI+IHwgQXJyYXlCdWZmZXJWaWV3IHwgQXJyYXlCdWZmZXIpOiBEYXRhVmlldyB7XG4gIGlmIChidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlclZpZXcgPSBlbnN1cmVVaW50OEFycmF5KGJ1ZmZlcik7XG4gIHJldHVybiBuZXcgRGF0YVZpZXcoYnVmZmVyVmlldy5idWZmZXIsIGJ1ZmZlclZpZXcuYnl0ZU9mZnNldCwgYnVmZmVyVmlldy5ieXRlTGVuZ3RoKTtcbn1cbiIsICJpbXBvcnQgeyB1dGY4RW5jb2RlSnMsIHV0ZjhDb3VudCwgVEVYVF9FTkNPREVSX1RIUkVTSE9MRCwgdXRmOEVuY29kZVRFIH0gZnJvbSBcIi4vdXRpbHMvdXRmOFwiO1xuaW1wb3J0IHsgRXh0ZW5zaW9uQ29kZWMsIEV4dGVuc2lvbkNvZGVjVHlwZSB9IGZyb20gXCIuL0V4dGVuc2lvbkNvZGVjXCI7XG5pbXBvcnQgeyBzZXRJbnQ2NCwgc2V0VWludDY0IH0gZnJvbSBcIi4vdXRpbHMvaW50XCI7XG5pbXBvcnQgeyBlbnN1cmVVaW50OEFycmF5IH0gZnJvbSBcIi4vdXRpbHMvdHlwZWRBcnJheXNcIjtcbmltcG9ydCB0eXBlIHsgRXh0RGF0YSB9IGZyb20gXCIuL0V4dERhdGFcIjtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfTUFYX0RFUFRIID0gMTAwO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfSU5JVElBTF9CVUZGRVJfU0laRSA9IDIwNDg7XG5cbmV4cG9ydCBjbGFzcyBFbmNvZGVyPENvbnRleHRUeXBlID0gdW5kZWZpbmVkPiB7XG4gIHByaXZhdGUgcG9zID0gMDtcbiAgcHJpdmF0ZSB2aWV3ID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcih0aGlzLmluaXRpYWxCdWZmZXJTaXplKSk7XG4gIHByaXZhdGUgYnl0ZXMgPSBuZXcgVWludDhBcnJheSh0aGlzLnZpZXcuYnVmZmVyKTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBleHRlbnNpb25Db2RlYzogRXh0ZW5zaW9uQ29kZWNUeXBlPENvbnRleHRUeXBlPiA9IEV4dGVuc2lvbkNvZGVjLmRlZmF1bHRDb2RlYyBhcyBhbnksXG4gICAgcHJpdmF0ZSByZWFkb25seSBjb250ZXh0OiBDb250ZXh0VHlwZSA9IHVuZGVmaW5lZCBhcyBhbnksXG4gICAgcHJpdmF0ZSByZWFkb25seSBtYXhEZXB0aCA9IERFRkFVTFRfTUFYX0RFUFRILFxuICAgIHByaXZhdGUgcmVhZG9ubHkgaW5pdGlhbEJ1ZmZlclNpemUgPSBERUZBVUxUX0lOSVRJQUxfQlVGRkVSX1NJWkUsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzb3J0S2V5cyA9IGZhbHNlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZm9yY2VGbG9hdDMyID0gZmFsc2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBpZ25vcmVVbmRlZmluZWQgPSBmYWxzZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZvcmNlSW50ZWdlclRvRmxvYXQgPSBmYWxzZSxcbiAgKSB7fVxuXG4gIHByaXZhdGUgcmVpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgdGhpcy5wb3MgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYWxtb3N0IGVxdWl2YWxlbnQgdG8ge0BsaW5rIEVuY29kZXIjZW5jb2RlfSwgYnV0IGl0IHJldHVybnMgYW4gcmVmZXJlbmNlIG9mIHRoZSBlbmNvZGVyJ3MgaW50ZXJuYWwgYnVmZmVyIGFuZCB0aHVzIG11Y2ggZmFzdGVyIHRoYW4ge0BsaW5rIEVuY29kZXIjZW5jb2RlfS5cbiAgICpcbiAgICogQHJldHVybnMgRW5jb2RlcyB0aGUgb2JqZWN0IGFuZCByZXR1cm5zIGEgc2hhcmVkIHJlZmVyZW5jZSB0aGUgZW5jb2RlcidzIGludGVybmFsIGJ1ZmZlci5cbiAgICovXG4gIHB1YmxpYyBlbmNvZGVTaGFyZWRSZWYob2JqZWN0OiB1bmtub3duKTogVWludDhBcnJheSB7XG4gICAgdGhpcy5yZWluaXRpYWxpemVTdGF0ZSgpO1xuICAgIHRoaXMuZG9FbmNvZGUob2JqZWN0LCAxKTtcbiAgICByZXR1cm4gdGhpcy5ieXRlcy5zdWJhcnJheSgwLCB0aGlzLnBvcyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgRW5jb2RlcyB0aGUgb2JqZWN0IGFuZCByZXR1cm5zIGEgY29weSBvZiB0aGUgZW5jb2RlcidzIGludGVybmFsIGJ1ZmZlci5cbiAgICovXG4gIHB1YmxpYyBlbmNvZGUob2JqZWN0OiB1bmtub3duKTogVWludDhBcnJheSB7XG4gICAgdGhpcy5yZWluaXRpYWxpemVTdGF0ZSgpO1xuICAgIHRoaXMuZG9FbmNvZGUob2JqZWN0LCAxKTtcbiAgICByZXR1cm4gdGhpcy5ieXRlcy5zbGljZSgwLCB0aGlzLnBvcyk7XG4gIH1cblxuICBwcml2YXRlIGRvRW5jb2RlKG9iamVjdDogdW5rbm93biwgZGVwdGg6IG51bWJlcik6IHZvaWQge1xuICAgIGlmIChkZXB0aCA+IHRoaXMubWF4RGVwdGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vIGRlZXAgb2JqZWN0cyBpbiBkZXB0aCAke2RlcHRofWApO1xuICAgIH1cblxuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgdGhpcy5lbmNvZGVOaWwoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICB0aGlzLmVuY29kZUJvb2xlYW4ob2JqZWN0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRoaXMuZW5jb2RlTnVtYmVyKG9iamVjdCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmVuY29kZVN0cmluZyhvYmplY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVuY29kZU9iamVjdChvYmplY3QsIGRlcHRoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKHNpemVUb1dyaXRlOiBudW1iZXIpIHtcbiAgICBjb25zdCByZXF1aXJlZFNpemUgPSB0aGlzLnBvcyArIHNpemVUb1dyaXRlO1xuXG4gICAgaWYgKHRoaXMudmlldy5ieXRlTGVuZ3RoIDwgcmVxdWlyZWRTaXplKSB7XG4gICAgICB0aGlzLnJlc2l6ZUJ1ZmZlcihyZXF1aXJlZFNpemUgKiAyKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlc2l6ZUJ1ZmZlcihuZXdTaXplOiBudW1iZXIpIHtcbiAgICBjb25zdCBuZXdCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIobmV3U2l6ZSk7XG4gICAgY29uc3QgbmV3Qnl0ZXMgPSBuZXcgVWludDhBcnJheShuZXdCdWZmZXIpO1xuICAgIGNvbnN0IG5ld1ZpZXcgPSBuZXcgRGF0YVZpZXcobmV3QnVmZmVyKTtcblxuICAgIG5ld0J5dGVzLnNldCh0aGlzLmJ5dGVzKTtcblxuICAgIHRoaXMudmlldyA9IG5ld1ZpZXc7XG4gICAgdGhpcy5ieXRlcyA9IG5ld0J5dGVzO1xuICB9XG5cbiAgcHJpdmF0ZSBlbmNvZGVOaWwoKSB7XG4gICAgdGhpcy53cml0ZVU4KDB4YzApO1xuICB9XG5cbiAgcHJpdmF0ZSBlbmNvZGVCb29sZWFuKG9iamVjdDogYm9vbGVhbikge1xuICAgIGlmIChvYmplY3QgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLndyaXRlVTgoMHhjMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud3JpdGVVOCgweGMzKTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBlbmNvZGVOdW1iZXIob2JqZWN0OiBudW1iZXIpIHtcbiAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIob2JqZWN0KSAmJiAhdGhpcy5mb3JjZUludGVnZXJUb0Zsb2F0KSB7XG4gICAgICBpZiAob2JqZWN0ID49IDApIHtcbiAgICAgICAgaWYgKG9iamVjdCA8IDB4ODApIHtcbiAgICAgICAgICAvLyBwb3NpdGl2ZSBmaXhpbnRcbiAgICAgICAgICB0aGlzLndyaXRlVTgob2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3QgPCAweDEwMCkge1xuICAgICAgICAgIC8vIHVpbnQgOFxuICAgICAgICAgIHRoaXMud3JpdGVVOCgweGNjKTtcbiAgICAgICAgICB0aGlzLndyaXRlVTgob2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3QgPCAweDEwMDAwKSB7XG4gICAgICAgICAgLy8gdWludCAxNlxuICAgICAgICAgIHRoaXMud3JpdGVVOCgweGNkKTtcbiAgICAgICAgICB0aGlzLndyaXRlVTE2KG9iamVjdCk7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqZWN0IDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAvLyB1aW50IDMyXG4gICAgICAgICAgdGhpcy53cml0ZVU4KDB4Y2UpO1xuICAgICAgICAgIHRoaXMud3JpdGVVMzIob2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1aW50IDY0XG4gICAgICAgICAgdGhpcy53cml0ZVU4KDB4Y2YpO1xuICAgICAgICAgIHRoaXMud3JpdGVVNjQob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9iamVjdCA+PSAtMHgyMCkge1xuICAgICAgICAgIC8vIG5lZ2F0aXZlIGZpeGludFxuICAgICAgICAgIHRoaXMud3JpdGVVOCgweGUwIHwgKG9iamVjdCArIDB4MjApKTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3QgPj0gLTB4ODApIHtcbiAgICAgICAgICAvLyBpbnQgOFxuICAgICAgICAgIHRoaXMud3JpdGVVOCgweGQwKTtcbiAgICAgICAgICB0aGlzLndyaXRlSTgob2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3QgPj0gLTB4ODAwMCkge1xuICAgICAgICAgIC8vIGludCAxNlxuICAgICAgICAgIHRoaXMud3JpdGVVOCgweGQxKTtcbiAgICAgICAgICB0aGlzLndyaXRlSTE2KG9iamVjdCk7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqZWN0ID49IC0weDgwMDAwMDAwKSB7XG4gICAgICAgICAgLy8gaW50IDMyXG4gICAgICAgICAgdGhpcy53cml0ZVU4KDB4ZDIpO1xuICAgICAgICAgIHRoaXMud3JpdGVJMzIob2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpbnQgNjRcbiAgICAgICAgICB0aGlzLndyaXRlVTgoMHhkMyk7XG4gICAgICAgICAgdGhpcy53cml0ZUk2NChvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vbi1pbnRlZ2VyIG51bWJlcnNcbiAgICAgIGlmICh0aGlzLmZvcmNlRmxvYXQzMikge1xuICAgICAgICAvLyBmbG9hdCAzMlxuICAgICAgICB0aGlzLndyaXRlVTgoMHhjYSk7XG4gICAgICAgIHRoaXMud3JpdGVGMzIob2JqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZsb2F0IDY0XG4gICAgICAgIHRoaXMud3JpdGVVOCgweGNiKTtcbiAgICAgICAgdGhpcy53cml0ZUY2NChvYmplY3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgd3JpdGVTdHJpbmdIZWFkZXIoYnl0ZUxlbmd0aDogbnVtYmVyKSB7XG4gICAgaWYgKGJ5dGVMZW5ndGggPCAzMikge1xuICAgICAgLy8gZml4c3RyXG4gICAgICB0aGlzLndyaXRlVTgoMHhhMCArIGJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoYnl0ZUxlbmd0aCA8IDB4MTAwKSB7XG4gICAgICAvLyBzdHIgOFxuICAgICAgdGhpcy53cml0ZVU4KDB4ZDkpO1xuICAgICAgdGhpcy53cml0ZVU4KGJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoYnl0ZUxlbmd0aCA8IDB4MTAwMDApIHtcbiAgICAgIC8vIHN0ciAxNlxuICAgICAgdGhpcy53cml0ZVU4KDB4ZGEpO1xuICAgICAgdGhpcy53cml0ZVUxNihieXRlTGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKGJ5dGVMZW5ndGggPCAweDEwMDAwMDAwMCkge1xuICAgICAgLy8gc3RyIDMyXG4gICAgICB0aGlzLndyaXRlVTgoMHhkYik7XG4gICAgICB0aGlzLndyaXRlVTMyKGJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvbyBsb25nIHN0cmluZzogJHtieXRlTGVuZ3RofSBieXRlcyBpbiBVVEYtOGApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZW5jb2RlU3RyaW5nKG9iamVjdDogc3RyaW5nKSB7XG4gICAgY29uc3QgbWF4SGVhZGVyU2l6ZSA9IDEgKyA0O1xuICAgIGNvbnN0IHN0ckxlbmd0aCA9IG9iamVjdC5sZW5ndGg7XG5cbiAgICBpZiAoc3RyTGVuZ3RoID4gVEVYVF9FTkNPREVSX1RIUkVTSE9MRCkge1xuICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IHV0ZjhDb3VudChvYmplY3QpO1xuICAgICAgdGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZShtYXhIZWFkZXJTaXplICsgYnl0ZUxlbmd0aCk7XG4gICAgICB0aGlzLndyaXRlU3RyaW5nSGVhZGVyKGJ5dGVMZW5ndGgpO1xuICAgICAgdXRmOEVuY29kZVRFKG9iamVjdCwgdGhpcy5ieXRlcywgdGhpcy5wb3MpO1xuICAgICAgdGhpcy5wb3MgKz0gYnl0ZUxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IHV0ZjhDb3VudChvYmplY3QpO1xuICAgICAgdGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZShtYXhIZWFkZXJTaXplICsgYnl0ZUxlbmd0aCk7XG4gICAgICB0aGlzLndyaXRlU3RyaW5nSGVhZGVyKGJ5dGVMZW5ndGgpO1xuICAgICAgdXRmOEVuY29kZUpzKG9iamVjdCwgdGhpcy5ieXRlcywgdGhpcy5wb3MpO1xuICAgICAgdGhpcy5wb3MgKz0gYnl0ZUxlbmd0aDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGVuY29kZU9iamVjdChvYmplY3Q6IHVua25vd24sIGRlcHRoOiBudW1iZXIpIHtcbiAgICAvLyB0cnkgdG8gZW5jb2RlIG9iamVjdHMgd2l0aCBjdXN0b20gY29kZWMgZmlyc3Qgb2Ygbm9uLXByaW1pdGl2ZXNcbiAgICBjb25zdCBleHQgPSB0aGlzLmV4dGVuc2lvbkNvZGVjLnRyeVRvRW5jb2RlKG9iamVjdCwgdGhpcy5jb250ZXh0KTtcbiAgICBpZiAoZXh0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZW5jb2RlRXh0ZW5zaW9uKGV4dCk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgIHRoaXMuZW5jb2RlQXJyYXkob2JqZWN0LCBkZXB0aCk7XG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcob2JqZWN0KSkge1xuICAgICAgdGhpcy5lbmNvZGVCaW5hcnkob2JqZWN0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRoaXMuZW5jb2RlTWFwKG9iamVjdCBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiwgZGVwdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzeW1ib2wsIGZ1bmN0aW9uIGFuZCBvdGhlciBzcGVjaWFsIG9iamVjdCBjb21lIGhlcmUgdW5sZXNzIGV4dGVuc2lvbkNvZGVjIGhhbmRsZXMgdGhlbS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIG9iamVjdDogJHtPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KG9iamVjdCl9YCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBlbmNvZGVCaW5hcnkob2JqZWN0OiBBcnJheUJ1ZmZlclZpZXcpIHtcbiAgICBjb25zdCBzaXplID0gb2JqZWN0LmJ5dGVMZW5ndGg7XG4gICAgaWYgKHNpemUgPCAweDEwMCkge1xuICAgICAgLy8gYmluIDhcbiAgICAgIHRoaXMud3JpdGVVOCgweGM0KTtcbiAgICAgIHRoaXMud3JpdGVVOChzaXplKTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMDAwKSB7XG4gICAgICAvLyBiaW4gMTZcbiAgICAgIHRoaXMud3JpdGVVOCgweGM1KTtcbiAgICAgIHRoaXMud3JpdGVVMTYoc2l6ZSk7XG4gICAgfSBlbHNlIGlmIChzaXplIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgIC8vIGJpbiAzMlxuICAgICAgdGhpcy53cml0ZVU4KDB4YzYpO1xuICAgICAgdGhpcy53cml0ZVUzMihzaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb28gbGFyZ2UgYmluYXJ5OiAke3NpemV9YCk7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gZW5zdXJlVWludDhBcnJheShvYmplY3QpO1xuICAgIHRoaXMud3JpdGVVOGEoYnl0ZXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBlbmNvZGVBcnJheShvYmplY3Q6IEFycmF5PHVua25vd24+LCBkZXB0aDogbnVtYmVyKSB7XG4gICAgY29uc3Qgc2l6ZSA9IG9iamVjdC5sZW5ndGg7XG4gICAgaWYgKHNpemUgPCAxNikge1xuICAgICAgLy8gZml4YXJyYXlcbiAgICAgIHRoaXMud3JpdGVVOCgweDkwICsgc2l6ZSk7XG4gICAgfSBlbHNlIGlmIChzaXplIDwgMHgxMDAwMCkge1xuICAgICAgLy8gYXJyYXkgMTZcbiAgICAgIHRoaXMud3JpdGVVOCgweGRjKTtcbiAgICAgIHRoaXMud3JpdGVVMTYoc2l6ZSk7XG4gICAgfSBlbHNlIGlmIChzaXplIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgIC8vIGFycmF5IDMyXG4gICAgICB0aGlzLndyaXRlVTgoMHhkZCk7XG4gICAgICB0aGlzLndyaXRlVTMyKHNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvbyBsYXJnZSBhcnJheTogJHtzaXplfWApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygb2JqZWN0KSB7XG4gICAgICB0aGlzLmRvRW5jb2RlKGl0ZW0sIGRlcHRoICsgMSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb3VudFdpdGhvdXRVbmRlZmluZWQob2JqZWN0OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiwga2V5czogUmVhZG9ubHlBcnJheTxzdHJpbmc+KTogbnVtYmVyIHtcbiAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgaWYgKG9iamVjdFtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cblxuICBwcml2YXRlIGVuY29kZU1hcChvYmplY3Q6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LCBkZXB0aDogbnVtYmVyKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgaWYgKHRoaXMuc29ydEtleXMpIHtcbiAgICAgIGtleXMuc29ydCgpO1xuICAgIH1cblxuICAgIGNvbnN0IHNpemUgPSB0aGlzLmlnbm9yZVVuZGVmaW5lZCA/IHRoaXMuY291bnRXaXRob3V0VW5kZWZpbmVkKG9iamVjdCwga2V5cykgOiBrZXlzLmxlbmd0aDtcblxuICAgIGlmIChzaXplIDwgMTYpIHtcbiAgICAgIC8vIGZpeG1hcFxuICAgICAgdGhpcy53cml0ZVU4KDB4ODAgKyBzaXplKTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMDAwKSB7XG4gICAgICAvLyBtYXAgMTZcbiAgICAgIHRoaXMud3JpdGVVOCgweGRlKTtcbiAgICAgIHRoaXMud3JpdGVVMTYoc2l6ZSk7XG4gICAgfSBlbHNlIGlmIChzaXplIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgIC8vIG1hcCAzMlxuICAgICAgdGhpcy53cml0ZVU4KDB4ZGYpO1xuICAgICAgdGhpcy53cml0ZVUzMihzaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb28gbGFyZ2UgbWFwIG9iamVjdDogJHtzaXplfWApO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgIGlmICghKHRoaXMuaWdub3JlVW5kZWZpbmVkICYmIHZhbHVlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHRoaXMuZW5jb2RlU3RyaW5nKGtleSk7XG4gICAgICAgIHRoaXMuZG9FbmNvZGUodmFsdWUsIGRlcHRoICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBlbmNvZGVFeHRlbnNpb24oZXh0OiBFeHREYXRhKSB7XG4gICAgY29uc3Qgc2l6ZSA9IGV4dC5kYXRhLmxlbmd0aDtcbiAgICBpZiAoc2l6ZSA9PT0gMSkge1xuICAgICAgLy8gZml4ZXh0IDFcbiAgICAgIHRoaXMud3JpdGVVOCgweGQ0KTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPT09IDIpIHtcbiAgICAgIC8vIGZpeGV4dCAyXG4gICAgICB0aGlzLndyaXRlVTgoMHhkNSk7XG4gICAgfSBlbHNlIGlmIChzaXplID09PSA0KSB7XG4gICAgICAvLyBmaXhleHQgNFxuICAgICAgdGhpcy53cml0ZVU4KDB4ZDYpO1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gOCkge1xuICAgICAgLy8gZml4ZXh0IDhcbiAgICAgIHRoaXMud3JpdGVVOCgweGQ3KTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPT09IDE2KSB7XG4gICAgICAvLyBmaXhleHQgMTZcbiAgICAgIHRoaXMud3JpdGVVOCgweGQ4KTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMCkge1xuICAgICAgLy8gZXh0IDhcbiAgICAgIHRoaXMud3JpdGVVOCgweGM3KTtcbiAgICAgIHRoaXMud3JpdGVVOChzaXplKTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMDAwKSB7XG4gICAgICAvLyBleHQgMTZcbiAgICAgIHRoaXMud3JpdGVVOCgweGM4KTtcbiAgICAgIHRoaXMud3JpdGVVMTYoc2l6ZSk7XG4gICAgfSBlbHNlIGlmIChzaXplIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgIC8vIGV4dCAzMlxuICAgICAgdGhpcy53cml0ZVU4KDB4YzkpO1xuICAgICAgdGhpcy53cml0ZVUzMihzaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb28gbGFyZ2UgZXh0ZW5zaW9uIG9iamVjdDogJHtzaXplfWApO1xuICAgIH1cbiAgICB0aGlzLndyaXRlSTgoZXh0LnR5cGUpO1xuICAgIHRoaXMud3JpdGVVOGEoZXh0LmRhdGEpO1xuICB9XG5cbiAgcHJpdmF0ZSB3cml0ZVU4KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDEpO1xuXG4gICAgdGhpcy52aWV3LnNldFVpbnQ4KHRoaXMucG9zLCB2YWx1ZSk7XG4gICAgdGhpcy5wb3MrKztcbiAgfVxuXG4gIHByaXZhdGUgd3JpdGVVOGEodmFsdWVzOiBBcnJheUxpa2U8bnVtYmVyPikge1xuICAgIGNvbnN0IHNpemUgPSB2YWx1ZXMubGVuZ3RoO1xuICAgIHRoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoc2l6ZSk7XG5cbiAgICB0aGlzLmJ5dGVzLnNldCh2YWx1ZXMsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSBzaXplO1xuICB9XG5cbiAgcHJpdmF0ZSB3cml0ZUk4KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDEpO1xuXG4gICAgdGhpcy52aWV3LnNldEludDgodGhpcy5wb3MsIHZhbHVlKTtcbiAgICB0aGlzLnBvcysrO1xuICB9XG5cbiAgcHJpdmF0ZSB3cml0ZVUxNih2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSgyKTtcblxuICAgIHRoaXMudmlldy5zZXRVaW50MTYodGhpcy5wb3MsIHZhbHVlKTtcbiAgICB0aGlzLnBvcyArPSAyO1xuICB9XG5cbiAgcHJpdmF0ZSB3cml0ZUkxNih2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSgyKTtcblxuICAgIHRoaXMudmlldy5zZXRJbnQxNih0aGlzLnBvcywgdmFsdWUpO1xuICAgIHRoaXMucG9zICs9IDI7XG4gIH1cblxuICBwcml2YXRlIHdyaXRlVTMyKHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDQpO1xuXG4gICAgdGhpcy52aWV3LnNldFVpbnQzMih0aGlzLnBvcywgdmFsdWUpO1xuICAgIHRoaXMucG9zICs9IDQ7XG4gIH1cblxuICBwcml2YXRlIHdyaXRlSTMyKHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDQpO1xuXG4gICAgdGhpcy52aWV3LnNldEludDMyKHRoaXMucG9zLCB2YWx1ZSk7XG4gICAgdGhpcy5wb3MgKz0gNDtcbiAgfVxuXG4gIHByaXZhdGUgd3JpdGVGMzIodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoNCk7XG4gICAgdGhpcy52aWV3LnNldEZsb2F0MzIodGhpcy5wb3MsIHZhbHVlKTtcbiAgICB0aGlzLnBvcyArPSA0O1xuICB9XG5cbiAgcHJpdmF0ZSB3cml0ZUY2NCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSg4KTtcbiAgICB0aGlzLnZpZXcuc2V0RmxvYXQ2NCh0aGlzLnBvcywgdmFsdWUpO1xuICAgIHRoaXMucG9zICs9IDg7XG4gIH1cblxuICBwcml2YXRlIHdyaXRlVTY0KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDgpO1xuXG4gICAgc2V0VWludDY0KHRoaXMudmlldywgdGhpcy5wb3MsIHZhbHVlKTtcbiAgICB0aGlzLnBvcyArPSA4O1xuICB9XG5cbiAgcHJpdmF0ZSB3cml0ZUk2NCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSg4KTtcblxuICAgIHNldEludDY0KHRoaXMudmlldywgdGhpcy5wb3MsIHZhbHVlKTtcbiAgICB0aGlzLnBvcyArPSA4O1xuICB9XG59XG4iLCAiaW1wb3J0IHsgRW5jb2RlciB9IGZyb20gXCIuL0VuY29kZXJcIjtcbmltcG9ydCB0eXBlIHsgRXh0ZW5zaW9uQ29kZWNUeXBlIH0gZnJvbSBcIi4vRXh0ZW5zaW9uQ29kZWNcIjtcbmltcG9ydCB0eXBlIHsgQ29udGV4dE9mLCBTcGxpdFVuZGVmaW5lZCB9IGZyb20gXCIuL2NvbnRleHRcIjtcblxuZXhwb3J0IHR5cGUgRW5jb2RlT3B0aW9uczxDb250ZXh0VHlwZSA9IHVuZGVmaW5lZD4gPSBQYXJ0aWFsPFxuICBSZWFkb25seTx7XG4gICAgZXh0ZW5zaW9uQ29kZWM6IEV4dGVuc2lvbkNvZGVjVHlwZTxDb250ZXh0VHlwZT47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBkZXB0aCBpbiBuZXN0ZWQgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAqXG4gICAgICogRGVmYXVsdHMgdG8gMTAwLlxuICAgICAqL1xuICAgIG1heERlcHRoOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5pdGlhbCBzaXplIG9mIHRoZSBpbnRlcm5hbCBidWZmZXIuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0byAyMDQ4LlxuICAgICAqL1xuICAgIGluaXRpYWxCdWZmZXJTaXplOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIHRoZSBrZXlzIG9mIGFuIG9iamVjdCBpcyBzb3J0ZWQuIEluIG90aGVyIHdvcmRzLCB0aGUgZW5jb2RlZFxuICAgICAqIGJpbmFyeSBpcyBjYW5vbmljYWwgYW5kIHRodXMgY29tcGFyYWJsZSB0byBhbm90aGVyIGVuY29kZWQgYmluYXJ5LlxuICAgICAqXG4gICAgICogRGVmYXVsdHMgdG8gYGZhbHNlYC4gSWYgZW5hYmxlZCwgaXQgc3BlbmRzIG1vcmUgdGltZSBpbiBlbmNvZGluZyBvYmplY3RzLlxuICAgICAqL1xuICAgIHNvcnRLZXlzOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgbm9uLWludGVnZXIgbnVtYmVycyBhcmUgZW5jb2RlZCBpbiBmbG9hdDMyLCBub3QgaW4gZmxvYXQ2NCAodGhlIGRlZmF1bHQpLlxuICAgICAqXG4gICAgICogT25seSB1c2UgaXQgaWYgcHJlY2lzaW9ucyBkb24ndCBtYXR0ZXIuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZvcmNlRmxvYXQzMjogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgYW4gb2JqZWN0IHByb3BlcnR5IHdpdGggYHVuZGVmaW5lZGAgdmFsdWUgYXJlIGlnbm9yZWQuXG4gICAgICogZS5nLiBgeyBmb286IHVuZGVmaW5lZCB9YCB3aWxsIGJlIGVuY29kZWQgYXMgYHt9YCwgYXMgYEpTT04uc3RyaW5naWZ5KClgIGRvZXMuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLiBJZiBlbmFibGVkLCBpdCBzcGVuZHMgbW9yZSB0aW1lIGluIGVuY29kaW5nIG9iamVjdHMuXG4gICAgICovXG4gICAgaWdub3JlVW5kZWZpbmVkOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCBpbnRlZ2VyIG51bWJlcnMgYXJlIGVuY29kZWQgYXMgZmxvYXRpbmcgcG9pbnQgbnVtYmVycyxcbiAgICAgKiB3aXRoIHRoZSBgZm9yY2VGbG9hdDMyYCBvcHRpb24gdGFrZW4gaW50byBhY2NvdW50LlxuICAgICAqXG4gICAgICogRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmb3JjZUludGVnZXJUb0Zsb2F0OiBib29sZWFuO1xuICB9PlxuPiAmXG4gIENvbnRleHRPZjxDb250ZXh0VHlwZT47XG5cbmNvbnN0IGRlZmF1bHRFbmNvZGVPcHRpb25zOiBFbmNvZGVPcHRpb25zID0ge307XG5cbi8qKlxuICogSXQgZW5jb2RlcyBgdmFsdWVgIGluIHRoZSBNZXNzYWdlUGFjayBmb3JtYXQgYW5kXG4gKiByZXR1cm5zIGEgYnl0ZSBidWZmZXIuXG4gKlxuICogVGhlIHJldHVybmVkIGJ1ZmZlciBpcyBhIHNsaWNlIG9mIGEgbGFyZ2VyIGBBcnJheUJ1ZmZlcmAsIHNvIHlvdSBoYXZlIHRvIHVzZSBpdHMgYCNieXRlT2Zmc2V0YCBhbmQgYCNieXRlTGVuZ3RoYCBpbiBvcmRlciB0byBjb252ZXJ0IGl0IHRvIGFub3RoZXIgdHlwZWQgYXJyYXlzIGluY2x1ZGluZyBOb2RlSlMgYEJ1ZmZlcmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGU8Q29udGV4dFR5cGUgPSB1bmRlZmluZWQ+KFxuICB2YWx1ZTogdW5rbm93bixcbiAgb3B0aW9uczogRW5jb2RlT3B0aW9uczxTcGxpdFVuZGVmaW5lZDxDb250ZXh0VHlwZT4+ID0gZGVmYXVsdEVuY29kZU9wdGlvbnMgYXMgYW55LFxuKTogVWludDhBcnJheSB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgRW5jb2RlcihcbiAgICBvcHRpb25zLmV4dGVuc2lvbkNvZGVjLFxuICAgIChvcHRpb25zIGFzIHR5cGVvZiBvcHRpb25zICYgeyBjb250ZXh0OiBhbnkgfSkuY29udGV4dCxcbiAgICBvcHRpb25zLm1heERlcHRoLFxuICAgIG9wdGlvbnMuaW5pdGlhbEJ1ZmZlclNpemUsXG4gICAgb3B0aW9ucy5zb3J0S2V5cyxcbiAgICBvcHRpb25zLmZvcmNlRmxvYXQzMixcbiAgICBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZCxcbiAgICBvcHRpb25zLmZvcmNlSW50ZWdlclRvRmxvYXQsXG4gICk7XG4gIHJldHVybiBlbmNvZGVyLmVuY29kZVNoYXJlZFJlZih2YWx1ZSk7XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIHByZXR0eUJ5dGUoYnl0ZTogbnVtYmVyKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke2J5dGUgPCAwID8gXCItXCIgOiBcIlwifTB4JHtNYXRoLmFicyhieXRlKS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpfWA7XG59XG4iLCAiaW1wb3J0IHsgdXRmOERlY29kZUpzIH0gZnJvbSBcIi4vdXRpbHMvdXRmOFwiO1xuXG5jb25zdCBERUZBVUxUX01BWF9LRVlfTEVOR1RIID0gMTY7XG5jb25zdCBERUZBVUxUX01BWF9MRU5HVEhfUEVSX0tFWSA9IDE2O1xuXG5leHBvcnQgaW50ZXJmYWNlIEtleURlY29kZXIge1xuICBjYW5CZUNhY2hlZChieXRlTGVuZ3RoOiBudW1iZXIpOiBib29sZWFuO1xuICBkZWNvZGUoYnl0ZXM6IFVpbnQ4QXJyYXksIGlucHV0T2Zmc2V0OiBudW1iZXIsIGJ5dGVMZW5ndGg6IG51bWJlcik6IHN0cmluZztcbn1cbmludGVyZmFjZSBLZXlDYWNoZVJlY29yZCB7XG4gIHJlYWRvbmx5IGJ5dGVzOiBVaW50OEFycmF5O1xuICByZWFkb25seSBzdHI6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIENhY2hlZEtleURlY29kZXIgaW1wbGVtZW50cyBLZXlEZWNvZGVyIHtcbiAgaGl0ID0gMDtcbiAgbWlzcyA9IDA7XG4gIHByaXZhdGUgcmVhZG9ubHkgY2FjaGVzOiBBcnJheTxBcnJheTxLZXlDYWNoZVJlY29yZD4+O1xuXG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IG1heEtleUxlbmd0aCA9IERFRkFVTFRfTUFYX0tFWV9MRU5HVEgsIHJlYWRvbmx5IG1heExlbmd0aFBlcktleSA9IERFRkFVTFRfTUFYX0xFTkdUSF9QRVJfS0VZKSB7XG4gICAgLy8gYXZvaWQgYG5ldyBBcnJheShOKWAsIHdoaWNoIG1ha2VzIGEgc3BhcnNlIGFycmF5LFxuICAgIC8vIGJlY2F1c2UgYSBzcGFyc2UgYXJyYXkgaXMgdHlwaWNhbGx5IHNsb3dlciB0aGFuIGEgbm9uLXNwYXJzZSBhcnJheS5cbiAgICB0aGlzLmNhY2hlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXhLZXlMZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5jYWNoZXMucHVzaChbXSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGNhbkJlQ2FjaGVkKGJ5dGVMZW5ndGg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBieXRlTGVuZ3RoID4gMCAmJiBieXRlTGVuZ3RoIDw9IHRoaXMubWF4S2V5TGVuZ3RoO1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5kKGJ5dGVzOiBVaW50OEFycmF5LCBpbnB1dE9mZnNldDogbnVtYmVyLCBieXRlTGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcgfCBudWxsIHtcbiAgICBjb25zdCByZWNvcmRzID0gdGhpcy5jYWNoZXNbYnl0ZUxlbmd0aCAtIDFdITtcblxuICAgIEZJTkRfQ0hVTks6IGZvciAoY29uc3QgcmVjb3JkIG9mIHJlY29yZHMpIHtcbiAgICAgIGNvbnN0IHJlY29yZEJ5dGVzID0gcmVjb3JkLmJ5dGVzO1xuXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJ5dGVMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVjb3JkQnl0ZXNbal0gIT09IGJ5dGVzW2lucHV0T2Zmc2V0ICsgal0pIHtcbiAgICAgICAgICBjb250aW51ZSBGSU5EX0NIVU5LO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVjb3JkLnN0cjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBwcml2YXRlIHN0b3JlKGJ5dGVzOiBVaW50OEFycmF5LCB2YWx1ZTogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVjb3JkcyA9IHRoaXMuY2FjaGVzW2J5dGVzLmxlbmd0aCAtIDFdITtcbiAgICBjb25zdCByZWNvcmQ6IEtleUNhY2hlUmVjb3JkID0geyBieXRlcywgc3RyOiB2YWx1ZSB9O1xuXG4gICAgaWYgKHJlY29yZHMubGVuZ3RoID49IHRoaXMubWF4TGVuZ3RoUGVyS2V5KSB7XG4gICAgICAvLyBgcmVjb3Jkc2AgYXJlIGZ1bGwhXG4gICAgICAvLyBTZXQgYHJlY29yZGAgdG8gYW4gYXJiaXRyYXJ5IHBvc2l0aW9uLlxuICAgICAgcmVjb3Jkc1soTWF0aC5yYW5kb20oKSAqIHJlY29yZHMubGVuZ3RoKSB8IDBdID0gcmVjb3JkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZGVjb2RlKGJ5dGVzOiBVaW50OEFycmF5LCBpbnB1dE9mZnNldDogbnVtYmVyLCBieXRlTGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IGNhY2hlZFZhbHVlID0gdGhpcy5maW5kKGJ5dGVzLCBpbnB1dE9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgaWYgKGNhY2hlZFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHRoaXMuaGl0Kys7XG4gICAgICByZXR1cm4gY2FjaGVkVmFsdWU7XG4gICAgfVxuICAgIHRoaXMubWlzcysrO1xuXG4gICAgY29uc3Qgc3RyID0gdXRmOERlY29kZUpzKGJ5dGVzLCBpbnB1dE9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgLy8gRW5zdXJlIHRvIGNvcHkgYSBzbGljZSBvZiBieXRlcyBiZWNhdXNlIHRoZSBieXRlIG1heSBiZSBOb2RlSlMgQnVmZmVyIGFuZCBCdWZmZXIjc2xpY2UoKSByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGl0cyBpbnRlcm5hbCBBcnJheUJ1ZmZlci5cbiAgICBjb25zdCBzbGljZWRDb3B5T2ZCeXRlcyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYnl0ZXMsIGlucHV0T2Zmc2V0LCBpbnB1dE9mZnNldCArIGJ5dGVMZW5ndGgpO1xuICAgIHRoaXMuc3RvcmUoc2xpY2VkQ29weU9mQnl0ZXMsIHN0cik7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuIiwgImltcG9ydCB7IHByZXR0eUJ5dGUgfSBmcm9tIFwiLi91dGlscy9wcmV0dHlCeXRlXCI7XG5pbXBvcnQgeyBFeHRlbnNpb25Db2RlYywgRXh0ZW5zaW9uQ29kZWNUeXBlIH0gZnJvbSBcIi4vRXh0ZW5zaW9uQ29kZWNcIjtcbmltcG9ydCB7IGdldEludDY0LCBnZXRVaW50NjQsIFVJTlQzMl9NQVggfSBmcm9tIFwiLi91dGlscy9pbnRcIjtcbmltcG9ydCB7IHV0ZjhEZWNvZGVKcywgVEVYVF9ERUNPREVSX1RIUkVTSE9MRCwgdXRmOERlY29kZVREIH0gZnJvbSBcIi4vdXRpbHMvdXRmOFwiO1xuaW1wb3J0IHsgY3JlYXRlRGF0YVZpZXcsIGVuc3VyZVVpbnQ4QXJyYXkgfSBmcm9tIFwiLi91dGlscy90eXBlZEFycmF5c1wiO1xuaW1wb3J0IHsgQ2FjaGVkS2V5RGVjb2RlciwgS2V5RGVjb2RlciB9IGZyb20gXCIuL0NhY2hlZEtleURlY29kZXJcIjtcbmltcG9ydCB7IERlY29kZUVycm9yIH0gZnJvbSBcIi4vRGVjb2RlRXJyb3JcIjtcblxuY29uc3QgZW51bSBTdGF0ZSB7XG4gIEFSUkFZLFxuICBNQVBfS0VZLFxuICBNQVBfVkFMVUUsXG59XG5cbnR5cGUgTWFwS2V5VHlwZSA9IHN0cmluZyB8IG51bWJlcjtcblxuY29uc3QgaXNWYWxpZE1hcEtleVR5cGUgPSAoa2V5OiB1bmtub3duKToga2V5IGlzIE1hcEtleVR5cGUgPT4ge1xuICBjb25zdCBrZXlUeXBlID0gdHlwZW9mIGtleTtcblxuICByZXR1cm4ga2V5VHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBrZXlUeXBlID09PSBcIm51bWJlclwiO1xufTtcblxudHlwZSBTdGFja01hcFN0YXRlID0ge1xuICB0eXBlOiBTdGF0ZS5NQVBfS0VZIHwgU3RhdGUuTUFQX1ZBTFVFO1xuICBzaXplOiBudW1iZXI7XG4gIGtleTogTWFwS2V5VHlwZSB8IG51bGw7XG4gIHJlYWRDb3VudDogbnVtYmVyO1xuICBtYXA6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xufTtcblxudHlwZSBTdGFja0FycmF5U3RhdGUgPSB7XG4gIHR5cGU6IFN0YXRlLkFSUkFZO1xuICBzaXplOiBudW1iZXI7XG4gIGFycmF5OiBBcnJheTx1bmtub3duPjtcbiAgcG9zaXRpb246IG51bWJlcjtcbn07XG5cbnR5cGUgU3RhY2tTdGF0ZSA9IFN0YWNrQXJyYXlTdGF0ZSB8IFN0YWNrTWFwU3RhdGU7XG5cbmNvbnN0IEhFQURfQllURV9SRVFVSVJFRCA9IC0xO1xuXG5jb25zdCBFTVBUWV9WSUVXID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigwKSk7XG5jb25zdCBFTVBUWV9CWVRFUyA9IG5ldyBVaW50OEFycmF5KEVNUFRZX1ZJRVcuYnVmZmVyKTtcblxuLy8gSUUxMTogSGFjayB0byBzdXBwb3J0IElFMTEuXG4vLyBJRTExOiBEcm9wIHRoaXMgaGFjayBhbmQganVzdCB1c2UgUmFuZ2VFcnJvciB3aGVuIElFMTEgaXMgb2Jzb2xldGUuXG5leHBvcnQgY29uc3QgRGF0YVZpZXdJbmRleE91dE9mQm91bmRzRXJyb3I6IHR5cGVvZiBFcnJvciA9ICgoKSA9PiB7XG4gIHRyeSB7XG4gICAgLy8gSUUxMTogVGhlIHNwZWMgc2F5cyBpdCBzaG91bGQgdGhyb3cgUmFuZ2VFcnJvcixcbiAgICAvLyBJRTExOiBidXQgaW4gSUUxMSBpdCB0aHJvd3MgVHlwZUVycm9yLlxuICAgIEVNUFRZX1ZJRVcuZ2V0SW50OCgwKTtcbiAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgcmV0dXJuIGUuY29uc3RydWN0b3I7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwibmV2ZXIgcmVhY2hlZFwiKTtcbn0pKCk7XG5cbmNvbnN0IE1PUkVfREFUQSA9IG5ldyBEYXRhVmlld0luZGV4T3V0T2ZCb3VuZHNFcnJvcihcIkluc3VmZmljaWVudCBkYXRhXCIpO1xuXG5jb25zdCBzaGFyZWRDYWNoZWRLZXlEZWNvZGVyID0gbmV3IENhY2hlZEtleURlY29kZXIoKTtcblxuZXhwb3J0IGNsYXNzIERlY29kZXI8Q29udGV4dFR5cGUgPSB1bmRlZmluZWQ+IHtcbiAgcHJpdmF0ZSB0b3RhbFBvcyA9IDA7XG4gIHByaXZhdGUgcG9zID0gMDtcblxuICBwcml2YXRlIHZpZXcgPSBFTVBUWV9WSUVXO1xuICBwcml2YXRlIGJ5dGVzID0gRU1QVFlfQllURVM7XG4gIHByaXZhdGUgaGVhZEJ5dGUgPSBIRUFEX0JZVEVfUkVRVUlSRUQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgc3RhY2s6IEFycmF5PFN0YWNrU3RhdGU+ID0gW107XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZXh0ZW5zaW9uQ29kZWM6IEV4dGVuc2lvbkNvZGVjVHlwZTxDb250ZXh0VHlwZT4gPSBFeHRlbnNpb25Db2RlYy5kZWZhdWx0Q29kZWMgYXMgYW55LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY29udGV4dDogQ29udGV4dFR5cGUgPSB1bmRlZmluZWQgYXMgYW55LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbWF4U3RyTGVuZ3RoID0gVUlOVDMyX01BWCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1heEJpbkxlbmd0aCA9IFVJTlQzMl9NQVgsXG4gICAgcHJpdmF0ZSByZWFkb25seSBtYXhBcnJheUxlbmd0aCA9IFVJTlQzMl9NQVgsXG4gICAgcHJpdmF0ZSByZWFkb25seSBtYXhNYXBMZW5ndGggPSBVSU5UMzJfTUFYLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbWF4RXh0TGVuZ3RoID0gVUlOVDMyX01BWCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGtleURlY29kZXI6IEtleURlY29kZXIgfCBudWxsID0gc2hhcmVkQ2FjaGVkS2V5RGVjb2RlcixcbiAgKSB7fVxuXG4gIHByaXZhdGUgcmVpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgdGhpcy50b3RhbFBvcyA9IDA7XG4gICAgdGhpcy5oZWFkQnl0ZSA9IEhFQURfQllURV9SRVFVSVJFRDtcbiAgICB0aGlzLnN0YWNrLmxlbmd0aCA9IDA7XG5cbiAgICAvLyB2aWV3LCBieXRlcywgYW5kIHBvcyB3aWxsIGJlIHJlLWluaXRpYWxpemVkIGluIHNldEJ1ZmZlcigpXG4gIH1cblxuICBwcml2YXRlIHNldEJ1ZmZlcihidWZmZXI6IEFycmF5TGlrZTxudW1iZXI+IHwgQnVmZmVyU291cmNlKTogdm9pZCB7XG4gICAgdGhpcy5ieXRlcyA9IGVuc3VyZVVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICB0aGlzLnZpZXcgPSBjcmVhdGVEYXRhVmlldyh0aGlzLmJ5dGVzKTtcbiAgICB0aGlzLnBvcyA9IDA7XG4gIH1cblxuICBwcml2YXRlIGFwcGVuZEJ1ZmZlcihidWZmZXI6IEFycmF5TGlrZTxudW1iZXI+IHwgQnVmZmVyU291cmNlKSB7XG4gICAgaWYgKHRoaXMuaGVhZEJ5dGUgPT09IEhFQURfQllURV9SRVFVSVJFRCAmJiAhdGhpcy5oYXNSZW1haW5pbmcoMSkpIHtcbiAgICAgIHRoaXMuc2V0QnVmZmVyKGJ1ZmZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlbWFpbmluZ0RhdGEgPSB0aGlzLmJ5dGVzLnN1YmFycmF5KHRoaXMucG9zKTtcbiAgICAgIGNvbnN0IG5ld0RhdGEgPSBlbnN1cmVVaW50OEFycmF5KGJ1ZmZlcik7XG5cbiAgICAgIC8vIGNvbmNhdCByZW1haW5pbmdEYXRhICsgbmV3RGF0YVxuICAgICAgY29uc3QgbmV3QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkocmVtYWluaW5nRGF0YS5sZW5ndGggKyBuZXdEYXRhLmxlbmd0aCk7XG4gICAgICBuZXdCdWZmZXIuc2V0KHJlbWFpbmluZ0RhdGEpO1xuICAgICAgbmV3QnVmZmVyLnNldChuZXdEYXRhLCByZW1haW5pbmdEYXRhLmxlbmd0aCk7XG4gICAgICB0aGlzLnNldEJ1ZmZlcihuZXdCdWZmZXIpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFzUmVtYWluaW5nKHNpemU6IG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLnZpZXcuYnl0ZUxlbmd0aCAtIHRoaXMucG9zID49IHNpemU7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUV4dHJhQnl0ZUVycm9yKHBvc1RvU2hvdzogbnVtYmVyKTogRXJyb3Ige1xuICAgIGNvbnN0IHsgdmlldywgcG9zIH0gPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUmFuZ2VFcnJvcihgRXh0cmEgJHt2aWV3LmJ5dGVMZW5ndGggLSBwb3N9IG9mICR7dmlldy5ieXRlTGVuZ3RofSBieXRlKHMpIGZvdW5kIGF0IGJ1ZmZlclske3Bvc1RvU2hvd31dYCk7XG4gIH1cblxuICAvKipcbiAgICogQHRocm93cyB7QGxpbmsgRGVjb2RlRXJyb3J9XG4gICAqIEB0aHJvd3Mge0BsaW5rIFJhbmdlRXJyb3J9XG4gICAqL1xuICBwdWJsaWMgZGVjb2RlKGJ1ZmZlcjogQXJyYXlMaWtlPG51bWJlcj4gfCBCdWZmZXJTb3VyY2UpOiB1bmtub3duIHtcbiAgICB0aGlzLnJlaW5pdGlhbGl6ZVN0YXRlKCk7XG4gICAgdGhpcy5zZXRCdWZmZXIoYnVmZmVyKTtcblxuICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuZG9EZWNvZGVTeW5jKCk7XG4gICAgaWYgKHRoaXMuaGFzUmVtYWluaW5nKDEpKSB7XG4gICAgICB0aHJvdyB0aGlzLmNyZWF0ZUV4dHJhQnl0ZUVycm9yKHRoaXMucG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIHB1YmxpYyAqZGVjb2RlTXVsdGkoYnVmZmVyOiBBcnJheUxpa2U8bnVtYmVyPiB8IEJ1ZmZlclNvdXJjZSk6IEdlbmVyYXRvcjx1bmtub3duLCB2b2lkLCB1bmtub3duPiB7XG4gICAgdGhpcy5yZWluaXRpYWxpemVTdGF0ZSgpO1xuICAgIHRoaXMuc2V0QnVmZmVyKGJ1ZmZlcik7XG5cbiAgICB3aGlsZSAodGhpcy5oYXNSZW1haW5pbmcoMSkpIHtcbiAgICAgIHlpZWxkIHRoaXMuZG9EZWNvZGVTeW5jKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlY29kZUFzeW5jKHN0cmVhbTogQXN5bmNJdGVyYWJsZTxBcnJheUxpa2U8bnVtYmVyPiB8IEJ1ZmZlclNvdXJjZT4pOiBQcm9taXNlPHVua25vd24+IHtcbiAgICBsZXQgZGVjb2RlZCA9IGZhbHNlO1xuICAgIGxldCBvYmplY3Q6IHVua25vd247XG4gICAgZm9yIGF3YWl0IChjb25zdCBidWZmZXIgb2Ygc3RyZWFtKSB7XG4gICAgICBpZiAoZGVjb2RlZCkge1xuICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUV4dHJhQnl0ZUVycm9yKHRoaXMudG90YWxQb3MpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGVuZEJ1ZmZlcihidWZmZXIpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBvYmplY3QgPSB0aGlzLmRvRGVjb2RlU3luYygpO1xuICAgICAgICBkZWNvZGVkID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIERhdGFWaWV3SW5kZXhPdXRPZkJvdW5kc0Vycm9yKSkge1xuICAgICAgICAgIHRocm93IGU7IC8vIHJldGhyb3dcbiAgICAgICAgfVxuICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgfVxuICAgICAgdGhpcy50b3RhbFBvcyArPSB0aGlzLnBvcztcbiAgICB9XG5cbiAgICBpZiAoZGVjb2RlZCkge1xuICAgICAgaWYgKHRoaXMuaGFzUmVtYWluaW5nKDEpKSB7XG4gICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXh0cmFCeXRlRXJyb3IodGhpcy50b3RhbFBvcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIGNvbnN0IHsgaGVhZEJ5dGUsIHBvcywgdG90YWxQb3MgfSA9IHRoaXM7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICBgSW5zdWZmaWNpZW50IGRhdGEgaW4gcGFyc2luZyAke3ByZXR0eUJ5dGUoaGVhZEJ5dGUpfSBhdCAke3RvdGFsUG9zfSAoJHtwb3N9IGluIHRoZSBjdXJyZW50IGJ1ZmZlcilgLFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZGVjb2RlQXJyYXlTdHJlYW0oXG4gICAgc3RyZWFtOiBBc3luY0l0ZXJhYmxlPEFycmF5TGlrZTxudW1iZXI+IHwgQnVmZmVyU291cmNlPixcbiAgKTogQXN5bmNHZW5lcmF0b3I8dW5rbm93biwgdm9pZCwgdW5rbm93bj4ge1xuICAgIHJldHVybiB0aGlzLmRlY29kZU11bHRpQXN5bmMoc3RyZWFtLCB0cnVlKTtcbiAgfVxuXG4gIHB1YmxpYyBkZWNvZGVTdHJlYW0oc3RyZWFtOiBBc3luY0l0ZXJhYmxlPEFycmF5TGlrZTxudW1iZXI+IHwgQnVmZmVyU291cmNlPik6IEFzeW5jR2VuZXJhdG9yPHVua25vd24sIHZvaWQsIHVua25vd24+IHtcbiAgICByZXR1cm4gdGhpcy5kZWNvZGVNdWx0aUFzeW5jKHN0cmVhbSwgZmFsc2UpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyAqZGVjb2RlTXVsdGlBc3luYyhzdHJlYW06IEFzeW5jSXRlcmFibGU8QXJyYXlMaWtlPG51bWJlcj4gfCBCdWZmZXJTb3VyY2U+LCBpc0FycmF5OiBib29sZWFuKSB7XG4gICAgbGV0IGlzQXJyYXlIZWFkZXJSZXF1aXJlZCA9IGlzQXJyYXk7XG4gICAgbGV0IGFycmF5SXRlbXNMZWZ0ID0gLTE7XG5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGJ1ZmZlciBvZiBzdHJlYW0pIHtcbiAgICAgIGlmIChpc0FycmF5ICYmIGFycmF5SXRlbXNMZWZ0ID09PSAwKSB7XG4gICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXh0cmFCeXRlRXJyb3IodGhpcy50b3RhbFBvcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwZW5kQnVmZmVyKGJ1ZmZlcik7XG5cbiAgICAgIGlmIChpc0FycmF5SGVhZGVyUmVxdWlyZWQpIHtcbiAgICAgICAgYXJyYXlJdGVtc0xlZnQgPSB0aGlzLnJlYWRBcnJheVNpemUoKTtcbiAgICAgICAgaXNBcnJheUhlYWRlclJlcXVpcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLmRvRGVjb2RlU3luYygpO1xuICAgICAgICAgIGlmICgtLWFycmF5SXRlbXNMZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIERhdGFWaWV3SW5kZXhPdXRPZkJvdW5kc0Vycm9yKSkge1xuICAgICAgICAgIHRocm93IGU7IC8vIHJldGhyb3dcbiAgICAgICAgfVxuICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgfVxuICAgICAgdGhpcy50b3RhbFBvcyArPSB0aGlzLnBvcztcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRvRGVjb2RlU3luYygpOiB1bmtub3duIHtcbiAgICBERUNPREU6IHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBoZWFkQnl0ZSA9IHRoaXMucmVhZEhlYWRCeXRlKCk7XG4gICAgICBsZXQgb2JqZWN0OiB1bmtub3duO1xuXG4gICAgICBpZiAoaGVhZEJ5dGUgPj0gMHhlMCkge1xuICAgICAgICAvLyBuZWdhdGl2ZSBmaXhpbnQgKDExMXggeHh4eCkgMHhlMCAtIDB4ZmZcbiAgICAgICAgb2JqZWN0ID0gaGVhZEJ5dGUgLSAweDEwMDtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPCAweGMwKSB7XG4gICAgICAgIGlmIChoZWFkQnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAvLyBwb3NpdGl2ZSBmaXhpbnQgKDB4eHggeHh4eCkgMHgwMCAtIDB4N2ZcbiAgICAgICAgICBvYmplY3QgPSBoZWFkQnl0ZTtcbiAgICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA8IDB4OTApIHtcbiAgICAgICAgICAvLyBmaXhtYXAgKDEwMDAgeHh4eCkgMHg4MCAtIDB4OGZcbiAgICAgICAgICBjb25zdCBzaXplID0gaGVhZEJ5dGUgLSAweDgwO1xuICAgICAgICAgIGlmIChzaXplICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hNYXBTdGF0ZShzaXplKTtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlIERFQ09ERTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqZWN0ID0ge307XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlIDwgMHhhMCkge1xuICAgICAgICAgIC8vIGZpeGFycmF5ICgxMDAxIHh4eHgpIDB4OTAgLSAweDlmXG4gICAgICAgICAgY29uc3Qgc2l6ZSA9IGhlYWRCeXRlIC0gMHg5MDtcbiAgICAgICAgICBpZiAoc2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoQXJyYXlTdGF0ZShzaXplKTtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlIERFQ09ERTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqZWN0ID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZpeHN0ciAoMTAxeCB4eHh4KSAweGEwIC0gMHhiZlxuICAgICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBoZWFkQnl0ZSAtIDB4YTA7XG4gICAgICAgICAgb2JqZWN0ID0gdGhpcy5kZWNvZGVVdGY4U3RyaW5nKGJ5dGVMZW5ndGgsIDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGMwKSB7XG4gICAgICAgIC8vIG5pbFxuICAgICAgICBvYmplY3QgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhjMikge1xuICAgICAgICAvLyBmYWxzZVxuICAgICAgICBvYmplY3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4YzMpIHtcbiAgICAgICAgLy8gdHJ1ZVxuICAgICAgICBvYmplY3QgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhjYSkge1xuICAgICAgICAvLyBmbG9hdCAzMlxuICAgICAgICBvYmplY3QgPSB0aGlzLnJlYWRGMzIoKTtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4Y2IpIHtcbiAgICAgICAgLy8gZmxvYXQgNjRcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5yZWFkRjY0KCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGNjKSB7XG4gICAgICAgIC8vIHVpbnQgOFxuICAgICAgICBvYmplY3QgPSB0aGlzLnJlYWRVOCgpO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhjZCkge1xuICAgICAgICAvLyB1aW50IDE2XG4gICAgICAgIG9iamVjdCA9IHRoaXMucmVhZFUxNigpO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhjZSkge1xuICAgICAgICAvLyB1aW50IDMyXG4gICAgICAgIG9iamVjdCA9IHRoaXMucmVhZFUzMigpO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhjZikge1xuICAgICAgICAvLyB1aW50IDY0XG4gICAgICAgIG9iamVjdCA9IHRoaXMucmVhZFU2NCgpO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhkMCkge1xuICAgICAgICAvLyBpbnQgOFxuICAgICAgICBvYmplY3QgPSB0aGlzLnJlYWRJOCgpO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhkMSkge1xuICAgICAgICAvLyBpbnQgMTZcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5yZWFkSTE2KCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGQyKSB7XG4gICAgICAgIC8vIGludCAzMlxuICAgICAgICBvYmplY3QgPSB0aGlzLnJlYWRJMzIoKTtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4ZDMpIHtcbiAgICAgICAgLy8gaW50IDY0XG4gICAgICAgIG9iamVjdCA9IHRoaXMucmVhZEk2NCgpO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhkOSkge1xuICAgICAgICAvLyBzdHIgOFxuICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gdGhpcy5sb29rVTgoKTtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5kZWNvZGVVdGY4U3RyaW5nKGJ5dGVMZW5ndGgsIDEpO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhkYSkge1xuICAgICAgICAvLyBzdHIgMTZcbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IHRoaXMubG9va1UxNigpO1xuICAgICAgICBvYmplY3QgPSB0aGlzLmRlY29kZVV0ZjhTdHJpbmcoYnl0ZUxlbmd0aCwgMik7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGRiKSB7XG4gICAgICAgIC8vIHN0ciAzMlxuICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gdGhpcy5sb29rVTMyKCk7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuZGVjb2RlVXRmOFN0cmluZyhieXRlTGVuZ3RoLCA0KTtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4ZGMpIHtcbiAgICAgICAgLy8gYXJyYXkgMTZcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMucmVhZFUxNigpO1xuICAgICAgICBpZiAoc2l6ZSAhPT0gMCkge1xuICAgICAgICAgIHRoaXMucHVzaEFycmF5U3RhdGUoc2l6ZSk7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgICAgIGNvbnRpbnVlIERFQ09ERTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmplY3QgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhkZCkge1xuICAgICAgICAvLyBhcnJheSAzMlxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5yZWFkVTMyKCk7XG4gICAgICAgIGlmIChzaXplICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy5wdXNoQXJyYXlTdGF0ZShzaXplKTtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgY29udGludWUgREVDT0RFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iamVjdCA9IFtdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGRlKSB7XG4gICAgICAgIC8vIG1hcCAxNlxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5yZWFkVTE2KCk7XG4gICAgICAgIGlmIChzaXplICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy5wdXNoTWFwU3RhdGUoc2l6ZSk7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgICAgIGNvbnRpbnVlIERFQ09ERTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmplY3QgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhkZikge1xuICAgICAgICAvLyBtYXAgMzJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMucmVhZFUzMigpO1xuICAgICAgICBpZiAoc2l6ZSAhPT0gMCkge1xuICAgICAgICAgIHRoaXMucHVzaE1hcFN0YXRlKHNpemUpO1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgICAgICBjb250aW51ZSBERUNPREU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqZWN0ID0ge307XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4YzQpIHtcbiAgICAgICAgLy8gYmluIDhcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMubG9va1U4KCk7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuZGVjb2RlQmluYXJ5KHNpemUsIDEpO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhjNSkge1xuICAgICAgICAvLyBiaW4gMTZcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMubG9va1UxNigpO1xuICAgICAgICBvYmplY3QgPSB0aGlzLmRlY29kZUJpbmFyeShzaXplLCAyKTtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4YzYpIHtcbiAgICAgICAgLy8gYmluIDMyXG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmxvb2tVMzIoKTtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5kZWNvZGVCaW5hcnkoc2l6ZSwgNCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGQ0KSB7XG4gICAgICAgIC8vIGZpeGV4dCAxXG4gICAgICAgIG9iamVjdCA9IHRoaXMuZGVjb2RlRXh0ZW5zaW9uKDEsIDApO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhkNSkge1xuICAgICAgICAvLyBmaXhleHQgMlxuICAgICAgICBvYmplY3QgPSB0aGlzLmRlY29kZUV4dGVuc2lvbigyLCAwKTtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4ZDYpIHtcbiAgICAgICAgLy8gZml4ZXh0IDRcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5kZWNvZGVFeHRlbnNpb24oNCwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGQ3KSB7XG4gICAgICAgIC8vIGZpeGV4dCA4XG4gICAgICAgIG9iamVjdCA9IHRoaXMuZGVjb2RlRXh0ZW5zaW9uKDgsIDApO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhkOCkge1xuICAgICAgICAvLyBmaXhleHQgMTZcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5kZWNvZGVFeHRlbnNpb24oMTYsIDApO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhjNykge1xuICAgICAgICAvLyBleHQgOFxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5sb29rVTgoKTtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5kZWNvZGVFeHRlbnNpb24oc2l6ZSwgMSk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGM4KSB7XG4gICAgICAgIC8vIGV4dCAxNlxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5sb29rVTE2KCk7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuZGVjb2RlRXh0ZW5zaW9uKHNpemUsIDIpO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhjOSkge1xuICAgICAgICAvLyBleHQgMzJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMubG9va1UzMigpO1xuICAgICAgICBvYmplY3QgPSB0aGlzLmRlY29kZUV4dGVuc2lvbihzaXplLCA0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBEZWNvZGVFcnJvcihgVW5yZWNvZ25pemVkIHR5cGUgYnl0ZTogJHtwcmV0dHlCeXRlKGhlYWRCeXRlKX1gKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuXG4gICAgICBjb25zdCBzdGFjayA9IHRoaXMuc3RhY2s7XG4gICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBhcnJheXMgYW5kIG1hcHNcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXSE7XG4gICAgICAgIGlmIChzdGF0ZS50eXBlID09PSBTdGF0ZS5BUlJBWSkge1xuICAgICAgICAgIHN0YXRlLmFycmF5W3N0YXRlLnBvc2l0aW9uXSA9IG9iamVjdDtcbiAgICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgICAgIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUuc2l6ZSkge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBvYmplY3QgPSBzdGF0ZS5hcnJheTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGludWUgREVDT0RFO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS50eXBlID09PSBTdGF0ZS5NQVBfS0VZKSB7XG4gICAgICAgICAgaWYgKCFpc1ZhbGlkTWFwS2V5VHlwZShvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRGVjb2RlRXJyb3IoXCJUaGUgdHlwZSBvZiBrZXkgbXVzdCBiZSBzdHJpbmcgb3IgbnVtYmVyIGJ1dCBcIiArIHR5cGVvZiBvYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0ID09PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRGVjb2RlRXJyb3IoXCJUaGUga2V5IF9fcHJvdG9fXyBpcyBub3QgYWxsb3dlZFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdGF0ZS5rZXkgPSBvYmplY3Q7XG4gICAgICAgICAgc3RhdGUudHlwZSA9IFN0YXRlLk1BUF9WQUxVRTtcbiAgICAgICAgICBjb250aW51ZSBERUNPREU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaXQgbXVzdCBiZSBgc3RhdGUudHlwZSA9PT0gU3RhdGUuTUFQX1ZBTFVFYCBoZXJlXG5cbiAgICAgICAgICBzdGF0ZS5tYXBbc3RhdGUua2V5IV0gPSBvYmplY3Q7XG4gICAgICAgICAgc3RhdGUucmVhZENvdW50Kys7XG5cbiAgICAgICAgICBpZiAoc3RhdGUucmVhZENvdW50ID09PSBzdGF0ZS5zaXplKSB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIG9iamVjdCA9IHN0YXRlLm1hcDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUua2V5ID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlLnR5cGUgPSBTdGF0ZS5NQVBfS0VZO1xuICAgICAgICAgICAgY29udGludWUgREVDT0RFO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVhZEhlYWRCeXRlKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuaGVhZEJ5dGUgPT09IEhFQURfQllURV9SRVFVSVJFRCkge1xuICAgICAgdGhpcy5oZWFkQnl0ZSA9IHRoaXMucmVhZFU4KCk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcImhlYWRCeXRlXCIsIHByZXR0eUJ5dGUodGhpcy5oZWFkQnl0ZSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmhlYWRCeXRlO1xuICB9XG5cbiAgcHJpdmF0ZSBjb21wbGV0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLmhlYWRCeXRlID0gSEVBRF9CWVRFX1JFUVVJUkVEO1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkQXJyYXlTaXplKCk6IG51bWJlciB7XG4gICAgY29uc3QgaGVhZEJ5dGUgPSB0aGlzLnJlYWRIZWFkQnl0ZSgpO1xuXG4gICAgc3dpdGNoIChoZWFkQnl0ZSkge1xuICAgICAgY2FzZSAweGRjOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkVTE2KCk7XG4gICAgICBjYXNlIDB4ZGQ6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRVMzIoKTtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgaWYgKGhlYWRCeXRlIDwgMHhhMCkge1xuICAgICAgICAgIHJldHVybiBoZWFkQnl0ZSAtIDB4OTA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IERlY29kZUVycm9yKGBVbnJlY29nbml6ZWQgYXJyYXkgdHlwZSBieXRlOiAke3ByZXR0eUJ5dGUoaGVhZEJ5dGUpfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwdXNoTWFwU3RhdGUoc2l6ZTogbnVtYmVyKSB7XG4gICAgaWYgKHNpemUgPiB0aGlzLm1heE1hcExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IERlY29kZUVycm9yKGBNYXggbGVuZ3RoIGV4Y2VlZGVkOiBtYXAgbGVuZ3RoICgke3NpemV9KSA+IG1heE1hcExlbmd0aExlbmd0aCAoJHt0aGlzLm1heE1hcExlbmd0aH0pYCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgIHR5cGU6IFN0YXRlLk1BUF9LRVksXG4gICAgICBzaXplLFxuICAgICAga2V5OiBudWxsLFxuICAgICAgcmVhZENvdW50OiAwLFxuICAgICAgbWFwOiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgcHVzaEFycmF5U3RhdGUoc2l6ZTogbnVtYmVyKSB7XG4gICAgaWYgKHNpemUgPiB0aGlzLm1heEFycmF5TGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRGVjb2RlRXJyb3IoYE1heCBsZW5ndGggZXhjZWVkZWQ6IGFycmF5IGxlbmd0aCAoJHtzaXplfSkgPiBtYXhBcnJheUxlbmd0aCAoJHt0aGlzLm1heEFycmF5TGVuZ3RofSlgKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgdHlwZTogU3RhdGUuQVJSQVksXG4gICAgICBzaXplLFxuICAgICAgYXJyYXk6IG5ldyBBcnJheTx1bmtub3duPihzaXplKSxcbiAgICAgIHBvc2l0aW9uOiAwLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBkZWNvZGVVdGY4U3RyaW5nKGJ5dGVMZW5ndGg6IG51bWJlciwgaGVhZGVyT2Zmc2V0OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGlmIChieXRlTGVuZ3RoID4gdGhpcy5tYXhTdHJMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBEZWNvZGVFcnJvcihcbiAgICAgICAgYE1heCBsZW5ndGggZXhjZWVkZWQ6IFVURi04IGJ5dGUgbGVuZ3RoICgke2J5dGVMZW5ndGh9KSA+IG1heFN0ckxlbmd0aCAoJHt0aGlzLm1heFN0ckxlbmd0aH0pYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYnl0ZXMuYnl0ZUxlbmd0aCA8IHRoaXMucG9zICsgaGVhZGVyT2Zmc2V0ICsgYnl0ZUxlbmd0aCkge1xuICAgICAgdGhyb3cgTU9SRV9EQVRBO1xuICAgIH1cblxuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMucG9zICsgaGVhZGVyT2Zmc2V0O1xuICAgIGxldCBvYmplY3Q6IHN0cmluZztcbiAgICBpZiAodGhpcy5zdGF0ZUlzTWFwS2V5KCkgJiYgdGhpcy5rZXlEZWNvZGVyPy5jYW5CZUNhY2hlZChieXRlTGVuZ3RoKSkge1xuICAgICAgb2JqZWN0ID0gdGhpcy5rZXlEZWNvZGVyLmRlY29kZSh0aGlzLmJ5dGVzLCBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoYnl0ZUxlbmd0aCA+IFRFWFRfREVDT0RFUl9USFJFU0hPTEQpIHtcbiAgICAgIG9iamVjdCA9IHV0ZjhEZWNvZGVURCh0aGlzLmJ5dGVzLCBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3QgPSB1dGY4RGVjb2RlSnModGhpcy5ieXRlcywgb2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgdGhpcy5wb3MgKz0gaGVhZGVyT2Zmc2V0ICsgYnl0ZUxlbmd0aDtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0ZUlzTWFwS2V5KCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdITtcbiAgICAgIHJldHVybiBzdGF0ZS50eXBlID09PSBTdGF0ZS5NQVBfS0VZO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIGRlY29kZUJpbmFyeShieXRlTGVuZ3RoOiBudW1iZXIsIGhlYWRPZmZzZXQ6IG51bWJlcik6IFVpbnQ4QXJyYXkge1xuICAgIGlmIChieXRlTGVuZ3RoID4gdGhpcy5tYXhCaW5MZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBEZWNvZGVFcnJvcihgTWF4IGxlbmd0aCBleGNlZWRlZDogYmluIGxlbmd0aCAoJHtieXRlTGVuZ3RofSkgPiBtYXhCaW5MZW5ndGggKCR7dGhpcy5tYXhCaW5MZW5ndGh9KWApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5oYXNSZW1haW5pbmcoYnl0ZUxlbmd0aCArIGhlYWRPZmZzZXQpKSB7XG4gICAgICB0aHJvdyBNT1JFX0RBVEE7XG4gICAgfVxuXG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5wb3MgKyBoZWFkT2Zmc2V0O1xuICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuYnl0ZXMuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBieXRlTGVuZ3RoKTtcbiAgICB0aGlzLnBvcyArPSBoZWFkT2Zmc2V0ICsgYnl0ZUxlbmd0aDtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgcHJpdmF0ZSBkZWNvZGVFeHRlbnNpb24oc2l6ZTogbnVtYmVyLCBoZWFkT2Zmc2V0OiBudW1iZXIpOiB1bmtub3duIHtcbiAgICBpZiAoc2l6ZSA+IHRoaXMubWF4RXh0TGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRGVjb2RlRXJyb3IoYE1heCBsZW5ndGggZXhjZWVkZWQ6IGV4dCBsZW5ndGggKCR7c2l6ZX0pID4gbWF4RXh0TGVuZ3RoICgke3RoaXMubWF4RXh0TGVuZ3RofSlgKTtcbiAgICB9XG5cbiAgICBjb25zdCBleHRUeXBlID0gdGhpcy52aWV3LmdldEludDgodGhpcy5wb3MgKyBoZWFkT2Zmc2V0KTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kZWNvZGVCaW5hcnkoc2l6ZSwgaGVhZE9mZnNldCArIDEgLyogZXh0VHlwZSAqLyk7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uQ29kZWMuZGVjb2RlKGRhdGEsIGV4dFR5cGUsIHRoaXMuY29udGV4dCk7XG4gIH1cblxuICBwcml2YXRlIGxvb2tVOCgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zKTtcbiAgfVxuXG4gIHByaXZhdGUgbG9va1UxNigpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLnBvcyk7XG4gIH1cblxuICBwcml2YXRlIGxvb2tVMzIoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5wb3MpO1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkVTgoKTogbnVtYmVyIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MrKztcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBwcml2YXRlIHJlYWRJOCgpOiBudW1iZXIge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy52aWV3LmdldEludDgodGhpcy5wb3MpO1xuICAgIHRoaXMucG9zKys7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkVTE2KCk6IG51bWJlciB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSAyO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZEkxNigpOiBudW1iZXIge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy52aWV3LmdldEludDE2KHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSAyO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZFUzMigpOiBudW1iZXIge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gNDtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBwcml2YXRlIHJlYWRJMzIoKTogbnVtYmVyIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmlldy5nZXRJbnQzMih0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gNDtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBwcml2YXRlIHJlYWRVNjQoKTogbnVtYmVyIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQ2NCh0aGlzLnZpZXcsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZEk2NCgpOiBudW1iZXIge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0SW50NjQodGhpcy52aWV3LCB0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gODtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBwcml2YXRlIHJlYWRGMzIoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0RmxvYXQzMih0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gNDtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBwcml2YXRlIHJlYWRGNjQoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0RmxvYXQ2NCh0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gODtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBEZWNvZGVyIH0gZnJvbSBcIi4vRGVjb2RlclwiO1xuaW1wb3J0IHR5cGUgeyBFeHRlbnNpb25Db2RlY1R5cGUgfSBmcm9tIFwiLi9FeHRlbnNpb25Db2RlY1wiO1xuaW1wb3J0IHR5cGUgeyBDb250ZXh0T2YsIFNwbGl0VW5kZWZpbmVkIH0gZnJvbSBcIi4vY29udGV4dFwiO1xuXG5leHBvcnQgdHlwZSBEZWNvZGVPcHRpb25zPENvbnRleHRUeXBlID0gdW5kZWZpbmVkPiA9IFJlYWRvbmx5PFxuICBQYXJ0aWFsPHtcbiAgICBleHRlbnNpb25Db2RlYzogRXh0ZW5zaW9uQ29kZWNUeXBlPENvbnRleHRUeXBlPjtcblxuICAgIC8qKlxuICAgICAqIE1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRvIDRfMjk0Xzk2N18yOTUgKFVJTlQzMl9NQVgpLlxuICAgICAqL1xuICAgIG1heFN0ckxlbmd0aDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIE1heGltdW0gYmluYXJ5IGxlbmd0aC5cbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRvIDRfMjk0Xzk2N18yOTUgKFVJTlQzMl9NQVgpLlxuICAgICAqL1xuICAgIG1heEJpbkxlbmd0aDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIE1heGltdW0gYXJyYXkgbGVuZ3RoLlxuICAgICAqXG4gICAgICogRGVmYXVsdHMgdG8gNF8yOTRfOTY3XzI5NSAoVUlOVDMyX01BWCkuXG4gICAgICovXG4gICAgbWF4QXJyYXlMZW5ndGg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIG1hcCBsZW5ndGguXG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0byA0XzI5NF85NjdfMjk1IChVSU5UMzJfTUFYKS5cbiAgICAgKi9cbiAgICBtYXhNYXBMZW5ndGg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIGV4dGVuc2lvbiBsZW5ndGguXG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0byA0XzI5NF85NjdfMjk1IChVSU5UMzJfTUFYKS5cbiAgICAgKi9cbiAgICBtYXhFeHRMZW5ndGg6IG51bWJlcjtcbiAgfT5cbj4gJlxuICBDb250ZXh0T2Y8Q29udGV4dFR5cGU+O1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdERlY29kZU9wdGlvbnM6IERlY29kZU9wdGlvbnMgPSB7fTtcblxuLyoqXG4gKiBJdCBkZWNvZGVzIGEgc2luZ2xlIE1lc3NhZ2VQYWNrIG9iamVjdCBpbiBhIGJ1ZmZlci5cbiAqXG4gKiBUaGlzIGlzIGEgc3luY2hyb25vdXMgZGVjb2RpbmcgZnVuY3Rpb24uXG4gKiBTZWUgb3RoZXIgdmFyaWFudHMgZm9yIGFzeW5jaHJvbm91cyBkZWNvZGluZzoge0BsaW5rIGRlY29kZUFzeW5jKCl9LCB7QGxpbmsgZGVjb2RlU3RyZWFtKCl9LCBvciB7QGxpbmsgZGVjb2RlQXJyYXlTdHJlYW0oKX0uXG4gKlxuICogQHRocm93cyB7QGxpbmsgUmFuZ2VFcnJvcn0gaWYgdGhlIGJ1ZmZlciBpcyBpbmNvbXBsZXRlLCBpbmNsdWRpbmcgdGhlIGNhc2Ugd2hlcmUgdGhlIGJ1ZmZlciBpcyBlbXB0eS5cbiAqIEB0aHJvd3Mge0BsaW5rIERlY29kZUVycm9yfSBpZiB0aGUgYnVmZmVyIGNvbnRhaW5zIGludmFsaWQgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZTxDb250ZXh0VHlwZSA9IHVuZGVmaW5lZD4oXG4gIGJ1ZmZlcjogQXJyYXlMaWtlPG51bWJlcj4gfCBCdWZmZXJTb3VyY2UsXG4gIG9wdGlvbnM6IERlY29kZU9wdGlvbnM8U3BsaXRVbmRlZmluZWQ8Q29udGV4dFR5cGU+PiA9IGRlZmF1bHREZWNvZGVPcHRpb25zIGFzIGFueSxcbik6IHVua25vd24ge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IERlY29kZXIoXG4gICAgb3B0aW9ucy5leHRlbnNpb25Db2RlYyxcbiAgICAob3B0aW9ucyBhcyB0eXBlb2Ygb3B0aW9ucyAmIHsgY29udGV4dDogYW55IH0pLmNvbnRleHQsXG4gICAgb3B0aW9ucy5tYXhTdHJMZW5ndGgsXG4gICAgb3B0aW9ucy5tYXhCaW5MZW5ndGgsXG4gICAgb3B0aW9ucy5tYXhBcnJheUxlbmd0aCxcbiAgICBvcHRpb25zLm1heE1hcExlbmd0aCxcbiAgICBvcHRpb25zLm1heEV4dExlbmd0aCxcbiAgKTtcbiAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGJ1ZmZlcik7XG59XG5cbi8qKlxuICogSXQgZGVjb2RlcyBtdWx0aXBsZSBNZXNzYWdlUGFjayBvYmplY3RzIGluIGEgYnVmZmVyLlxuICogVGhpcyBpcyBjb3JyZXNwb25kaW5nIHRvIHtAbGluayBkZWNvZGVNdWx0aVN0cmVhbSgpfS5cbiAqXG4gKiBAdGhyb3dzIHtAbGluayBSYW5nZUVycm9yfSBpZiB0aGUgYnVmZmVyIGlzIGluY29tcGxldGUsIGluY2x1ZGluZyB0aGUgY2FzZSB3aGVyZSB0aGUgYnVmZmVyIGlzIGVtcHR5LlxuICogQHRocm93cyB7QGxpbmsgRGVjb2RlRXJyb3J9IGlmIHRoZSBidWZmZXIgY29udGFpbnMgaW52YWxpZCBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlTXVsdGk8Q29udGV4dFR5cGUgPSB1bmRlZmluZWQ+KFxuICBidWZmZXI6IEFycmF5TGlrZTxudW1iZXI+IHwgQnVmZmVyU291cmNlLFxuICBvcHRpb25zOiBEZWNvZGVPcHRpb25zPFNwbGl0VW5kZWZpbmVkPENvbnRleHRUeXBlPj4gPSBkZWZhdWx0RGVjb2RlT3B0aW9ucyBhcyBhbnksXG4pOiBHZW5lcmF0b3I8dW5rbm93biwgdm9pZCwgdW5rbm93bj4ge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IERlY29kZXIoXG4gICAgb3B0aW9ucy5leHRlbnNpb25Db2RlYyxcbiAgICAob3B0aW9ucyBhcyB0eXBlb2Ygb3B0aW9ucyAmIHsgY29udGV4dDogYW55IH0pLmNvbnRleHQsXG4gICAgb3B0aW9ucy5tYXhTdHJMZW5ndGgsXG4gICAgb3B0aW9ucy5tYXhCaW5MZW5ndGgsXG4gICAgb3B0aW9ucy5tYXhBcnJheUxlbmd0aCxcbiAgICBvcHRpb25zLm1heE1hcExlbmd0aCxcbiAgICBvcHRpb25zLm1heEV4dExlbmd0aCxcbiAgKTtcbiAgcmV0dXJuIGRlY29kZXIuZGVjb2RlTXVsdGkoYnVmZmVyKTtcbn1cbiIsICIvLyB1dGlsaXR5IGZvciB3aGF0d2cgc3RyZWFtc1xuXG4vLyBUaGUgbGl2aW5nIHN0YW5kYXJkIG9mIHdoYXR3ZyBzdHJlYW1zIHNheXNcbi8vIFJlYWRhYmxlU3RyZWFtIGlzIGFsc28gQXN5bmNJdGVyYWJsZSwgYnV0XG4vLyBhcyBvZiBKdW5lIDIwMTksIG5vIGJyb3dzZXIgaW1wbGVtZW50cyBpdC5cbi8vIFNlZSBodHRwczovL3N0cmVhbXMuc3BlYy53aGF0d2cub3JnLyBmb3IgZGV0YWlsc1xuZXhwb3J0IHR5cGUgUmVhZGFibGVTdHJlYW1MaWtlPFQ+ID0gQXN5bmNJdGVyYWJsZTxUPiB8IFJlYWRhYmxlU3RyZWFtPFQ+O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNBc3luY0l0ZXJhYmxlPFQ+KG9iamVjdDogUmVhZGFibGVTdHJlYW1MaWtlPFQ+KTogb2JqZWN0IGlzIEFzeW5jSXRlcmFibGU8VD4ge1xuICByZXR1cm4gKG9iamVjdCBhcyBhbnkpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSAhPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROb25OdWxsPFQ+KHZhbHVlOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCk6IGFzc2VydHMgdmFsdWUgaXMgVCB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0aW9uIEZhaWx1cmU6IHZhbHVlIG11c3Qgbm90IGJlIG51bGwgbm9yIHVuZGVmaW5lZFwiKTtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIGFzeW5jSXRlcmFibGVGcm9tU3RyZWFtPFQ+KHN0cmVhbTogUmVhZGFibGVTdHJlYW08VD4pOiBBc3luY0l0ZXJhYmxlPFQ+IHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuXG4gIHRyeSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhc3NlcnROb25OdWxsKHZhbHVlKTtcbiAgICAgIHlpZWxkIHZhbHVlO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlQXN5bmNJdGVyYWJsZTxUPihzdHJlYW1MaWtlOiBSZWFkYWJsZVN0cmVhbUxpa2U8VD4pOiBBc3luY0l0ZXJhYmxlPFQ+IHtcbiAgaWYgKGlzQXN5bmNJdGVyYWJsZShzdHJlYW1MaWtlKSkge1xuICAgIHJldHVybiBzdHJlYW1MaWtlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc3luY0l0ZXJhYmxlRnJvbVN0cmVhbShzdHJlYW1MaWtlKTtcbiAgfVxufVxuIiwgImltcG9ydCB7IERlY29kZXIgfSBmcm9tIFwiLi9EZWNvZGVyXCI7XG5pbXBvcnQgeyBlbnN1cmVBc3luY0l0ZXJhYmxlIH0gZnJvbSBcIi4vdXRpbHMvc3RyZWFtXCI7XG5pbXBvcnQgeyBkZWZhdWx0RGVjb2RlT3B0aW9ucyB9IGZyb20gXCIuL2RlY29kZVwiO1xuaW1wb3J0IHR5cGUgeyBSZWFkYWJsZVN0cmVhbUxpa2UgfSBmcm9tIFwiLi91dGlscy9zdHJlYW1cIjtcbmltcG9ydCB0eXBlIHsgRGVjb2RlT3B0aW9ucyB9IGZyb20gXCIuL2RlY29kZVwiO1xuaW1wb3J0IHR5cGUgeyBTcGxpdFVuZGVmaW5lZCB9IGZyb20gXCIuL2NvbnRleHRcIjtcblxuLyoqXG4gKiBAdGhyb3dzIHtAbGluayBSYW5nZUVycm9yfSBpZiB0aGUgYnVmZmVyIGlzIGluY29tcGxldGUsIGluY2x1ZGluZyB0aGUgY2FzZSB3aGVyZSB0aGUgYnVmZmVyIGlzIGVtcHR5LlxuICogQHRocm93cyB7QGxpbmsgRGVjb2RlRXJyb3J9IGlmIHRoZSBidWZmZXIgY29udGFpbnMgaW52YWxpZCBkYXRhLlxuICovXG4gZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlY29kZUFzeW5jPENvbnRleHRUeXBlPihcbiAgc3RyZWFtTGlrZTogUmVhZGFibGVTdHJlYW1MaWtlPEFycmF5TGlrZTxudW1iZXI+IHwgQnVmZmVyU291cmNlPixcbiAgb3B0aW9uczogRGVjb2RlT3B0aW9uczxTcGxpdFVuZGVmaW5lZDxDb250ZXh0VHlwZT4+ID0gZGVmYXVsdERlY29kZU9wdGlvbnMgYXMgYW55LFxuKTogUHJvbWlzZTx1bmtub3duPiB7XG4gIGNvbnN0IHN0cmVhbSA9IGVuc3VyZUFzeW5jSXRlcmFibGUoc3RyZWFtTGlrZSk7XG5cbiAgY29uc3QgZGVjb2RlciA9IG5ldyBEZWNvZGVyKFxuICAgIG9wdGlvbnMuZXh0ZW5zaW9uQ29kZWMsXG4gICAgKG9wdGlvbnMgYXMgdHlwZW9mIG9wdGlvbnMgJiB7IGNvbnRleHQ6IGFueSB9KS5jb250ZXh0LFxuICAgIG9wdGlvbnMubWF4U3RyTGVuZ3RoLFxuICAgIG9wdGlvbnMubWF4QmluTGVuZ3RoLFxuICAgIG9wdGlvbnMubWF4QXJyYXlMZW5ndGgsXG4gICAgb3B0aW9ucy5tYXhNYXBMZW5ndGgsXG4gICAgb3B0aW9ucy5tYXhFeHRMZW5ndGgsXG4gICk7XG4gIHJldHVybiBkZWNvZGVyLmRlY29kZUFzeW5jKHN0cmVhbSk7XG59XG5cbi8qKlxuICogQHRocm93cyB7QGxpbmsgUmFuZ2VFcnJvcn0gaWYgdGhlIGJ1ZmZlciBpcyBpbmNvbXBsZXRlLCBpbmNsdWRpbmcgdGhlIGNhc2Ugd2hlcmUgdGhlIGJ1ZmZlciBpcyBlbXB0eS5cbiAqIEB0aHJvd3Mge0BsaW5rIERlY29kZUVycm9yfSBpZiB0aGUgYnVmZmVyIGNvbnRhaW5zIGludmFsaWQgZGF0YS5cbiAqL1xuIGV4cG9ydCBmdW5jdGlvbiBkZWNvZGVBcnJheVN0cmVhbTxDb250ZXh0VHlwZT4oXG4gIHN0cmVhbUxpa2U6IFJlYWRhYmxlU3RyZWFtTGlrZTxBcnJheUxpa2U8bnVtYmVyPiB8IEJ1ZmZlclNvdXJjZT4sXG4gIG9wdGlvbnM6IERlY29kZU9wdGlvbnM8U3BsaXRVbmRlZmluZWQ8Q29udGV4dFR5cGU+PiA9IGRlZmF1bHREZWNvZGVPcHRpb25zIGFzIGFueSxcbik6IEFzeW5jR2VuZXJhdG9yPHVua25vd24sIHZvaWQsIHVua25vd24+IHtcbiAgY29uc3Qgc3RyZWFtID0gZW5zdXJlQXN5bmNJdGVyYWJsZShzdHJlYW1MaWtlKTtcblxuICBjb25zdCBkZWNvZGVyID0gbmV3IERlY29kZXIoXG4gICAgb3B0aW9ucy5leHRlbnNpb25Db2RlYyxcbiAgICAob3B0aW9ucyBhcyB0eXBlb2Ygb3B0aW9ucyAmIHsgY29udGV4dDogYW55IH0pLmNvbnRleHQsXG4gICAgb3B0aW9ucy5tYXhTdHJMZW5ndGgsXG4gICAgb3B0aW9ucy5tYXhCaW5MZW5ndGgsXG4gICAgb3B0aW9ucy5tYXhBcnJheUxlbmd0aCxcbiAgICBvcHRpb25zLm1heE1hcExlbmd0aCxcbiAgICBvcHRpb25zLm1heEV4dExlbmd0aCxcbiAgKTtcblxuICByZXR1cm4gZGVjb2Rlci5kZWNvZGVBcnJheVN0cmVhbShzdHJlYW0pO1xufVxuXG4vKipcbiAqIEB0aHJvd3Mge0BsaW5rIFJhbmdlRXJyb3J9IGlmIHRoZSBidWZmZXIgaXMgaW5jb21wbGV0ZSwgaW5jbHVkaW5nIHRoZSBjYXNlIHdoZXJlIHRoZSBidWZmZXIgaXMgZW1wdHkuXG4gKiBAdGhyb3dzIHtAbGluayBEZWNvZGVFcnJvcn0gaWYgdGhlIGJ1ZmZlciBjb250YWlucyBpbnZhbGlkIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVNdWx0aVN0cmVhbTxDb250ZXh0VHlwZT4oXG4gIHN0cmVhbUxpa2U6IFJlYWRhYmxlU3RyZWFtTGlrZTxBcnJheUxpa2U8bnVtYmVyPiB8IEJ1ZmZlclNvdXJjZT4sXG4gIG9wdGlvbnM6IERlY29kZU9wdGlvbnM8U3BsaXRVbmRlZmluZWQ8Q29udGV4dFR5cGU+PiA9IGRlZmF1bHREZWNvZGVPcHRpb25zIGFzIGFueSxcbik6IEFzeW5jR2VuZXJhdG9yPHVua25vd24sIHZvaWQsIHVua25vd24+IHtcbiAgY29uc3Qgc3RyZWFtID0gZW5zdXJlQXN5bmNJdGVyYWJsZShzdHJlYW1MaWtlKTtcblxuICBjb25zdCBkZWNvZGVyID0gbmV3IERlY29kZXIoXG4gICAgb3B0aW9ucy5leHRlbnNpb25Db2RlYyxcbiAgICAob3B0aW9ucyBhcyB0eXBlb2Ygb3B0aW9ucyAmIHsgY29udGV4dDogYW55IH0pLmNvbnRleHQsXG4gICAgb3B0aW9ucy5tYXhTdHJMZW5ndGgsXG4gICAgb3B0aW9ucy5tYXhCaW5MZW5ndGgsXG4gICAgb3B0aW9ucy5tYXhBcnJheUxlbmd0aCxcbiAgICBvcHRpb25zLm1heE1hcExlbmd0aCxcbiAgICBvcHRpb25zLm1heEV4dExlbmd0aCxcbiAgKTtcblxuICByZXR1cm4gZGVjb2Rlci5kZWNvZGVTdHJlYW0oc3RyZWFtKTtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGRlY29kZU11bHRpU3RyZWFtKCl9IGluc3RlYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVTdHJlYW08Q29udGV4dFR5cGU+KFxuICBzdHJlYW1MaWtlOiBSZWFkYWJsZVN0cmVhbUxpa2U8QXJyYXlMaWtlPG51bWJlcj4gfCBCdWZmZXJTb3VyY2U+LFxuICBvcHRpb25zOiBEZWNvZGVPcHRpb25zPFNwbGl0VW5kZWZpbmVkPENvbnRleHRUeXBlPj4gPSBkZWZhdWx0RGVjb2RlT3B0aW9ucyBhcyBhbnksXG4pOiBBc3luY0dlbmVyYXRvcjx1bmtub3duLCB2b2lkLCB1bmtub3duPiB7XG4gIHJldHVybiBkZWNvZGVNdWx0aVN0cmVhbShzdHJlYW1MaWtlLCBvcHRpb25zKTtcbn1cbiIsICIvLyBNYWluIEZ1bmN0aW9uczpcblxuaW1wb3J0IHsgZW5jb2RlIH0gZnJvbSBcIi4vZW5jb2RlXCI7XG5leHBvcnQgeyBlbmNvZGUgfTtcbmltcG9ydCB0eXBlIHsgRW5jb2RlT3B0aW9ucyB9IGZyb20gXCIuL2VuY29kZVwiO1xuZXhwb3J0IHR5cGUgeyBFbmNvZGVPcHRpb25zIH07XG5cbmltcG9ydCB7IGRlY29kZSwgZGVjb2RlTXVsdGkgfSBmcm9tIFwiLi9kZWNvZGVcIjtcbmV4cG9ydCB7IGRlY29kZSwgZGVjb2RlTXVsdGkgfTtcbmltcG9ydCB0eXBlIHsgRGVjb2RlT3B0aW9ucyB9IGZyb20gXCIuL2RlY29kZVwiO1xuZXhwb3J0IHsgRGVjb2RlT3B0aW9ucyB9O1xuXG5pbXBvcnQgeyBkZWNvZGVBc3luYywgZGVjb2RlQXJyYXlTdHJlYW0sIGRlY29kZU11bHRpU3RyZWFtLCBkZWNvZGVTdHJlYW0gfSBmcm9tIFwiLi9kZWNvZGVBc3luY1wiO1xuZXhwb3J0IHsgZGVjb2RlQXN5bmMsIGRlY29kZUFycmF5U3RyZWFtLCBkZWNvZGVNdWx0aVN0cmVhbSwgZGVjb2RlU3RyZWFtIH07XG5cbmltcG9ydCB7IERlY29kZXIsIERhdGFWaWV3SW5kZXhPdXRPZkJvdW5kc0Vycm9yIH0gZnJvbSBcIi4vRGVjb2RlclwiO1xuaW1wb3J0IHsgRGVjb2RlRXJyb3IgfSBmcm9tIFwiLi9EZWNvZGVFcnJvclwiO1xuZXhwb3J0IHsgRGVjb2RlciwgRGVjb2RlRXJyb3IsIERhdGFWaWV3SW5kZXhPdXRPZkJvdW5kc0Vycm9yIH07XG5cbmltcG9ydCB7IEVuY29kZXIgfSBmcm9tIFwiLi9FbmNvZGVyXCI7XG5leHBvcnQgeyBFbmNvZGVyIH07XG5cbi8vIFV0aWxpdGlpZXMgZm9yIEV4dGVuc2lvbiBUeXBlczpcblxuaW1wb3J0IHsgRXh0ZW5zaW9uQ29kZWMgfSBmcm9tIFwiLi9FeHRlbnNpb25Db2RlY1wiO1xuZXhwb3J0IHsgRXh0ZW5zaW9uQ29kZWMgfTtcbmltcG9ydCB0eXBlIHsgRXh0ZW5zaW9uQ29kZWNUeXBlLCBFeHRlbnNpb25EZWNvZGVyVHlwZSwgRXh0ZW5zaW9uRW5jb2RlclR5cGUgfSBmcm9tIFwiLi9FeHRlbnNpb25Db2RlY1wiO1xuZXhwb3J0IHR5cGUgeyBFeHRlbnNpb25Db2RlY1R5cGUsIEV4dGVuc2lvbkRlY29kZXJUeXBlLCBFeHRlbnNpb25FbmNvZGVyVHlwZSB9O1xuaW1wb3J0IHsgRXh0RGF0YSB9IGZyb20gXCIuL0V4dERhdGFcIjtcbmV4cG9ydCB7IEV4dERhdGEgfTtcblxuaW1wb3J0IHtcbiAgRVhUX1RJTUVTVEFNUCxcbiAgZW5jb2RlRGF0ZVRvVGltZVNwZWMsXG4gIGVuY29kZVRpbWVTcGVjVG9UaW1lc3RhbXAsXG4gIGRlY29kZVRpbWVzdGFtcFRvVGltZVNwZWMsXG4gIGVuY29kZVRpbWVzdGFtcEV4dGVuc2lvbixcbiAgZGVjb2RlVGltZXN0YW1wRXh0ZW5zaW9uLFxufSBmcm9tIFwiLi90aW1lc3RhbXBcIjtcbmV4cG9ydCB7XG4gIEVYVF9USU1FU1RBTVAsXG4gIGVuY29kZURhdGVUb1RpbWVTcGVjLFxuICBlbmNvZGVUaW1lU3BlY1RvVGltZXN0YW1wLFxuICBkZWNvZGVUaW1lc3RhbXBUb1RpbWVTcGVjLFxuICBlbmNvZGVUaW1lc3RhbXBFeHRlbnNpb24sXG4gIGRlY29kZVRpbWVzdGFtcEV4dGVuc2lvbixcbn07XG4iLCBudWxsLCAiaW1wb3J0IHsgTm90aWNlLCBQbHVnaW4sIG5vcm1hbGl6ZVBhdGgsIERhdGFBZGFwdGVyIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgdXVoaW1zeVNldHRpbmdzVGFiIH0gZnJvbSAnc2V0dGluZ3MnO1xuaW1wb3J0IHsgVVVoaW1zeUVudHJhbmNlU3VnZ2VzdCwgVVVoaW1zeUV4aXRTdWdnZXN0IH0gZnJvbSAnc3VnZ2VzdCc7XG5cbi8vaW5jbHVkZSBzeXN0ZW0gY29tbWFuZCBcbmNvbnN0IHsgZXhlY1N5bmMgfSA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKTtcblxuLy8gcGF0aFRvUGx1Z2luIGNvbnRhaW5zIFwibXktZm9sZGVyL2ZpbGVcIiBub3QgXCIvL215LWZvbGRlclxcXCJcblxuY29uc3QgeyBDbGllbnQsIFNlcnZlciwgTWVzc2FnZSB9ID0gcmVxdWlyZShcIm5vZGUtb3NjXCIpXG5jb25zdCBPQlNXZWJTb2NrZXQgPSByZXF1aXJlKFwib2JzLXdlYnNvY2tldC1qc1wiKS5kZWZhdWx0O1xuXG5pbnRlcmZhY2UgdXVoaW1zeVBsdWdpblNldHRpbmdze1xuXHR3ZWJzb2NrZXRJUF9UZXh0OiBzdHJpbmc7XG5cdHdlYnNvY2tldFBvcnRfVGV4dDogc3RyaW5nO1xuXHR3ZWJzb2NrZXRQV19UZXh0OiBzdHJpbmc7XG5cdG9ic0FwcE5hbWVfVGV4dDogc3RyaW5nO1xuXHRvYnNBcHBQYXRoX1RleHQ6IHN0cmluZztcblx0b2JzQ29sbGVjdGlvbl9UZXh0OiBzdHJpbmc7XG5cdG9ic0RlYnVnX1RleHQ6IHN0cmluZztcblx0b2JzRGVidWdQb3J0X1RleHQ6IHN0cmluZztcblx0b3NjSVBfVGV4dDogc3RyaW5nO1xuXHRvc2NJblBvcnRfVGV4dDogc3RyaW5nO1xuXHRvc2NPdXRQb3J0X1RleHQ6IHN0cmluZztcbn1cblxuY29uc3QgREVGQVVMVF9TRVRUSU5HUzogUGFydGlhbDx1dWhpbXN5UGx1Z2luU2V0dGluZ3M+ID0ge1xuXHR3ZWJzb2NrZXRJUF9UZXh0OiBcImxvY2FsaG9zdFwiLFxuXHR3ZWJzb2NrZXRQb3J0X1RleHQ6IFwiNDQ1NVwiLFxuXHR3ZWJzb2NrZXRQV19UZXh0OiBcInBhc3N3b3JkXCIsXG5cdG9zY0lQX1RleHQ6IFwibG9jYWxob3N0XCIsXG5cdG9zY0luUG9ydF9UZXh0OiBcIjQ0NjZcIixcblx0b3NjT3V0UG9ydF9UZXh0OiBcIjQ0NzdcIixcblx0b2JzQXBwTmFtZV9UZXh0OiBcIk9CU1wiLFxuXHRvYnNBcHBQYXRoX1RleHQ6IFwiQzpcXFxcXFxcXFByb2dyYW0gRmlsZXNcXFxcXFxcXG9icy1zdHVkaW9cXFxcXFxcXGJpblxcXFxcXFxcNjRiaXRcXFxcXFxcXFwiLFxuXHRvYnNDb2xsZWN0aW9uX1RleHQ6IFwiS2V5X2FuZF9Nb3VzZV9WaXN1YWxzX0NvbGxlY3Rpb25cIiwgIFxuXHRvYnNEZWJ1Z19UZXh0OiBcIllcIixcblx0b2JzRGVidWdQb3J0X1RleHQ6IFwiOTIyMlwiXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB1dWhpbXN5UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcblx0c2V0dGluZ3M6IHV1aGltc3lQbHVnaW5TZXR0aW5ncztcblx0XG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpe1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKFxuXHRcdFx0e30sIFxuXHRcdFx0REVGQVVMVF9TRVRUSU5HUyxcblx0XHRcdGF3YWl0IHRoaXMubG9hZERhdGEoKVxuXHRcdCk7XG5cdH1cblx0XG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpe1xuXHRcdHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG5cdH1cblx0XHRcblx0YXN5bmMgb25sb2FkKCkge1xuXG5cdFx0YXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcblx0XHRcblx0XHRcblx0XHR0aGlzLmFkZFNldHRpbmdUYWIobmV3IHV1aGltc3lTZXR0aW5nc1RhYih0aGlzLmFwcCwgdGhpcykpXG5cdFx0XG5cdFx0bmV3IE5vdGljZShcIkVuYWJsZWQgT1NDIHBsdWdpblwiKVx0XG5cdFx0bmV3IE5vdGljZSh0aGlzLnNldHRpbmdzLndlYnNvY2tldElQX1RleHQpXHRcblx0XHRuZXcgTm90aWNlKHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0Rpcilcblx0XHRcdCBcbi8vXG4vL1xuLy9cdFx0IFxuLy9cdCNyZWdpb24gT1NDIFNlcnZlciBjb25uZWN0aW9uIGZlYXR1cmVcbi8vXG4vLyBcbi8vXHRcdFxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ3N0YXJ0LW9zYy10by13ZWJzb2NrZXQnLFxuXHRcdFx0bmFtZTogJ1N0YXJ0IE9TQyB0byBPQlMgV2Vic29ja2V0IGNvbm5lY3Rpb24nLFxuXHRcdFx0Y2FsbGJhY2s6KCkgPT4ge1xuXHRcdFx0Ly90aGlzLmFkZFJpYmJvbkljb24oXCJhY3Rpdml0eVwiLFwic3RhcnQgT1NDIHRvIFdlYnNvY2tldFwiLCAoKSA9Pntcblx0XHRcdG5ldyBOb3RpY2UoXCJTdGFydGluZyBPU0MgU2VydmVyXCIpXG5cdFx0XHR2YXIgd2Vic29ja2V0SVAgPSB0aGlzLnNldHRpbmdzLndlYnNvY2tldElQX1RleHQ7XG5cdFx0XHR2YXIgd2Vic29ja2V0UG9ydCA9IHRoaXMuc2V0dGluZ3Mud2Vic29ja2V0UG9ydF9UZXh0O1xuXHRcdFx0dmFyIHdlYnNvY2tldFBhc3N3b3JkID0gdGhpcy5zZXR0aW5ncy53ZWJzb2NrZXRQV19UZXh0O1xuXHRcdFx0dmFyIG9zY0lQID0gdGhpcy5zZXR0aW5ncy5vc2NJUF9UZXh0O1xuXHRcdFx0dmFyIG9zY0luUE9SVCA9IHRoaXMuc2V0dGluZ3Mub3NjSW5Qb3J0X1RleHQ7XG5cdFx0XHR2YXIgb3NjT3V0UE9SVCA9IHRoaXMuc2V0dGluZ3Mub3NjT3V0UG9ydF9UZXh0O1xuXHRcdFx0XG5cdFx0XHRzZXRPU0Njb25uZWN0aW9uKFxuXHRcdFx0XHR3ZWJzb2NrZXRJUCxcblx0XHRcdFx0d2Vic29ja2V0UG9ydCxcblx0XHRcdFx0d2Vic29ja2V0UGFzc3dvcmQsXG5cdFx0XHRcdG9zY0lQLFxuXHRcdFx0XHRvc2NJblBPUlQsXG5cdFx0XHRcdG9zY091dFBPUlRcblx0XHRcdCk7XG5cdFx0XHRcblx0XHRcdGFzeW5jIGZ1bmN0aW9uIHNldE9TQ2Nvbm5lY3Rpb24oXG5cdFx0XHRcdHdlYnNvY2tldElQLFxuXHRcdFx0XHR3ZWJzb2NrZXRQb3J0LFxuXHRcdFx0XHR3ZWJzb2NrZXRQYXNzd29yZCxcblx0XHRcdFx0b3NjSVAsXG5cdFx0XHRcdG9zY0luUE9SVCxcblx0XHRcdFx0b3NjT3V0UE9SVFxuXHRcdFx0KSB7XG5cdFx0XHRcdFxuXHRcdFx0XHQvKlxuXHRcdFx0XHQqQ29ubmVjdCB0aGlzIGFwcCB0byBPQlNcblx0XHRcdFx0KiBcblx0XHRcdFx0Ki9cblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IG9icyA9IG5ldyBPQlNXZWJTb2NrZXQod2Vic29ja2V0SVAsIHdlYnNvY2tldFBvcnQsIHdlYnNvY2tldFBhc3N3b3JkKTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRjb25zdCB7IG9ic1dlYlNvY2tldFZlcnNpb24sIG5lZ290aWF0ZWRScGNWZXJzaW9uIH0gPSBhd2FpdCBvYnMuY29ubmVjdChcblx0XHRcdFx0XHRcdGB3czovLyR7d2Vic29ja2V0SVB9OiR7d2Vic29ja2V0UG9ydH1gLFxuXHRcdFx0XHRcdFx0d2Vic29ja2V0UGFzc3dvcmQsXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHJwY1ZlcnNpb246IDEsXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcblx0XHRcdFx0XHRcdGBDb25uZWN0ZWQgdG8gc2VydmVyICR7b2JzV2ViU29ja2V0VmVyc2lvbn0gKHVzaW5nIFJQQyAke25lZ290aWF0ZWRScGNWZXJzaW9ufSlgXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiQ29ubmVjdGVkIHRvIE9CUyBXZWJTb2NrZXQgU2VydmVyXCIpXG5cdFx0XHRcdFx0aW5pdFdlYnNvY2tldEZ1bmN0aW9ucygpO1xuXHRcdFx0XHRcdC8vZG9jdW1lbnQudGl0bGUgPSBcImNvbm5lY3Rpb24gc2V0XCI7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIkZhaWxlZCB0byBjb25uZWN0IHRvIE9CUyBXZWJTb2NrZXQgU2VydmVyXCIpXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjb25uZWN0XCIsIGVycm9yLmNvZGUsIGVycm9yLm1lc3NhZ2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZnVuY3Rpb24gaW5pdFdlYnNvY2tldEZ1bmN0aW9ucygpe1xuXG5cdFx0XHRcdFx0b2JzLm9uKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcihcIlNvY2tldCBlcnJvcjpcIiwgZXJyKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhgd3M6Ly8ke3dlYnNvY2tldElQfToke3dlYnNvY2tldFBvcnR9YCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Lypcblx0XHRcdFx0XHQqQ3JlYXRlIGFuIE9TQyBTZXJ2ZXIgY29ubmVjdGlvblxuXHRcdFx0XHRcdCpPU0MgYXBwIC0tIHRvLS0+IE9CU1xuXHRcdFx0XHRcdCovXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dmFyIG9zY1NlcnZlciA9IG5ldyBTZXJ2ZXIob3NjSW5QT1JULCBvc2NJUCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0b3NjU2VydmVyLm9uKFwibGlzdGVuaW5nXCIsICgpID0+IHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiT1NDIFNlcnZlciBpcyBsaXN0ZW5pbmcuXCIpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdG9zY1NlcnZlci5vbihcIm1lc3NhZ2VcIiwgKG1zZykgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coYE1lc3NhZ2U6ICR7bXNnfWApO1xuXHRcdFx0XHRcdFx0c2VuZFRvT0JTKG1zZywgb2JzLCBcIm9zYy1tZXNzYWdlXCIpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGZ1bmN0aW9uIHNlbmRUb09CUyhtc2dQYXJhbSwgb2JzUGFyYW0sIGV2ZW50TmFtZSkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJzZW5kaW5nIG1lc3NhZ2U6XCIsIEpTT04uc3RyaW5naWZ5KG1zZ1BhcmFtKSk7XG5cdFx0XHRcdFx0XHRjb25zdCB3ZWJTb2NrZXRNZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkobXNnUGFyYW0pO1xuXHRcdFx0XHRcdFx0Ly9zZW5kIHJlc3VsdHMgdG8gT0JTIEJyb3dzZXIgU291cmNlXG5cdFx0XHRcdFx0XHRvYnNQYXJhbS5jYWxsKFwiQ2FsbFZlbmRvclJlcXVlc3RcIiwge1xuXHRcdFx0XHRcdFx0XHR2ZW5kb3JOYW1lOiBcIm9icy1icm93c2VyXCIsXG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcImVtaXRfZXZlbnRcIixcblx0XHRcdFx0XHRcdFx0cmVxdWVzdERhdGE6IHtcblx0XHRcdFx0XHRcdFx0XHRldmVudF9uYW1lOiBldmVudE5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0ZXZlbnRfZGF0YTogeyB3ZWJTb2NrZXRNZXNzYWdlIH0sXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHQvKlxuXHRcdFx0XHQqQ3JlYXRlIE9TQyBDbGllbnQgT3V0IFBvcnRcblx0XHRcdFx0Km1lc3NhZ2UgZnJvbSBPQlMgLS10by0tPiBPU0MgYXBwXG5cdFx0XHRcdCovXG5cdFx0XHRcdGNvbnN0IG9zY0NsaWVudCA9IG5ldyBDbGllbnQob3NjSVAsIG9zY091dFBPUlQpO1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcIm9zY0NsaWVudFwiLCBvc2NDbGllbnQsIG9zY0lQLCBvc2NPdXRQT1JULCBvc2NJblBPUlQpO1xuXHRcdFx0XHRcblx0XHRcdFx0b2JzLm9uKFwiQ3VzdG9tRXZlbnRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJNZXNzYWdlIGZyb20gT0JTXCIsZXZlbnQpO1xuXHRcdFx0XHRcdGlmIChldmVudC5ldmVudF9uYW1lID09PSBcIk9TQy1vdXRcIikge1xuXHRcdFx0XHRcdFx0Y29uc3QgbWVzc2FnZSA9IG5ldyBNZXNzYWdlKGV2ZW50LmFkZHJlc3MpO1xuXHRcdFx0XHRcdFx0aWYgKE9iamVjdC5oYXNPd24oZXZlbnQsIFwiYXJnMVwiKSkge1xuXHRcdFx0XHRcdFx0XHRtZXNzYWdlLmFwcGVuZChldmVudC5hcmcxKTtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJhcmcxXCIsIG1lc3NhZ2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKE9iamVjdC5oYXNPd24oZXZlbnQsIFwiYXJnMlwiKSkge1xuXHRcdFx0XHRcdFx0XHRtZXNzYWdlLmFwcGVuZChldmVudC5hcmcyKTtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2cobWVzc2FnZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoT2JqZWN0Lmhhc093bihldmVudCwgXCJhcmczXCIpKSB7XG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2UuYXBwZW5kKGV2ZW50LmFyZzMpO1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhtZXNzYWdlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChPYmplY3QuaGFzT3duKGV2ZW50LCBcImFyZzRcIikpIHtcblx0XHRcdFx0XHRcdFx0bWVzc2FnZS5hcHBlbmQoZXZlbnQuYXJnNCk7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKE9iamVjdC5oYXNPd24oZXZlbnQsIFwiYXJnNVwiKSkge1xuXHRcdFx0XHRcdFx0XHRtZXNzYWdlLmFwcGVuZChldmVudC5hcmc1KTtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2cobWVzc2FnZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoT2JqZWN0Lmhhc093bihldmVudCwgXCJhcmc2XCIpKSB7XG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2UuYXBwZW5kKGV2ZW50LmFyZzYpO1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhtZXNzYWdlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChPYmplY3QuaGFzT3duKGV2ZW50LCBcImFyZzdcIikpIHtcblx0XHRcdFx0XHRcdFx0bWVzc2FnZS5hcHBlbmQoZXZlbnQuYXJnNyk7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJtZXNzYWdlIHRvIE9TQyBkZXZpY2VcIiwgbWVzc2FnZSk7XG5cdFx0XHRcdFx0XHRvc2NDbGllbnQuc2VuZChtZXNzYWdlLCAoZXJyKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKG5ldyBFcnJvcihlcnIpKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHQvL2NsaWVudC5zZW5kKGAke2V2ZW50LmNvbW1hbmR9IFwiJHtldmVudC5kYXRhfVwiYClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fX0pXG5cdFx0XG4vLyAjZW5kcmVnaW9uXG5cbi8vIFxuLy9cbi8vXHRcbi8vXHQjcmVnaW9uIEdldCBTY2VuZXMgZnJvbSBPQlMgZmVhdHVyZVxuLy8gIDEuIHBvcHVsYXRlIHRoZSBfc2xpZGVfVGFncyBmb2xkZXIgd2l0aCBPQlMgU2NlbmVzXG4vL1x0Mi4gQWRkIHRhZ3MgdG8gc2xpZGVzXG4vL1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ2dldC1vYnMtc2NlbmUtdGFncycsXG5cdFx0XHRuYW1lOiAnR2V0IE9CUyBTY2VuZSB0YWdzJyxcblx0XHRcdGNhbGxiYWNrOiBhc3luYygpID0+IHtcblx0XHQgLy90aGlzLmFkZFJpYmJvbkljb24oXCJpbWFnZS1kb3duXCIsXCJnZXQgT0JTIFNjZW5lIE9wdGlvbnNcIiwgYXN5bmMgKCkgPT57XG5cdFx0XHRuZXcgTm90aWNlKFwiR2V0IE9CUyBTY2VuZXNcIilcblx0XHRcdHZhciB3ZWJzb2NrZXRJUCA9IHRoaXMuc2V0dGluZ3Mud2Vic29ja2V0SVBfVGV4dDtcblx0XHRcdHZhciB3ZWJzb2NrZXRQb3J0ID0gdGhpcy5zZXR0aW5ncy53ZWJzb2NrZXRQb3J0X1RleHQ7XG5cdFx0XHR2YXIgd2Vic29ja2V0UGFzc3dvcmQgPSB0aGlzLnNldHRpbmdzLndlYnNvY2tldFBXX1RleHQ7XG5cdFx0XHRcblx0XHRcdC8qXG5cdFx0XHQqQ29ubmVjdCB0aGlzIGFwcCB0byBPQlNcblx0XHRcdCovXG5cdFx0XHRjb25zdCBvYnMgPSBuZXcgT0JTV2ViU29ja2V0KHdlYnNvY2tldElQLCB3ZWJzb2NrZXRQb3J0LCB3ZWJzb2NrZXRQYXNzd29yZCk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zdCB7IG9ic1dlYlNvY2tldFZlcnNpb24sIG5lZ290aWF0ZWRScGNWZXJzaW9uIH0gPSBhd2FpdCBvYnMuY29ubmVjdChcblx0XHRcdFx0XHRgd3M6Ly8ke3dlYnNvY2tldElQfToke3dlYnNvY2tldFBvcnR9YCxcblx0XHRcdFx0XHR3ZWJzb2NrZXRQYXNzd29yZCxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRycGNWZXJzaW9uOiAxLFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdFx0Y29uc29sZS5sb2coXG5cdFx0XHRcdFx0YENvbm5lY3RlZCB0byBzZXJ2ZXIgJHtvYnNXZWJTb2NrZXRWZXJzaW9ufSAodXNpbmcgUlBDICR7bmVnb3RpYXRlZFJwY1ZlcnNpb259KWBcblx0XHRcdFx0KTtcblx0XHRcdFx0bmV3IE5vdGljZShcIkNvbm5lY3RlZCB0byBPQlMgV2ViU29ja2V0IFNlcnZlclwiKVxuXHRcdFx0XHQvL2RvY3VtZW50LnRpdGxlID0gXCJjb25uZWN0aW9uIHNldFwiO1xuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0bmV3IE5vdGljZShcIkZhaWxlZCB0byBjb25uZWN0IHRvIE9CUyBXZWJTb2NrZXQgU2VydmVyXCIpXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY29ubmVjdFwiLCBlcnJvci5jb2RlLCBlcnJvci5tZXNzYWdlKTtcblx0XHRcdH1cblx0XHRcdG9icy5vbihcImVycm9yXCIsIChlcnIpID0+IHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihcIlNvY2tldCBlcnJvcjpcIiwgZXJyKTtcblx0XHRcdH0pO1xuXHRcdFx0Y29uc29sZS5sb2coYHdzOi8vJHt3ZWJzb2NrZXRJUH06JHt3ZWJzb2NrZXRQb3J0fWApO1xuXHRcdFx0XG5cdFx0XHQvL1xuXHRcdFx0Ly8gR2V0IFNjZW5lcyBhbmQgY2FtZXJhXG5cdFx0XHQvL1xuXHRcdFx0Ly9zZXRUaW1lb3V0KCgpID0+IG9icy5kaXNjb25uZWN0KCksIDMwMDApO1xuXHRcdFx0XG5cdFx0XHQvL2NyZWF0ZSBTY2VuZSBUZW1wbGF0ZSBOb3Rlc1xuXHRcdFx0XHRjb25zdCBzY2VuZUxpc3QgPSBhd2FpdCBvYnMuY2FsbChcIkdldFNjZW5lTGlzdFwiKTtcblx0XHRcdFx0Y29uc29sZS5sb2coc2NlbmVMaXN0KVxuXHRcdFx0XHRzY2VuZUxpc3Quc2NlbmVzLmZvckVhY2goYXN5bmMgKHNjZW5lLCBpbmRleCkgPT4ge1xuXHRcdFx0XHRcdC8vIGZpbmQgc2NlbmVzIHN0YXJ0aW5nIHdpdGggXCJzY2VuZVwiXG5cdFx0XHRcdFx0aWYgKHNjZW5lLnNjZW5lTmFtZS5zdGFydHNXaXRoKFwic2NlbmV8fHxcIikpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHNjZW5lTmFtZSA9IHNjZW5lLnNjZW5lTmFtZS5zcGxpdChcInx8fFwiKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0bGV0IGZpbGVOYW1lID0gYEVudHJhbmNlIFNjZW5lIC0gJHtzY2VuZU5hbWVbMV19YDtcblx0XHRcdFx0XHRcdGxldCBleGlzdGluZyA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKG5vcm1hbGl6ZVBhdGgoYF9zbGlkZV9UYWdzLyR7ZmlsZU5hbWV9YCkpO1xuXHRcdFx0XHRcdFx0aWYgKCFleGlzdGluZykge1xuXHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUoYF9zbGlkZV9UYWdzLyR7ZmlsZU5hbWV9Lm1kYCwgXG5cdFx0XHRcdFx0XHRcdFx0YDwhLS0gc2xpZGUgZGF0YS1zY2VuZS1lbnRyYW5jZT1cIiR7c2NlbmVOYW1lWzFdfVwiIC0tPiBgLFxuXHRcdFx0XHRcdFx0XHQpO1x0XHRcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZmlsZU5hbWUgPSBgRXhpdCBTY2VuZSAtICR7c2NlbmVOYW1lWzFdfWA7XG5cdFx0XHRcdFx0XHRleGlzdGluZyA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKG5vcm1hbGl6ZVBhdGgoYF9zbGlkZV9UYWdzLyR7ZmlsZU5hbWV9YCkpO1xuXHRcdFx0XHRcdFx0aWYgKCFleGlzdGluZykge1xuXHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUoYF9zbGlkZV9UYWdzLyR7ZmlsZU5hbWV9Lm1kYCwgXG5cdFx0XHRcdFx0XHRcdFx0YDwhLS0gc2xpZGUgZGF0YS1zY2VuZS1leGl0PVwiJHtzY2VuZU5hbWVbMV19XCIgLS0+IGAsXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cdFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Ly99XG5cdFx0XHRcdFxuXHRcdFx0Ly9jcmVhdGUgQ2FtZXJhIFRlbXBsYXRlIE5vdGVzXG5cdFx0XHRcdGxldCBjYW1lcmFTb3VyY2VzID0gYXdhaXQgb2JzLmNhbGwoXCJHZXRTY2VuZUl0ZW1MaXN0XCIsIHsgc2NlbmVOYW1lOiBcIklucHV0IENhbWVyYVwiIH0pO1xuXHRcdFx0XHRjYW1lcmFTb3VyY2VzLnNjZW5lSXRlbXMuZm9yRWFjaChhc3luYyhzb3VyY2UsIGluZGV4KSA9PiB7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdGxldCBmaWxlTmFtZSA9IGBFbnRyYW5jZSBDYW1lcmEgLSAke3NvdXJjZS5zb3VyY2VOYW1lfWA7XG5cdFx0XHRcdFx0bGV0IGV4aXN0aW5nID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5leGlzdHMobm9ybWFsaXplUGF0aChgX3NsaWRlX1RhZ3MvJHtmaWxlTmFtZX1gKSk7XG5cdFx0XHRcdFx0aWYgKCFleGlzdGluZykge1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKGBfc2xpZGVfVGFncy8ke2ZpbGVOYW1lfS5tZGAsIFxuXHRcdFx0XHRcdFx0XHRgPCEtLSBzbGlkZSBkYXRhLWNhbWVyYS1lbnRyYW5jZT1cIiR7c291cmNlLnNvdXJjZU5hbWV9XCIgLS0+IGAsXG5cdFx0XHRcdFx0XHQpO1x0XHRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0ZmlsZU5hbWUgPSBgRXhpdCBDYW1lcmEgLSAke3NvdXJjZS5zb3VyY2VOYW1lfWA7XG5cdFx0XHRcdFx0ZXhpc3RpbmcgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLmV4aXN0cyhub3JtYWxpemVQYXRoKGBfc2xpZGVfVGFncy8ke2ZpbGVOYW1lfWApKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoIWV4aXN0aW5nKSB7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUoYF9zbGlkZV9UYWdzLyR7ZmlsZU5hbWV9Lm1kYCwgXG5cdFx0XHRcdFx0XHRcdGA8IS0tIHNsaWRlIGRhdGEtY2FtZXJhLWV4aXQ9XCIke3NvdXJjZS5zb3VyY2VOYW1lfVwiIC0tPiBgLFxuXHRcdFx0XHRcdFx0XHQpO1x0XHRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuICAgICAgICAgICAgIC8vRW5kIG9mIGdldCBzY2VuZSBmdW5jdGlvblxuXHRcdFx0fX0pXG5cblx0XHRcdC8vIHRoaXMuYWRkUmliYm9uSWNvbihcInNjcm9sbFwiLCBcImVudHJhbmNlIHRhZ1wiLCAoKSA9PiB7XG5cdFx0XHQvLyBcdG5ldyBVVWhpbXN5RW50cmFuY2VTdWdnZXN0KHRoaXMuYXBwKS5vcGVuKCk7XG5cdFx0XHQvLyB9KVxuXG5cdFx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0XHRpZDogJ2luc2VydC1lbnRyYW5jZS10YWcnLFxuXHRcdFx0XHRuYW1lOiAnSW5zZXJ0IHNsaWRlIGVudHJhbmNlIHRhZycsXG5cdFx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRcdG5ldyBVVWhpbXN5RW50cmFuY2VTdWdnZXN0KHRoaXMuYXBwKS5vcGVuKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0XHRpZDogJ2luc2VydC1leGl0LXRhZycsXG5cdFx0XHRcdG5hbWU6ICdJbnNlcnQgc2xpZGUgZXhpdCB0YWcnLFxuXHRcdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0XHRuZXcgVVVoaW1zeUV4aXRTdWdnZXN0KHRoaXMuYXBwKS5vcGVuKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuLy8gI2VuZHJlZ2lvblxuXG4vLyBcbi8vXG4vL1x0XHRcbi8vICNyZWdpb24gU2VuZCBQVFogY2FtZXJhIHBvc2l0aW9uIHRvIE9CUyBmZWF0dXJlXG4vLyAgT25seSBzaG93IHRoaXMgY29tbWFuZCB0byBtYWNPUyB1c2Vyc1xuLy9cbi8vXHRTZW5kIGEgUFRaIGNhbWVyYSBwb3NpdGlvbiBtZXNzYWdlIGV2ZXJ5IHNlY29uZFxuXHRcdFxuXHRcdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdFx0aWQ6ICdzZW5kLWNhbWVyYS1wb3NpdGlvbi10by1vYnMnLFxuXHRcdFx0XHRuYW1lOiAnU3RhcnQgc2VuZGluZyBjYW1lcmEgUFRaIHBvc2l0aW9uIHRvIE9CUycsXG5cdFx0XHRcdGNoZWNrQ2FsbGJhY2s6IGFzeW5jKGNoZWNraW5nKSA9PiB7XG5cdFx0XHRcdFx0bGV0IGlzTWFjID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2Rhcndpbic7XG5cdFx0XHRcdFx0aWYgKGlzTWFjKXtcblx0XHRcdFx0XHRcdGlmKCFjaGVja2luZyl7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcInRydWVcIilcblx0XHRcdFx0XHRcdFx0dmFyIHdlYnNvY2tldElQID0gdGhpcy5zZXR0aW5ncy53ZWJzb2NrZXRJUF9UZXh0O1xuXHRcdFx0XHRcdFx0XHR2YXIgd2Vic29ja2V0UG9ydCA9IHRoaXMuc2V0dGluZ3Mud2Vic29ja2V0UG9ydF9UZXh0O1xuXHRcdFx0XHRcdFx0XHR2YXIgd2Vic29ja2V0UGFzc3dvcmQgPSB0aGlzLnNldHRpbmdzLndlYnNvY2tldFBXX1RleHQ7XG5cdFx0XHRcblx0XHRcdC8qXG5cdFx0XHQqQ29ubmVjdCB0aGlzIGFwcCB0byBPQlNcblx0XHRcdCovXG5cdFx0XHRjb25zdCBvYnMgPSBuZXcgT0JTV2ViU29ja2V0KHdlYnNvY2tldElQLCB3ZWJzb2NrZXRQb3J0LCB3ZWJzb2NrZXRQYXNzd29yZCk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zdCB7IG9ic1dlYlNvY2tldFZlcnNpb24sIG5lZ290aWF0ZWRScGNWZXJzaW9uIH0gPSBhd2FpdCBvYnMuY29ubmVjdChcblx0XHRcdFx0XHRgd3M6Ly8ke3dlYnNvY2tldElQfToke3dlYnNvY2tldFBvcnR9YCxcblx0XHRcdFx0XHR3ZWJzb2NrZXRQYXNzd29yZCxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRycGNWZXJzaW9uOiAxLFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdFx0Y29uc29sZS5sb2coXG5cdFx0XHRcdFx0YENvbm5lY3RlZCB0byBzZXJ2ZXIgJHtvYnNXZWJTb2NrZXRWZXJzaW9ufSAodXNpbmcgUlBDICR7bmVnb3RpYXRlZFJwY1ZlcnNpb259KWBcblx0XHRcdFx0KTtcblx0XHRcdFx0bmV3IE5vdGljZShcIkNvbm5lY3RlZCB0byBPQlMgV2ViU29ja2V0IFNlcnZlclwiKVxuXHRcdFx0XHQvL2RvY3VtZW50LnRpdGxlID0gXCJjb25uZWN0aW9uIHNldFwiO1xuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0bmV3IE5vdGljZShcIkZhaWxlZCB0byBjb25uZWN0IHRvIE9CUyBXZWJTb2NrZXQgU2VydmVyXCIpXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY29ubmVjdFwiLCBlcnJvci5jb2RlLCBlcnJvci5tZXNzYWdlKTtcblx0XHRcdH1cblx0XHRcdG9icy5vbihcImVycm9yXCIsIChlcnIpID0+IHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihcIlNvY2tldCBlcnJvcjpcIiwgZXJyKTtcblx0XHRcdH0pO1xuXHRcdFx0Y29uc29sZS5sb2coYHdzOi8vJHt3ZWJzb2NrZXRJUH06JHt3ZWJzb2NrZXRQb3J0fWApO1xuXG5cdFx0XHQvL1xuXHRcdFx0Ly9QVFogZGV0YWlsc1xuXHRcdFx0Ly9cblxuXHRcdFx0Ly9odHRwczovL2ZvcnVtLm9ic2lkaWFuLm1kL3QvaG93LXRvLWdldC12YXVsdC1hYnNvbHV0ZS1wYXRoLzIyOTY1XG5cdFx0XHQvL0B0cy1pZ25vcmVcbi8vLy8vLy8vLy8vbWFrZSB2YXVsdFBhdGggYW4gb25Mb2FkIGdsb2JhbCB2YXJpYWJsZVxuXHRcdFx0Y29uc3QgdmF1bHRQYXRoID0gbm9ybWFsaXplUGF0aChgJHt0aGlzLmFwcC52YXVsdC5hZGFwdGVyLmJhc2VQYXRofS8ke3RoaXMuYXBwLnZhdWx0LmNvbmZpZ0Rpcn0vcGx1Z2lucy9VVWhpbXN5UGx1Z2luYClcblx0XHRcdGNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cdFx0XHRjb25zdCBleGVjID0gdXRpbC5wcm9taXNpZnkocmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWMpO1xuXHRcdFx0bGV0IHByZXZpb3VzUFRaID1cIlwiO1xuXHRcdFx0XG5cdFx0XHRzZXRJbnRlcnZhbCggYXN5bmMoKSA9PntcblxuXHRcdFx0XHRsZXQgcHQgPSBhd2FpdCBnZXRDYW1lcmFQYW5UaWx0KHZhdWx0UGF0aCwgdXRpbCwgZXhlYyk7XG5cdFx0XHRcdGxldCB6ID0gYXdhaXQgZ2V0Q2FtZXJhWm9vbSh2YXVsdFBhdGgsIHV0aWwsIGV4ZWMpO1xuXHRcdFx0XHRsZXQgcHR6TWVzc2FnZSA9IGAke3B0fSR7en19YFxuXHRcdFx0XHRcblx0XHRcdFx0aWYocHR6TWVzc2FnZSAhPSBwcmV2aW91c1BUWil7XG5cdFx0XHRcdFx0Ly9zZW5kIHJlc3VsdHMgdG8gT0JTXG5cdFx0XHRcdFx0cHJldmlvdXNQVFogPSBwdHpNZXNzYWdlXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly9zZW5kIHJlc3VsdHMgdG8gdGV4dCBzb3VyY2Vcblx0XHRcdFx0XHRhd2FpdCBvYnMuY2FsbChcIlNldElucHV0U2V0dGluZ3NcIiwge1xuXHRcdFx0XHRcdFx0aW5wdXROYW1lOiAnUFRaIHZhbHVlcycsXG5cdFx0XHRcdFx0XHRpbnB1dFNldHRpbmdzOiB7XG5cdFx0XHRcdFx0XHRcdHRleHQ6IGAke3B0ek1lc3NhZ2V9YCxcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvL3NlbmQgcmVzdWx0cyB0byBPQlMgQnJvd3NlciBTb3VyY2Vcblx0XHRcdFx0XHRvYnMuY2FsbChcIkNhbGxWZW5kb3JSZXF1ZXN0XCIsIHtcblx0XHRcdFx0XHRcdHZlbmRvck5hbWU6IFwib2JzLWJyb3dzZXJcIixcblx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcImVtaXRfZXZlbnRcIixcblx0XHRcdFx0XHRcdHJlcXVlc3REYXRhOiB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50X25hbWU6IFwicHR6LW1lc3NhZ2VcIixcblx0XHRcdFx0XHRcdFx0ZXZlbnRfZGF0YTogeyBwdHpNZXNzYWdlIH0sXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCAyMDAwKTtcblxuXHRcdFx0YXN5bmMgZnVuY3Rpb24gZ2V0Q2FtZXJhUGFuVGlsdCh2YXVsdFBhdGgsIHV0aWwsIGV4ZWMpIHtcdFx0XHRcdFxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zb2xlLmxvZyh2YXVsdFBhdGgpXG5cdFx0XHRcdGNvbnN0IHsgc3Rkb3V0LCBzdGRlcnIgfSA9IGF3YWl0IGV4ZWMoYCcke3ZhdWx0UGF0aH0vdXZjLXV0aWwnIC1JIDAgLW8gcGFuLXRpbHQtYWJzYCk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ3N0ZG91dDonLCBzdGRvdXQpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdzdGRlcnI6Jywgc3RkZXJyKTtcblx0XHRcdFx0bGV0IHB0UmVzdWx0ID0gc3Rkb3V0LnRvU3RyaW5nKCk7XG5cdFx0XHRcdHB0UmVzdWx0ID0gcHRSZXN1bHQucmVwbGFjZSgvXFxuL2csJycpLnJlcGxhY2UoJ3BhbicsJ1wicGFuXCInKS5yZXBsYWNlKCd9JywnLCBcInpvb21cIjogJykucmVwbGFjZSgvPS9nLCc6ICcpLnJlcGxhY2UoJ3RpbHQnLCdcInRpbHRcIicpXG5cdFx0XHRcdHJldHVybiBwdFJlc3VsdDtcblx0XHRcdFx0XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0ICBjb25zb2xlLmVycm9yKGUpOyAvLyBzaG91bGQgY29udGFpbiBjb2RlIChleGl0IGNvZGUpIGFuZCBzaWduYWwgKHRoYXQgY2F1c2VkIHRoZSB0ZXJtaW5hdGlvbikuXG5cdFx0XHRcdH1cblx0XHRcdCAgfVxuXG5cdFx0XHRhc3luYyBmdW5jdGlvbiBnZXRDYW1lcmFab29tKHZhdWx0UGF0aCwgdXRpbCwgZXhlYykge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zdCB7IHN0ZG91dCwgc3RkZXJyIH0gPSBhd2FpdCBleGVjKGAnJHt2YXVsdFBhdGh9L3V2Yy11dGlsJyAtSSAwIC1vIHpvb20tYWJzYCk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ3N0ZG91dDonLCBzdGRvdXQpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdzdGRlcnI6Jywgc3RkZXJyKTtcblx0XHRcdFx0cmV0dXJuIHN0ZG91dC5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG5cdFx0XHRcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHQgIGNvbnNvbGUuZXJyb3IoZSk7IC8vIHNob3VsZCBjb250YWluIGNvZGUgKGV4aXQgY29kZSkgYW5kIHNpZ25hbCAodGhhdCBjYXVzZWQgdGhlIHRlcm1pbmF0aW9uKS5cblx0XHRcdFx0fVxuXHRcdFx0ICB9XG5cdFx0XHRcblx0XHRcdCAgb2JzLm9uKFwiQ3VzdG9tRXZlbnRcIiwgYXN5bmMgZnVuY3Rpb24gKGV2ZW50KXtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiTWVzc2FnZSBmcm9tIE9CU1wiLGV2ZW50KTtcblx0XHRcdFx0aWYgKGV2ZW50LmV2ZW50X25hbWUgPT09IFwic2V0LXB0elwiKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ2NvbW1hbmQnLGAnc2hvcnRjdXRzJyBydW4gJHtldmVudC5zaG9ydGN1dF9uYW1lfWApXG5cdFx0XHRcdFx0Y29uc3Qgc3Rkb3V0ID0gIGF3YWl0IGV4ZWMoYCcke3ZhdWx0UGF0aH0vdXZjLXV0aWwnIC1JIDAgLW8gcGFuLXRpbHQtYWJzYCk7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coc3Rkb3V0KVxuXHRcdFx0XHR9XG5cdFx0XHQgIH0pXG5cblx0XHRcdFx0Ly9lbmQgY2hlY2tpbmcgXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHQvL2VuZCBnZXQgUFRaIGNvbW1hbmRcdFxuXHRcdFx0fSk7XG5cblxuXHQvL3N0b3Agc2VuZGluZyBjYW1lcmEgcG9zaXRpb25cdFx0XG5cdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0aWQ6ICdzdG9wLWNhbWVyYS1wb3NpdGlvbi10by1vYnMnLFxuXHRcdG5hbWU6ICdTdG9wIHNlbmRpbmcgY2FtZXJhIFBUWiBwb3NpdGlvbiB0byBPQlMnLFxuXHRcdGNhbGxiYWNrOigpID0+e1xuXHRcdFx0Ly8gU2V0IGEgZmFrZSB0aW1lb3V0IHRvIGdldCB0aGUgaGlnaGVzdCB0aW1lb3V0IGlkXG5cdFx0XHR2YXIgaGlnaGVzdFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoXCI7XCIpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAgOyBpIDwgaGlnaGVzdFRpbWVvdXRJZCA7IGkrKykge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoaSk7IFxuXHRcdFx0fVxuXHRcdH1cblxuXHR9KVxuXG4vLyAjZW5kcmVnaW9uXG5cbi8vIFxuLy9cbi8vXHRcdFxuLy8gI3JlZ2lvbiBSdW4gQXBwbGUgU2hvcnRjdXRzIHNjcmlwdCBmZWF0dXJlXG4vLyAgT25seSBzaG93IHRoaXMgY29tbWFuZCB0byBtYWNPUyB1c2Vyc1xuLy9cbi8vXHRSdW4gU2hvcnRjdXRzIGFuZCByZXR1cm4gcmVzdWx0cyBcblxuLy9DT01NQU5EOiBHZXQgbGlzdCBvZiBTaG9ydGN1dCB0YWdzXG50aGlzLmFkZENvbW1hbmQoe1xuXHRpZDogJ2dldC1zaG9ydGN1dHMtdGFncycsXG5cdG5hbWU6ICdHZXQgQXBwbGUgU2hvcnRjdXRzIHRhZ3MnLFxuXHRjaGVja0NhbGxiYWNrOiBhc3luYyhjaGVja2luZykgPT4ge1xuXHRcdGxldCBpc01hYyA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nO1xuXHRcdGlmIChpc01hYyl7XG5cdFx0XHRpZighY2hlY2tpbmcpe1xuXHRcdFx0XHQvL1RoaXMgaXMgYSBNYWMgY29tcHV0ZXIgZnVuIHRoZSBjb21tYW5kXG5cdFx0XHRcdGNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cdFx0XHRcdGNvbnN0IGV4ZWMgPSB1dGlsLnByb21pc2lmeShyZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYyk7XHRcblx0XHRcdFx0Y29uc3QgeyBzdGRvdXQsIHN0ZGVyciB9ID0gYXdhaXQgZXhlYyhgJ3Nob3J0Y3V0cycgbGlzdGApO1xuXHRcdFx0XHQvL2xldCBzaG9ydGN1dHMgPSAgSlNPTi5zdHJpbmdpZnkoc3Rkb3V0KVxuXHRcdFx0XHRsZXQgc2hvcnRjdXRzID0gIHN0ZG91dC5zcGxpdCgnXFxuJylcblxuXHRcdFx0XHRzaG9ydGN1dHMgPSBzaG9ydGN1dHMuZmlsdGVyKChzaG9ydGN1dCkgPT4ge3JldHVybiBzaG9ydGN1dC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJ1dWhpbXN5XCIpfSlcblx0XHRcdFx0Y29uc29sZS5sb2coc2hvcnRjdXRzKTtcblx0XHRcdFx0Y29uc29sZS5sb2codHlwZW9mIHNob3J0Y3V0cyk7XG5cdFx0XHRcdE9iamVjdC5lbnRyaWVzKHNob3J0Y3V0cykuZm9yRWFjaChhc3luYyhba2V5LCBzaG9ydGN1dF0pID0+IHtcblx0XHRcdFx0Ly9zaG9ydGN1dHMuZm9yZWFjaChhc3luYyAoc2hvcnRjdXQsIGluZGV4KSA9PiB7XG5cdFx0XHRcdFx0bGV0IGZpbGVOYW1lID0gYEVudHJhbmNlIFNob3J0Y3V0cyAtICR7c2hvcnRjdXR9Lm1kYDtcblx0XHRcdFx0XHRcdGxldCBleGlzdGluZyA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKG5vcm1hbGl6ZVBhdGgoYF9zbGlkZV9UYWdzLyR7ZmlsZU5hbWV9YCkpO1xuXHRcdFx0XHRcdFx0aWYgKCFleGlzdGluZykge1xuXHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUoYF9zbGlkZV9UYWdzLyR7ZmlsZU5hbWV9YCwgXG5cdFx0XHRcdFx0XHRcdFx0YDwhLS0gc2xpZGUgZGF0YS1zaG9ydGN1dC1lbnRyYW5jZT1cIiR7c2hvcnRjdXR9XCIgLS0+IGAsXG5cdFx0XHRcdFx0XHRcdCk7XHRcdFxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRmaWxlTmFtZSA9IGBFeGl0IFNob3J0Y3V0cyAtICR7c2hvcnRjdXR9Lm1kYDtcblx0XHRcdFx0XHRcdGV4aXN0aW5nID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5leGlzdHMobm9ybWFsaXplUGF0aChgX3NsaWRlX1RhZ3MvJHtmaWxlTmFtZX1gKSk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhmaWxlTmFtZSlcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiZXhpc3RpbmdcIixleGlzdGluZylcblx0XHRcdFx0XHRcdGlmICghZXhpc3RpbmcpIHtcblx0XHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKGBfc2xpZGVfVGFncy8ke2ZpbGVOYW1lfWAsIFxuXHRcdFx0XHRcdFx0XHRcdGA8IS0tIHNsaWRlIGRhdGEtc2hvcnRjdXQtZXhpdD1cIiR7c2hvcnRjdXR9XCIgLS0+IGAsXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXHRcblx0XHRcdH07XG5cdFx0fVxuXHR9IFxufSlcblxuXG4vL0xJU1RFTiBmb3IgU2hvcnRjdXQgUmVxdWVzdFxudGhpcy5hZGRDb21tYW5kKHtcblx0aWQ6ICdydW4tYXBwbGUtc2hvcnRjdXQnLFxuXHRuYW1lOiAnUnVuIEFwcGxlIFNob3J0Y3V0Jyxcblx0Y2FsbGJhY2s6IGFzeW5jKCkgPT4ge1xuXHRcdFxuXHRcdFxuXHRcdC8vY29ubmVjdCB0byBPQlNcblx0XHR2YXIgd2Vic29ja2V0SVAgPSB0aGlzLnNldHRpbmdzLndlYnNvY2tldElQX1RleHQ7XG5cdFx0dmFyIHdlYnNvY2tldFBvcnQgPSB0aGlzLnNldHRpbmdzLndlYnNvY2tldFBvcnRfVGV4dDtcblx0XHR2YXIgd2Vic29ja2V0UGFzc3dvcmQgPSB0aGlzLnNldHRpbmdzLndlYnNvY2tldFBXX1RleHQ7XG5cdFx0XG5cdFx0Lypcblx0XHQqQ29ubmVjdCB0aGlzIGFwcCB0byBPQlNcblx0XHQqL1xuXHRcdGNvbnN0IG9icyA9IG5ldyBPQlNXZWJTb2NrZXQod2Vic29ja2V0SVAsIHdlYnNvY2tldFBvcnQsIHdlYnNvY2tldFBhc3N3b3JkKTtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgeyBvYnNXZWJTb2NrZXRWZXJzaW9uLCBuZWdvdGlhdGVkUnBjVmVyc2lvbiB9ID0gYXdhaXQgb2JzLmNvbm5lY3QoXG5cdFx0XHRcdGB3czovLyR7d2Vic29ja2V0SVB9OiR7d2Vic29ja2V0UG9ydH1gLFxuXHRcdFx0XHR3ZWJzb2NrZXRQYXNzd29yZCxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJwY1ZlcnNpb246IDEsXG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0XHRjb25zb2xlLmxvZyhcblx0XHRcdFx0YENvbm5lY3RlZCB0byBzZXJ2ZXIgJHtvYnNXZWJTb2NrZXRWZXJzaW9ufSAodXNpbmcgUlBDICR7bmVnb3RpYXRlZFJwY1ZlcnNpb259KWBcblx0XHRcdCk7XG5cdFx0XHRuZXcgTm90aWNlKFwiQ29ubmVjdGVkIHRvIE9CUyBXZWJTb2NrZXQgU2VydmVyXCIpXG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdG5ldyBOb3RpY2UoXCJGYWlsZWQgdG8gY29ubmVjdCB0byBPQlMgV2ViU29ja2V0IFNlcnZlclwiKVxuXHRcdFx0Y29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjb25uZWN0XCIsIGVycm9yLmNvZGUsIGVycm9yLm1lc3NhZ2UpO1xuXHRcdH1cblx0XHRvYnMub24oXCJlcnJvclwiLCAoZXJyKSA9PiB7XG5cdFx0XHRjb25zb2xlLmVycm9yKFwiU29ja2V0IGVycm9yOlwiLCBlcnIpO1xuXHRcdH0pO1xuXHRcdGNvbnNvbGUubG9nKGB3czovLyR7d2Vic29ja2V0SVB9OiR7d2Vic29ja2V0UG9ydH1gKTtcblx0XHRcblxuXHRcdC8vbGlzdGVuIGZvciBTaG9ydGN1dCBSZXF1ZXN0XG5cdFx0b2JzLm9uKFwiQ3VzdG9tRXZlbnRcIiwgYXN5bmMgZnVuY3Rpb24gKGV2ZW50KXtcblx0XHRcdGlmIChldmVudC5ldmVudF9uYW1lID09PSBcInJ1bi1zaG9ydGN1dFwiKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwibWVzc2FnZSBmcm9tIE9CU1wiLGV2ZW50KTtcblx0XHRcdFx0Y29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoZXZlbnQuZXZlbnRfZGF0YSkpO1xuXHRcdFx0XHQvL3VwZGF0ZSBPQlMgU291cmNlIENvbW1hbmRUZXh0XG5cdFx0XHRcdGF3YWl0IG9icy5jYWxsKFwiU2V0SW5wdXRTZXR0aW5nc1wiLCB7XG5cdFx0XHRcdFx0aW5wdXROYW1lOiBcIkNvbW1hbmRUZXh0XCIsXG5cdFx0XHRcdFx0aW5wdXRTZXR0aW5nczoge1xuXHRcdFx0XHRcdFx0dGV4dDogYCR7ZXZlbnQuZXZlbnRfbmFtZX0gJHtldmVudC5ldmVudF9kYXRhLnNob3J0Y3V0X25hbWV9YFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdjb21tYW5kJyxgJ3Nob3J0Y3V0cycgcnVuICR7ZXZlbnQuZXZlbnRfZGF0YS5zaG9ydGN1dF9uYW1lfWApXG5cdFx0XHRcdC8vaWYgaGFzIGlucHV0XG5cdFx0XHRcdGxldCBzdGRvdXQgXG5cdFx0XHRcdGlmIChPYmplY3QuaGFzT3duKGV2ZW50LCBcImV2ZW50LmV2ZW50X2RhdGEuc2hvcnRjdXRfaW5wdXRcIikpIHtcblx0XHRcdFx0XHRzdGRvdXQgPSAgZXhlY1N5bmMoYCdzaG9ydGN1dHMnIHJ1biBcIiR7ZXZlbnQuZXZlbnRfZGF0YS5zaG9ydGN1dF9uYW1lfVwiIDw8PCBcIiR7ZXZlbnQuZXZlbnRfZGF0YS5zaG9ydGN1dF9pbnB1dH1cImAse2VuY29kaW5nOiAndXRmOCcsfSk7XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdHN0ZG91dCA9ICBleGVjU3luYyhgJ3Nob3J0Y3V0cycgcnVuIFwiJHtldmVudC5ldmVudF9kYXRhLnNob3J0Y3V0X25hbWV9XCJgLHtlbmNvZGluZzogJ3V0ZjgnLH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwic2hvcnRjdXQgcmVzdWx0IFwiLHN0ZG91dClcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhzdGRlcnIpXG5cdFx0XHRcdC8vSWYgU2hvcnRjdXQgcmV0dXJucyBhIHJlc3VsdCwgdGhlbiBjYWxsIE9CU1xuXHRcdFx0XHQvL1VwZGF0ZSBPQlMgU291cmNlIENvbW1hbmRSZXN1bHRzVGV4dFxuXHRcdFx0XHRhd2FpdCBvYnMuY2FsbChcIlNldElucHV0U2V0dGluZ3NcIiwge1xuXHRcdFx0XHRcdGlucHV0TmFtZTogXCJDb21tYW5kUmVzdWx0c1RleHRcIixcblx0XHRcdFx0XHRpbnB1dFNldHRpbmdzOiB7XG5cdFx0XHRcdFx0ICB0ZXh0OiBgJHtzdGRvdXR9YFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSlcblx0fX0pXG5cbi8vICNlbmRyZWdpb25cblxuXG4vLyBcbi8vXG4vL1x0XHRcbi8vICNyZWdpb24gT3BlbiBPQlMgZmVhdHVyZVxuLy8gIE9ubHkgc2hvdyB0aGlzIGNvbW1hbmQgdG8gbWFjT1MgdXNlcnNcbi8vXG4vL1x0RXhlY3V0ZSBhIGNvbW1hbmQgbGluZSB0byBPcGVuIE9CU1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiAnb3Blbi1vYnMnLFxuXHRcdFx0bmFtZTogJ09wZW4gT0JTJyxcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cdFx0XHRcdGNvbnN0IGV4ZWMgPSB1dGlsLnByb21pc2lmeShyZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYyk7XG5cdFx0XHRcdC8vYnVpbGQgY29tbWFuZCBzdHJpbmdcblx0XHRcdFx0XG5cdFx0XHRcdGxldCBjb21tYW5kU3RyaW5nID1cImhlbGxvXCJcblx0XHRcdFx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG5cdFx0XHRcdFx0Y29tbWFuZFN0cmluZyA9IGBvcGVuIC1uIC1hIFwiJHt0aGlzLnNldHRpbmdzLm9ic0FwcE5hbWVfVGV4dH1cImA7XG5cdFx0XHRcdFx0Y29tbWFuZFN0cmluZyArPSBgIC0tYXJncyAtLWNvbGxlY3Rpb24gXCIke3RoaXMuc2V0dGluZ3Mub2JzQ29sbGVjdGlvbl9UZXh0fVwiYDtcblx0XHRcdFx0XHRjb21tYW5kU3RyaW5nICs9IGAgLS1yZW1vdGUtZGVidWdnaW5nLXBvcnQ9JHt0aGlzLnNldHRpbmdzLm9ic0RlYnVnUG9ydF9UZXh0fWA7XG5cdFx0XHRcdFx0Y29tbWFuZFN0cmluZyArPSBgIC0tcmVtb3RlLWFsbG93LW9yaWdpbnM9aHR0cDovL2xvY2FsaG9zdDoke3RoaXMuc2V0dGluZ3Mub2JzRGVidWdQb3J0X1RleHR9YDtcblx0XHRcdFx0XHRjb21tYW5kU3RyaW5nICs9IGAgLS13ZWJzb2NrZXRfcG9ydCBcIiR7dGhpcy5zZXR0aW5ncy53ZWJzb2NrZXRQb3J0X1RleHR9XCJgO1xuXHRcdFx0XHRcdGNvbW1hbmRTdHJpbmcgKz0gYCAtLXdlYnNvY2tldF9wYXNzd29yZCBcIiR7dGhpcy5zZXR0aW5ncy53ZWJzb2NrZXRQV19UZXh0fVwiYDtcblx0XHRcdFx0XHRjb21tYW5kU3RyaW5nICs9IGAgLS1tdWx0aWA7XG5cdFx0XHRcdFx0ZXhlYyhjb21tYW5kU3RyaW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuXHRcdFx0XHRcdGNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cdFx0XHRcdFx0Y29uc3Qgb2JzUGF0aCA9IGAke3RoaXMuc2V0dGluZ3Mub2JzQXBwUGF0aF9UZXh0fSR7dGhpcy5zZXR0aW5ncy5vYnNBcHBOYW1lX1RleHR9YFxuXHRcdFx0XHRcdGNvbnN0IG9ic0RpciA9IHBhdGguZGlybmFtZShvYnNQYXRoKTtcblx0XHRcdFx0XHRwcm9jZXNzLmNoZGlyKG9ic0Rpcilcblx0XHRcblx0XHRcdFx0XHRjb21tYW5kU3RyaW5nID0gYCR7dGhpcy5zZXR0aW5ncy5vYnNBcHBOYW1lX1RleHR9YDtcblx0XHRcdFx0XHRjb21tYW5kU3RyaW5nICs9IGAgLS1hcmdzIC0tY29sbGVjdGlvbiBcIiR7dGhpcy5zZXR0aW5ncy5vYnNDb2xsZWN0aW9uX1RleHR9XCJgO1xuXHRcdFx0XHRcdGNvbW1hbmRTdHJpbmcgKz0gYCAtLXJlbW90ZS1kZWJ1Z2dpbmctcG9ydD0ke3RoaXMuc2V0dGluZ3Mub2JzRGVidWdQb3J0X1RleHR9YDtcblx0XHRcdFx0XHRjb21tYW5kU3RyaW5nICs9IGAgLS1yZW1vdGUtYWxsb3ctb3JpZ2lucz1odHRwOi8vbG9jYWxob3N0OiR7dGhpcy5zZXR0aW5ncy5vYnNEZWJ1Z1BvcnRfVGV4dH1gO1xuXHRcdFx0XHRcdGNvbW1hbmRTdHJpbmcgKz0gYCAtLXdlYnNvY2tldF9wb3J0IFwiJHt0aGlzLnNldHRpbmdzLndlYnNvY2tldFBvcnRfVGV4dH1cImA7XG5cdFx0XHRcdFx0Y29tbWFuZFN0cmluZyArPSBgIC0td2Vic29ja2V0X3Bhc3N3b3JkIFwiJHt0aGlzLnNldHRpbmdzLndlYnNvY2tldFBXX1RleHR9XCJgO1xuXHRcdFx0XHRcdGNvbW1hbmRTdHJpbmcgKz0gYCAtLW11bHRpYDtcblx0XHRcblx0XHRcdFx0XHRleGVjKGNvbW1hbmRTdHJpbmcsIChlcnJvciwgc3Rkb3V0LCBzdGRlcnIpID0+IHtcblx0XHRcdFx0XHQgIGlmIChlcnJvcikge1xuXHRcdFx0XHRcdFx0ICBjb25zb2xlLmVycm9yKGBleGVjIGVycm9yOiAke2Vycm9yfWApO1xuXHRcdFx0XHRcdFx0ICByZXR1cm47XG5cdFx0XHRcdFx0ICB9XG5cdFx0XHRcdFx0ICBjb25zb2xlLmxvZyhgc3Rkb3V0OiAke3N0ZG91dH1gKTtcblx0XHRcdFx0XHQgIGNvbnNvbGUuZXJyb3IoYHN0ZGVycjogJHtzdGRlcnJ9YCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdCAgfVxuXHRcdFx0XHRjb25zb2xlLmxvZyhjb21tYW5kU3RyaW5nKVxuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHQpXG5cbi8vICNlbmRyZWdpb25cblxuXG5cbi8vIFxuLy9cbi8vXHRUT0RPOiBhIGZlYXR1cmUgdG8gYXV0b21hdGUgbW9kaWZ5aW5nIHRoZSBcIlNsaWRlcyBFeHRlbmRlZFwiIHRlbXBsYXRlIHdpdGggV2hpbXN5IHNjcmlwdHNcbi8vICNyZWdpb24gTW9kaWZ5ICdTbGlkZXMgRXh0ZW5kZWQnIHdpdGggVVVoaW1zeSBTY3JpcHRcbi8vIFRoaXMgYWxsb3dzIHRoZSBTbGlkZXMgRXh0ZW5kZWQgUGx1Z2luIHRvIGNvbm5lY3QgdG8gT0JTXHUwMEEwIFxuLy9cbi8vXHRcblxuLy9DT01NQU5EOiBmaW5kICdTbGlkZXMgRXh0ZW5kZWQnIFRlbXBsYXRlIGZpbGVcblxuLy9JZiBmaWxlIGRvZXMgbm90IGNvbnRhaW4gPHNjcmlwdCBzcmM9XCJPQlMgQ29ubmVjdFwiLCB0aGVuIHJlcGxhY2UgdGhlIDwvYm9keT4gd2l0aCA8c2NyaXB0Pi4uLjwvYm9keT4gXG5cbi8vICNlbmRyZWdpb25cblxuLy8gXG4vL1xuLy9cdFRPRE86IGEgZmVhdHVyZSB0byBhdXRvbWF0ZSBzZXR0aW5nIGZpbGUgcGF0aHMgdGhhdCBPQlMgcmVmZXJlbmNlcy4gIFVzZSB0aGUgT2JzaWRpYW4gdmF1bHQgbG9jYXRpb24gYXMgdGhlIGJhc2UgZmlsZSBwYXRoIFxuLy8gI3JlZ2lvbiBNb2RpZnkgT0JTIENvbGxlY3Rpb24gZmlsZSBwYXRocyBcbi8vIFxuLy9cbi8vXHRcblxuLy9DT01NQU5EOiBmaW5kIE9CUyBDb2xsZWN0aW9uIGZpbGUgYW5kIGNoYW5nZSB0aGUgZmlsZSBwYXRocyBcblxuLy8gI2VuZHJlZ2lvblxuXG4vL0VuZCBvZiBvbmxvYWQoKVxufVxuXG5cdG9udW5sb2FkKCkge1xuXHRcdG5ldyBOb3RpY2UoXCJEaXNhYmxlZCBVVWhpbXN5IHBsdWdpblwiKVxuXHR9XG59IiwgImltcG9ydCB1dWhpbXN5UGx1Z2luIGZyb20gXCJtYWluXCI7XG5pbXBvcnQge0FwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgbm9ybWFsaXplUGF0aCB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5leHBvcnQgY2xhc3MgdXVoaW1zeVNldHRpbmdzVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG4gICAgcGx1Z2luOiB1dWhpbXN5UGx1Z2luO1xuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogdXVoaW1zeVBsdWdpbil7XG4gICAgICAgIHN1cGVyKGFwcCxwbHVnaW4pO1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICB9XG4gICAgXG4gICAgZGlzcGxheSgpe1xuICAgICAgICBsZXQgeyBjb250YWluZXJFbCB9ID0gdGhpcztcbiAgICAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgLnNldE5hbWUoXCJPQlMgV2ViU29ja2V0IFNlcnZlclwiKVxuICAgICAgICAuc2V0SGVhZGluZygpXG4gICAgICAgIC5zZXREZXNjKFwiU2V0IHRoZSBPQlMgV2Vic29ja2V0IFNlcnZlciBTZXR0aW5nc1wiKVxuICAgICAgICBcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgIC5zZXROYW1lKFwiSVBcIilcbiAgICAgICAgLnNldERlc2MoXCJFbnRlciB0aGUgSVAgYWRkcmVzcyBvciAnbG9jYWxob3N0J1wiKVxuICAgICAgICAuYWRkVGV4dCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaXRlbS5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy53ZWJzb2NrZXRJUF9UZXh0KS5vbkNoYW5nZShcbiAgICAgICAgICAgICAgICAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mud2Vic29ja2V0SVBfVGV4dCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKVxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoX3dlYnNvY2tldERldGFpbHNKUyh0aGlzKVxuICAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZShcIlBPUlRcIilcbiAgICAgICAgLmFkZFRleHQoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGl0ZW0uc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mud2Vic29ja2V0UG9ydF9UZXh0KS5vbkNoYW5nZShcbiAgICAgICAgICAgICAgICAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mud2Vic29ja2V0UG9ydF9UZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hfd2Vic29ja2V0RGV0YWlsc0pTKHRoaXMpXG4gICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgIC5zZXROYW1lKFwiUGFzc3dvcmRcIilcbiAgICAgICAgLmFkZFRleHQoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGl0ZW0uc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mud2Vic29ja2V0UFdfVGV4dCkub25DaGFuZ2UoXG4gICAgICAgICAgICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLndlYnNvY2tldFBXX1RleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKClcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaF93ZWJzb2NrZXREZXRhaWxzSlModGhpcylcbiAgICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgLnNldE5hbWUoXCJPQlMgTGF1bmNoIFBhcmFtZXRlcnNcIilcbiAgICAgICAgLnNldEhlYWRpbmcoKVxuICAgICAgICAuc2V0RGVzYyhcIk9wZW4gT0JTIHdpdGggdGhlc2Ugb3B0aW9ucy5cIilcbiAgICAgICAgXG4gICAgICAgIGlmKHByb2Nlc3MucGxhdGZvcm0gPT09IFwiZGFyd2luXCIpe1xuICAgICAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZShcIk5hbWVcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiRW50ZXIgJ09CUycgb3IgYSBjdXN0b20gbmFtZVwiKVxuICAgICAgICAgICAgLmFkZFRleHQoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm9ic0FwcE5hbWVfVGV4dCkub25DaGFuZ2UoXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub2JzQXBwTmFtZV9UZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKXtcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJOYW1lXCIpXG4gICAgICAgICAgICAuc2V0RGVzYyhcIkVudGVyICdvYnM2NC5leGUnIG9yIGEgY3VzdG9tIG5hbWVcIilcbiAgICAgICAgICAgIC5hZGRUZXh0KChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5vYnNBcHBOYW1lX1RleHQpLm9uQ2hhbmdlKFxuICAgICAgICAgICAgICAgICAgICAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm9ic0FwcE5hbWVfVGV4dCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKClcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZShcIlBhdGggdG8gT0JTIGFwcFwiKVxuICAgICAgICAgICAgLmFkZFRleHQoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm9ic0FwcFBhdGhfVGV4dCkub25DaGFuZ2UoXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub2JzQXBwUGF0aF9UZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZShcIkNvbGxlY3Rpb25cIilcbiAgICAgICAgLmFkZFRleHQoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGl0ZW0uc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mub2JzQ29sbGVjdGlvbl9UZXh0KS5vbkNoYW5nZShcbiAgICAgICAgICAgICAgICAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub2JzQ29sbGVjdGlvbl9UZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgLnNldE5hbWUoXCJPQlMgQnJvd3NlciBTb3VyY2UgRGVidWcgUG9ydFwiKVxuICAgICAgICAuc2V0RGVzYyhcIkVudGVyIGEgUG9ydCBmb3IgdGhlIFJlbW90ZSBEZWJ1Z2dlciwgb3IgbGVhdmUgYmxhbmsgdG8gc2tpcCB0aGlzIG9wdGlvblwiKVxuICAgICAgICAuYWRkVGV4dCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaXRlbS5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5vYnNEZWJ1Z1BvcnRfVGV4dCkub25DaGFuZ2UoXG4gICAgICAgICAgICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm9ic0RlYnVnUG9ydF9UZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgLnNldE5hbWUoXCJPU0MgU2VydmVyXCIpXG4gICAgICAgIC5zZXRIZWFkaW5nKClcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgLnNldE5hbWUoXCJJUFwiKVxuICAgICAgICAuc2V0RGVzYyhcIkVudGVyIHRoZSBJUCBhZGRyZXNzIG9yICdsb2NhbGhvc3QnXCIpXG4gICAgICAgIC5hZGRUZXh0KChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpdGVtLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm9zY0lQX1RleHQpLm9uQ2hhbmdlKFxuICAgICAgICAgICAgICAgICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vc2NJUF9UZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpXG4gICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgIC5zZXROYW1lKFwiSW5jb21pbmcgTWVzc2FnZSBQT1JUXCIpXG4gICAgICAgIC5hZGRUZXh0KChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpdGVtLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm9zY0luUG9ydF9UZXh0KS5vbkNoYW5nZShcbiAgICAgICAgICAgICAgICAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3NjSW5Qb3J0X1RleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKClcbiAgICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgLnNldE5hbWUoXCJPdXQgZ29pbmcgTWVzc2FnZSBQT1JUXCIpXG4gICAgICAgIC5hZGRUZXh0KChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpdGVtLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm9zY091dFBvcnRfVGV4dCkub25DaGFuZ2UoXG4gICAgICAgICAgICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm9zY091dFBvcnRfVGV4dCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgLnNldE5hbWUoXCJBZGQgVVVoaW1zeSBzY3JpcHRzIHRvIFNsaWRlcyBFeHRlbmRlZCBUZW1wbGF0ZVwiKVxuICAgICAgICAuc2V0SGVhZGluZygpXG4gICAgICAgIC5zZXREZXNjKFwiVVVoaW1zeSBzY3JpcHRzIHdpbGwgYmUgaW5jbHVkZWQgd2hlbiBleHBvcnRpbmcgU2xpZGVzIEV4dGVuZGVkIHNsaWRlc1wiKVxuICAgICAgICAuYWRkQnV0dG9uKChidXR0b24pID0+IHtcbiAgICAgICAgICAgIGJ1dHRvblxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KFwiQWRkIFVVaGltc3kgc2NyaXB0cyB0byBTbGlkZXMgRXh0ZW5kZWQgVGVtcGxhdGVcIilcbiAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcChcIlVVaGltc3kgc2NyaXB0cyBhcmUgaW5jbHVkZWQgd2hlbiBleHBvcnRpbmcgZnJvbSBTbGlkZXMgRXh0ZW5kZWRcIilcbiAgICAgICAgICAgICAgICAuc2V0Q3RhKClcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGAub2JzaWRpYW4vcGx1Z2lucy9zbGlkZXMtZXh0ZW5kZWQvdGVtcGxhdGUvcmV2ZWFsLmh0bWxgO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKG5vcm1hbGl6ZVBhdGgoYCR7ZmlsZU5hbWV9YCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5yZWFkKG5vcm1hbGl6ZVBhdGgoYCR7ZmlsZU5hbWV9YCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihmaWxlLmluY2x1ZGVzKGA8c2NyaXB0IHNyYz1cIi9fYnJvd3Nlcl9Tb3VyY2VzL2pzL3JldmVhbFNsaWRlQ29udHJvbHMuanNcIj48L3NjcmlwdD5gKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3RlbXBsYXRlIGFscmVhZHkgaW5jbHVkZXMgdXVoaW1zeSBzY3JpcHRzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2FkZGluZyBzY3JpcHRzJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5wcm9jZXNzKG5vcm1hbGl6ZVBhdGgoYCR7ZmlsZU5hbWV9YCksIChkYXRhKSA9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucmVwbGFjZSgnPC9ib2R5PicsYCAgICA8c2NyaXB0IHNyYz1cIi9fYnJvd3Nlcl9Tb3VyY2VzL29ic193ZWJTb2NrZXRfZGV0YWlscy93ZWJzb2NrZXREZXRhaWxzLmpzXCI+PC9zY3JpcHQ+XG4gICAgPHNjcmlwdCBzcmM9XCIvX2Jyb3dzZXJfU291cmNlcy9vYnNfd2ViU29ja2V0X2RldGFpbHMvb2JzLXdzLmpzXCI+PC9zY3JpcHQ+XG4gICAgPHNjcmlwdCBzcmM9XCIvX2Jyb3dzZXJfU291cmNlcy9vYnNfd2ViU29ja2V0X2RldGFpbHMvb2JzQ29ubmVjdC5qc1wiPjwvc2NyaXB0PlxuICAgIDxzY3JpcHQgc3JjPVwiL19icm93c2VyX1NvdXJjZXMvb2JzX3dlYlNvY2tldF9kZXRhaWxzL3N0YXJ0Q29ubmVjdGlvbi5qc1wiPjwvc2NyaXB0PlxuICAgIDxzY3JpcHQgc3JjPVwiL19icm93c2VyX1NvdXJjZXMvanMvcmV2ZWFsU2xpZGVDb250cm9scy5qc1wiPjwvc2NyaXB0PlxuPC9ib2R5PmApXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3NjT3V0UG9ydF9UZXh0KS5vbkNoYW5nZShcbiAgICAgICAgICAgICAgICAvLyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3NjT3V0UG9ydF9UZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpXG4gICAgICAgICAgICAgICAgLy8gIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hfd2Vic29ja2V0RGV0YWlsc0pTKG9ic2lkaWFuKXtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gYF9icm93c2VyX1NvdXJjZXMvb2JzX3dlYlNvY2tldF9kZXRhaWxzL3dlYnNvY2tldERldGFpbHMuanNgO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBhd2FpdCBvYnNpZGlhbi5hcHAudmF1bHQuYWRhcHRlci5leGlzdHMobm9ybWFsaXplUGF0aChgJHtmaWxlTmFtZX1gKSk7XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgb2JzaWRpYW4uYXBwLnZhdWx0LmNyZWF0ZShgJHtmaWxlTmFtZX1gLCBcbiAgICAgICAgICAgICAgICAgICAgYHZhciB3c3NEZXRhaWxzID0ge1xuICAgICAgICAgICAgICAgICAgICBcIklQXCI6XCIke29ic2lkaWFuLnBsdWdpbi5zZXR0aW5ncy53ZWJzb2NrZXRJUF9UZXh0fVwiLFxuICAgICAgICAgICAgICAgICAgICBcIlBPUlRcIjpcIiR7b2JzaWRpYW4ucGx1Z2luLnNldHRpbmdzLndlYnNvY2tldFBvcnRfVGV4dH1cIixcbiAgICAgICAgICAgICAgICAgICAgXCJQV1wiOlwiJHtvYnNpZGlhbi5wbHVnaW4uc2V0dGluZ3Mud2Vic29ja2V0UFdfVGV4dH1cIlxuICAgICAgICAgICAgICAgIH07YCwpO1xuICAgICAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgICAgIGF3YWl0IG9ic2lkaWFuLmFwcC52YXVsdC5kZWxldGUob2JzaWRpYW4uYXBwLnZhdWx0LmdldEZpbGVCeVBhdGgoZmlsZU5hbWUpKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBvYnNpZGlhbi5hcHAudmF1bHQuY3JlYXRlKGAke2ZpbGVOYW1lfWAsIFxuICAgICAgICAgICAgICAgICAgICBgdmFyIHdzc0RldGFpbHMgPSB7XG4gICAgXCJJUFwiOlwiJHtvYnNpZGlhbi5wbHVnaW4uc2V0dGluZ3Mud2Vic29ja2V0SVBfVGV4dH1cIixcbiAgICBcIlBPUlRcIjpcIiR7b2JzaWRpYW4ucGx1Z2luLnNldHRpbmdzLndlYnNvY2tldFBvcnRfVGV4dH1cIixcbiAgICBcIlBXXCI6XCIke29ic2lkaWFuLnBsdWdpbi5zZXR0aW5ncy53ZWJzb2NrZXRQV19UZXh0fVwiXG59O2AsKTsgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5cbi8vIHZhciB3ZWJzb2NrZXRJUCA9IHRoaXMuc2V0dGluZ3Mud2Vic29ja2V0SVBfVGV4dDtcbi8vIHZhciB3ZWJzb2NrZXRQb3J0ID0gdGhpcy5zZXR0aW5ncy53ZWJzb2NrZXRQb3J0X1RleHQ7XG4vLyB2YXIgd2Vic29ja2V0UGFzc3dvcmQgPSB0aGlzLnNldHRpbmdzLndlYnNvY2tldFBXX1RleHQ7IiwgImltcG9ydCB7IEVkaXRvciwgRnV6enlTdWdnZXN0TW9kYWwsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmV4cG9ydCBjbGFzcyBVVWhpbXN5RW50cmFuY2VTdWdnZXN0IGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8VEZpbGU+IHtcbiAgICBnZXRJdGVtcygpOiBURmlsZVtdIHtcbiAgICAgICAgY29uc3QgZmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XG5cbiAgICAgICAgY29uc3QgY2hvaWNlcyA9IGZpbGVzLmZpbHRlcigoZmlsZSkgPT4ge3JldHVybiBmaWxlLmJhc2VuYW1lLnN0YXJ0c1dpdGgoXCJFbnRyYW5jZVwiKX0pXG5cbiAgICAgICAgcmV0dXJuIGNob2ljZXM7XG4gICAgfVxuICAgIGdldEl0ZW1UZXh0KGl0ZW06IFRGaWxlKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uYmFzZW5hbWVcbiAgICB9XG4gICAgYXN5bmMgb25DaG9vc2VJdGVtKGl0ZW06IFRGaWxlLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KTogdm9pZCB7ICBcbiAgICAgICAgLy9uZXcgTm90aWNlKFwiU2VsZWN0ZWQgXCIgKyBpdGVtLmJhc2VuYW1lKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGl0ZW0pKVxuICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2UuYWN0aXZlRWRpdG9yPy5lZGl0b3I/LnJlcGxhY2VTZWxlY3Rpb24oYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChpdGVtKSlcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVVWhpbXN5RXhpdFN1Z2dlc3QgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxURmlsZT4ge1xuICAgIGdldEl0ZW1zKCk6IFRGaWxlW10ge1xuICAgICAgICBjb25zdCBmaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTtcblxuICAgICAgICBjb25zdCBjaG9pY2VzID0gZmlsZXMuZmlsdGVyKChmaWxlKSA9PiB7cmV0dXJuIGZpbGUuYmFzZW5hbWUuc3RhcnRzV2l0aChcIkV4aXRcIil9KVxuXG4gICAgICAgIHJldHVybiBjaG9pY2VzO1xuICAgIH1cbiAgICBnZXRJdGVtVGV4dChpdGVtOiBURmlsZSk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBpdGVtLmJhc2VuYW1lXG4gICAgfVxuICAgIGFzeW5jIG9uQ2hvb3NlSXRlbShpdGVtOiBURmlsZSwgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCk6IHZvaWQgeyAgXG4gICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5hY3RpdmVFZGl0b3I/LmVkaXRvcj8ucmVwbGFjZVNlbGVjdGlvbihhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGl0ZW0pKVxuICAgIH1cbn0iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBLHVEQUFBQSxTQUFBO0FBQUE7QUFFQSxRQUFNLFdBQVc7QUFBQSxNQUNmLEdBQUc7QUFBQSxNQUNILEdBQUc7QUFBQSxNQUNILEdBQUc7QUFBQSxNQUNILEdBQUc7QUFBQSxJQUNMO0FBRUEsUUFBTSxXQUFOLE1BQWU7QUFBQSxNQUNiLFlBQVksTUFBTSxPQUFPO0FBQ3ZCLGFBQUssT0FBTztBQUNaLGFBQUssUUFBUTtBQUFBLE1BQ2Y7QUFBQSxJQUNGO0FBRUEsUUFBTUMsV0FBTixNQUFjO0FBQUEsTUFDWixZQUFZLFlBQVksTUFBTTtBQUM1QixhQUFLLFVBQVU7QUFDZixhQUFLLFVBQVU7QUFDZixhQUFLLE9BQU87QUFBQSxNQUNkO0FBQUEsTUFFQSxPQUFPLEtBQUs7QUFDVixZQUFJO0FBQ0osZ0JBQVEsT0FBTyxLQUFLO0FBQUEsVUFDcEIsS0FBSztBQUNILGdCQUFJLGVBQWUsT0FBTztBQUN4QixrQkFBSSxRQUFRLE9BQUssS0FBSyxPQUFPLENBQUMsQ0FBQztBQUFBLFlBQ2pDLFdBQVcsSUFBSSxNQUFNO0FBQ25CLGtCQUFJLFNBQVMsSUFBSSxJQUFJO0FBQUcsb0JBQUksT0FBTyxTQUFTLElBQUksSUFBSTtBQUNwRCxtQkFBSyxLQUFLLEtBQUssR0FBRztBQUFBLFlBQ3BCLE9BQU87QUFD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QUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQ0gsaUJBQU8sSUFBSTtBQUFBLFFBQ2IsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUNILGlCQUFPLElBQUk7QUFBQSxRQUNiLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFDSCxpQkFBTyxJQUFJO0FBQUEsUUFDYixLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQ0gsaUJBQU8sSUFBSTtBQUFBLFFBQ2IsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUNILGlCQUFPLElBQUk7QUFBQSxRQUNiLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFDSCxpQkFBTyxJQUFJO0FBQUEsUUFDYixLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQ0gsaUJBQU87QUFBQSxRQUNUO0FBQ0UsaUJBQU87QUFBQSxNQUNYO0FBQUEsSUFDRjtBQVVBLGFBQVMsU0FBUyxJQUFJO0FBQ3BCLFVBQUksUUFBUSxLQUFLLElBQUksRUFBRTtBQUN2QixVQUFJLFNBQVMsR0FBRztBQUNkLGVBQU8sS0FBSyxNQUFNLEtBQUssQ0FBQyxJQUFJO0FBQUEsTUFDOUI7QUFDQSxVQUFJLFNBQVMsR0FBRztBQUNkLGVBQU8sS0FBSyxNQUFNLEtBQUssQ0FBQyxJQUFJO0FBQUEsTUFDOUI7QUFDQSxVQUFJLFNBQVMsR0FBRztBQUNkLGVBQU8sS0FBSyxNQUFNLEtBQUssQ0FBQyxJQUFJO0FBQUEsTUFDOUI7QUFDQSxVQUFJLFNBQVMsR0FBRztBQUNkLGVBQU8sS0FBSyxNQUFNLEtBQUssQ0FBQyxJQUFJO0FBQUEsTUFDOUI7QUFD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LGNBQUEsS0FBQSxRQUFBLEdBQUE7VUFDQTtVQUNBO1VBQ0EsR0FBQTtRQUNBLENBQUE7QUFDQSxjQUFBLEVBQUEsUUFBQSxJQUFBLE1BQUE7QUFDQSxlQUFBO01BQ0E7Ozs7TUFJQSxVQUFBO0FBQ0EsWUFBQSxDQUFBLEtBQUEsUUFBQTtBQUNBO1FBQ0E7QUFDQSxhQUFBLE9BQUEsU0FBQTtBQUNBLGFBQUEsT0FBQSxZQUFBO0FBQ0EsYUFBQSxPQUFBLFVBQUE7QUFDQSxhQUFBLE9BQUEsVUFBQTtBQUNBLGFBQUEsU0FBQTtBQUNBLGFBQUEsY0FBQTtBQUNBLGFBQUEsa0JBQUEsbUJBQUE7TUFDQTs7Ozs7Ozs7TUFRQSxNQUFBLGlCQUFBLEtBQUE7QUFDQSxZQUFBO0FBQ0EsY0FBQSwwQkFBQSxLQUFBLHFCQUFBLGtCQUFBO0FBQ0EsY0FBQSxlQUFBLEtBQUEscUJBQUEsTUFBQSxHQUFBO0FBQ0EsYUFBQSxTQUFBLEtBQUEsR0FBQSxlQUFBLFNBQUEsS0FBQSxLQUFBLFFBQUE7QUFDQSxhQUFBLE9BQUEsU0FBQSxLQUFBLE9BQUEsS0FBQSxJQUFBO0FBQ0EsYUFBQSxPQUFBLFlBQUEsS0FBQSxVQUFBLEtBQUEsSUFBQTtBQUNBLGFBQUEsT0FBQSxVQUFBLEtBQUEsUUFBQSxLQUFBLElBQUE7QUFDQSxhQUFBLE9BQUEsVUFBQSxLQUFBLFFBQUEsS0FBQSxJQUFBO0FBQ0EsY0FBQTtBQUNBLGNBQUEsWUFBQSxLQUFBLEtBQUEsV0FBQSxPQUFBLFNBQUEsR0FBQTtBQUNBLFlBQUEsQ0FBQSxVQUFBO0FBQ0EsZ0JBQUEsSUFBQSxrQkFBQSxJQUFBLDRCQUFBO1FBQ0E7QUFDQSxZQUFBLGFBQUEsS0FBQSxVQUFBO0FBQ0EsZ0JBQUEsSUFBQSxrQkFBQSxJQUFBLG9DQUFBO1FBQ0E7QUFDQSxlQUFBO01BQ0E7Ozs7Ozs7Ozs7TUFVQSxNQUFBLFNBQUE7UUFDQTtRQUNBO1FBQ0EsR0FBQTtNQUNBLEdBQUEsVUFBQSx1QkFBQSxDQUFBLEdBQUE7QUFDQSxjQUFBLE9BQUE7VUFDQTtVQUNBLEdBQUE7UUFDQTtB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LEtBQUssU0FBUztBQUMzRCw2QkFBaUIsNENBQTRDLEtBQUssU0FBUztBQUMzRSw2QkFBaUIsc0JBQXNCLEtBQUssU0FBUztBQUNyRCw2QkFBaUIsMEJBQTBCLEtBQUssU0FBUztBQUN6RCw2QkFBaUI7QUFDakIsaUJBQUssYUFBYTtBQUFBLFVBQ25CO0FBQ0EsY0FBSSxRQUFRLGFBQWEsU0FBUztBQUNqQyxrQkFBTSxPQUFPLFFBQVEsTUFBTTtBQUMzQixrQkFBTSxVQUFVLEdBQUcsS0FBSyxTQUFTLGtCQUFrQixLQUFLLFNBQVM7QUFDakUsa0JBQU0sU0FBUyxLQUFLLFFBQVEsT0FBTztBQUNuQyxvQkFBUSxNQUFNLE1BQU07QUFFcEIsNEJBQWdCLEdBQUcsS0FBSyxTQUFTO0FBQ2pDLDZCQUFpQix5QkFBeUIsS0FBSyxTQUFTO0FBQ3hELDZCQUFpQiw0QkFBNEIsS0FBSyxTQUFTO0FBQzNELDZCQUFpQiw0Q0FBNEMsS0FBSyxTQUFTO0FBQzNFLDZCQUFpQixzQkFBc0IsS0FBSyxTQUFTO0FBQ3JELDZCQUFpQiwwQkFBMEIsS0FBSyxTQUFTO0FBQ3pELDZCQUFpQjtBQUVqQixpQkFBSyxlQUFlLENBQUMsT0FBTyxRQUFRLFdBQVc7QUFDN0Msa0JBQUksT0FBTztBQUNWLHdCQUFRLE1BQU0sZUFBZSxPQUFPO0FBQ3BDO0FBQUEsY0FDRDtBQUNBLHNCQUFRLElBQUksV0FBVyxRQUFRO0FBQy9CLHNCQUFRLE1BQU0sV0FBVyxRQUFRO0FBQUEsWUFDbkMsQ0FBQztBQUFBLFVBQ0E7QUFDRixrQkFBUSxJQUFJLGFBQWE7QUFBQSxRQUV6QjtBQUFBLE1BQ0Q7QUFBQSxJQUNEO0FBQUEsRUFpQ0Y7QUFBQSxFQUVDLFdBQVc7QUFDVixRQUFJLHdCQUFPLHlCQUF5QjtBQUFBLEVBQ3JDO0FBQ0Q7IiwKICAibmFtZXMiOiBbIm1vZHVsZSIsICJNZXNzYWdlIiwgIm1vZHVsZSIsICJNZXNzYWdlIiwgIm1vZHVsZSIsICJiIiwgImIiLCAiYnVmZmVyIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAiU2VydmVyIiwgIm1vZHVsZSIsICJNZXNzYWdlIiwgIkNsaWVudCIsICJyZXF1aXJlX2xpYiIsICJNZXNzYWdlIiwgIlNlcnZlciIsICJDbGllbnQiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJzZWxmIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJ1c2VDb2xvcnMiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAiZGF0YSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJrZXkiLCAibW9kdWxlIiwgImVyciIsICJtb2R1bGUiLCAicHJvdG9jb2wiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJyZXF1aXJlX25vZGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJNYXRoIiwgInVuZGVmaW5lZCIsICJtb2R1bGUiLCAiTWF0aCIsICJuIiwgIkgiLCAiYiIsICJtb2R1bGUiLCAiT0JTV2ViU29ja2V0IiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAid2Vic29ja2V0SVAiLCAid2Vic29ja2V0UG9ydCIsICJ3ZWJzb2NrZXRQYXNzd29yZCIsICJvc2NJUCIsICJvc2NJblBPUlQiLCAib3NjT3V0UE9SVCIsICJ2YXVsdFBhdGgiLCAidXRpbCIsICJleGVjIl0KfQo=
