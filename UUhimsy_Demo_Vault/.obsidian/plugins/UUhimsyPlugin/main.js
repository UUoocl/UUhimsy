/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/node-osc/dist/lib/Message.js
var require_Message = __commonJS({
  "node_modules/node-osc/dist/lib/Message.js"(exports, module2) {
    "use strict";
    var typeTags = {
      s: "string",
      f: "float",
      i: "integer",
      b: "blob"
    };
    var Argument = class {
      constructor(type, value) {
        this.type = type;
        this.value = value;
      }
    };
    var Message2 = class {
      constructor(address, ...args) {
        this.oscType = "message";
        this.address = address;
        this.args = args;
      }
      append(arg) {
        let argOut;
        switch (typeof arg) {
          case "object":
            if (arg instanceof Array) {
              arg.forEach((a) => this.append(a));
            } else if (arg.type) {
              if (typeTags[arg.type])
                arg.type = typeTags[arg.type];
              this.args.push(arg);
            } else {
              throw new Error(`don't know how to encode object ${arg}`);
            }
            break;
          case "number":
            if (Math.floor(arg) === arg) {
              argOut = new Argument("integer", arg);
            } else {
              argOut = new Argument("float", arg);
            }
            break;
          case "string":
            argOut = new Argument("string", arg);
            break;
          case "boolean":
            argOut = new Argument("boolean", arg);
            break;
          default:
            throw new Error(`don't know how to encode ${arg}`);
        }
        if (argOut)
          this.args.push(argOut);
      }
    };
    module2.exports = Message2;
  }
});

// node_modules/node-osc/dist/lib/Bundle.js
var require_Bundle = __commonJS({
  "node_modules/node-osc/dist/lib/Bundle.js"(exports, module2) {
    "use strict";
    var Message2 = require_Message();
    function sanitize(element) {
      if (element instanceof Array)
        element = new Message2(element[0], ...element.slice(1));
      return element;
    }
    var Bundle = class {
      constructor(timetag, ...elements) {
        if (!(typeof timetag === "number")) {
          elements.unshift(timetag);
          timetag = 0;
        }
        this.timetag = timetag;
        this.elements = elements.map(sanitize);
      }
      append(element) {
        this.elements.push(sanitize(element));
      }
    };
    module2.exports = Bundle;
  }
});

// node_modules/binpack/index.js
var require_binpack = __commonJS({
  "node_modules/binpack/index.js"(exports, module2) {
    var sizeOfType = function(t) {
      if (t[0] === "U") {
        t = t.slice(1);
      }
      return {
        "Float32": 4,
        "Float64": 8,
        "Int8": 1,
        "Int16": 2,
        "Int32": 4,
        "Int64": 8
      }[t];
    };
    var endianConv = function(e, t) {
      if (t[t.length - 1] === "8")
        return "";
      if (e === "big") {
        return "BE";
      }
      return "LE";
    };
    var addBindings = function(binpackTypename, nodeTypename) {
      if (!(typeof nodeTypename !== "undefined" && nodeTypename !== null)) {
        nodeTypename = binpackTypename;
      }
      module2.exports["pack" + binpackTypename] = function(num, endian) {
        b = new Buffer(sizeOfType(binpackTypename));
        b["write" + nodeTypename + endianConv(endian, binpackTypename)](num, 0, true);
        return b;
      };
      module2.exports["unpack" + binpackTypename] = function(buff, endian) {
        return buff["read" + nodeTypename + endianConv(endian, binpackTypename)](0);
      };
    };
    var addIntBindings = function(n) {
      addBindings("Int" + n);
      addBindings("UInt" + n);
    };
    addIntBindings(8);
    addIntBindings(16);
    addIntBindings(32);
    twoToThe32 = Math.pow(2, 32);
    var read64 = function(unsigned) {
      return function(buff, endian) {
        var e = endianConv(endian, "");
        var u = unsigned ? "U" : "";
        var low, high;
        if (e === "LE") {
          low = buff.readUInt32LE(0);
          high = buff["read" + u + "Int32LE"](4);
        } else {
          low = buff.readUInt32BE(4);
          high = buff["read" + u + "Int32BE"](0);
        }
        return high * twoToThe32 + low;
      };
    };
    var write64 = function(unsigned) {
      return function(num, endian) {
        var e = endianConv(endian, "");
        var u = unsigned ? "U" : "";
        var b2 = new Buffer(8);
        var high = Math.floor(num / twoToThe32);
        var low = Math.floor(num - high * twoToThe32);
        if (e == "LE") {
          b2.writeUInt32LE(low, 0, true);
          b2["write" + u + "Int32LE"](high, 4, true);
        } else {
          b2.writeUInt32BE(low, 4, true);
          b2["write" + u + "Int32BE"](high, 0, true);
        }
        return b2;
      };
    };
    module2.exports.unpackInt64 = read64(false);
    module2.exports.unpackUInt64 = read64(true);
    module2.exports.packInt64 = write64(false);
    module2.exports.packUInt64 = write64(true);
    addBindings("Float32", "Float");
    addBindings("Float64", "Double");
  }
});

// node_modules/osc-min/lib/osc-utilities.js
var require_osc_utilities = __commonJS({
  "node_modules/osc-min/lib/osc-utilities.js"(exports) {
    (function() {
      var IsArray, StrictError, TWO_POW_32, UNIX_EPOCH, binpack, getArrayArg, isOscBundleBuffer, makeTimetag, mapBundleList, oscTypeCodes, padding, toOscTypeAndArgs, hasProp = {}.hasOwnProperty;
      binpack = require_binpack();
      exports.concat = function(buffers) {
        var buffer, copyTo, destBuffer, j, k, l, len, len1, len2, sumLength;
        if (!IsArray(buffers)) {
          throw new Error("concat must take an array of buffers");
        }
        for (j = 0, len = buffers.length; j < len; j++) {
          buffer = buffers[j];
          if (!Buffer.isBuffer(buffer)) {
            throw new Error("concat must take an array of buffers");
          }
        }
        sumLength = 0;
        for (k = 0, len1 = buffers.length; k < len1; k++) {
          buffer = buffers[k];
          sumLength += buffer.length;
        }
        destBuffer = new Buffer(sumLength);
        copyTo = 0;
        for (l = 0, len2 = buffers.length; l < len2; l++) {
          buffer = buffers[l];
          buffer.copy(destBuffer, copyTo);
          copyTo += buffer.length;
        }
        return destBuffer;
      };
      exports.toOscString = function(str, strict) {
        var i, j, nullIndex, ref;
        if (!(typeof str === "string")) {
          throw new Error("can't pack a non-string into an osc-string");
        }
        nullIndex = str.indexOf("\0");
        if (nullIndex !== -1 && strict) {
          throw StrictError("Can't pack an osc-string that contains NULL characters");
        }
        if (nullIndex !== -1) {
          str = str.slice(0, nullIndex);
        }
        for (i = j = 0, ref = padding(str); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          str += "\0";
        }
        return new Buffer(str);
      };
      exports.splitOscString = function(buffer, strict) {
        var i, j, nullIndex, rawStr, ref, ref1, rest, splitPoint, str;
        if (!Buffer.isBuffer(buffer)) {
          throw StrictError("Can't split something that isn't a buffer");
        }
        rawStr = buffer.toString("utf8");
        nullIndex = rawStr.indexOf("\0");
        if (nullIndex === -1) {
          if (strict) {
            throw new Error("All osc-strings must contain a null character");
          }
          return {
            string: rawStr,
            rest: new Buffer(0)
          };
        }
        str = rawStr.slice(0, nullIndex);
        splitPoint = Buffer.byteLength(str) + padding(str);
        if (strict && splitPoint > buffer.length) {
          throw StrictError("Not enough padding for osc-string");
        }
        if (strict) {
          for (i = j = ref = Buffer.byteLength(str), ref1 = splitPoint; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
            if (buffer[i] !== 0) {
              throw StrictError("Not enough or incorrect padding for osc-string");
            }
          }
        }
        rest = buffer.slice(splitPoint, buffer.length);
        return {
          string: str,
          rest
        };
      };
      exports.splitInteger = function(buffer, type) {
        var bytes, num, rest, value;
        if (type == null) {
          type = "Int32";
        }
        bytes = binpack["pack" + type](0).length;
        if (buffer.length < bytes) {
          throw new Error("buffer is not big enough for integer type");
        }
        num = 0;
        value = binpack["unpack" + type](buffer.slice(0, bytes), "big");
        rest = buffer.slice(bytes, buffer.length);
        return {
          integer: value,
          rest
        };
      };
      exports.splitTimetag = function(buffer) {
        var a, b2, bytes, c, d, fractional, rest, seconds, type;
        type = "UInt32";
        bytes = binpack["pack" + type](0).length;
        if (buffer.length < bytes * 2) {
          throw new Error("buffer is not big enough to contain a timetag");
        }
        a = 0;
        b2 = bytes;
        seconds = binpack["unpack" + type](buffer.slice(a, b2), "big");
        c = bytes;
        d = bytes + bytes;
        fractional = binpack["unpack" + type](buffer.slice(c, d), "big");
        rest = buffer.slice(d, buffer.length);
        return {
          timetag: [seconds, fractional],
          rest
        };
      };
      UNIX_EPOCH = 2208988800;
      TWO_POW_32 = 4294967296;
      exports.dateToTimetag = function(date) {
        return exports.timestampToTimetag(date.getTime() / 1e3);
      };
      exports.timestampToTimetag = function(secs) {
        var fracSeconds, wholeSecs;
        wholeSecs = Math.floor(secs);
        fracSeconds = secs - wholeSecs;
        return makeTimetag(wholeSecs, fracSeconds);
      };
      exports.timetagToTimestamp = function(timetag) {
        var seconds;
        seconds = timetag[0] + exports.ntpToFractionalSeconds(timetag[1]);
        return seconds - UNIX_EPOCH;
      };
      makeTimetag = function(unixseconds, fracSeconds) {
        var ntpFracs, ntpSecs;
        ntpSecs = unixseconds + UNIX_EPOCH;
        ntpFracs = Math.round(TWO_POW_32 * fracSeconds);
        return [ntpSecs, ntpFracs];
      };
      exports.timetagToDate = function(timetag) {
        var date, dd, fracs, fractional, seconds;
        seconds = timetag[0], fractional = timetag[1];
        seconds = seconds - UNIX_EPOCH;
        fracs = exports.ntpToFractionalSeconds(fractional);
        date = new Date();
        date.setTime(seconds * 1e3 + fracs * 1e3);
        dd = new Date();
        dd.setUTCFullYear(date.getUTCFullYear());
        dd.setUTCMonth(date.getUTCMonth());
        dd.setUTCDate(date.getUTCDate());
        dd.setUTCHours(date.getUTCHours());
        dd.setUTCMinutes(date.getUTCMinutes());
        dd.setUTCSeconds(date.getUTCSeconds());
        dd.setUTCMilliseconds(fracs * 1e3);
        return dd;
      };
      exports.deltaTimetag = function(seconds, now) {
        var n;
        n = (now != null ? now : new Date()) / 1e3;
        return exports.timestampToTimetag(n + seconds);
      };
      exports.ntpToFractionalSeconds = function(fracSeconds) {
        return parseFloat(fracSeconds) / TWO_POW_32;
      };
      exports.toTimetagBuffer = function(timetag) {
        var high, low, type;
        if (typeof timetag === "number") {
          timetag = exports.timestampToTimetag(timetag);
        } else if (typeof timetag === "object" && "getTime" in timetag) {
          timetag = exports.dateToTimetag(timetag);
        } else if (timetag.length !== 2) {
          throw new Error("Invalid timetag" + timetag);
        }
        type = "UInt32";
        high = binpack["pack" + type](timetag[0], "big");
        low = binpack["pack" + type](timetag[1], "big");
        return exports.concat([high, low]);
      };
      exports.toIntegerBuffer = function(number, type) {
        if (type == null) {
          type = "Int32";
        }
        if (typeof number !== "number") {
          throw new Error("cannot pack a non-number into an integer buffer");
        }
        return binpack["pack" + type](number, "big");
      };
      oscTypeCodes = {
        s: {
          representation: "string",
          split: function(buffer, strict) {
            var split;
            split = exports.splitOscString(buffer, strict);
            return {
              value: split.string,
              rest: split.rest
            };
          },
          toArg: function(value, strict) {
            if (typeof value !== "string") {
              throw new Error("expected string");
            }
            return exports.toOscString(value, strict);
          }
        },
        i: {
          representation: "integer",
          split: function(buffer, strict) {
            var split;
            split = exports.splitInteger(buffer);
            return {
              value: split.integer,
              rest: split.rest
            };
          },
          toArg: function(value, strict) {
            if (typeof value !== "number") {
              throw new Error("expected number");
            }
            return exports.toIntegerBuffer(value);
          }
        },
        t: {
          representation: "timetag",
          split: function(buffer, strict) {
            var split;
            split = exports.splitTimetag(buffer);
            return {
              value: split.timetag,
              rest: split.rest
            };
          },
          toArg: function(value, strict) {
            return exports.toTimetagBuffer(value);
          }
        },
        f: {
          representation: "float",
          split: function(buffer, strict) {
            return {
              value: binpack.unpackFloat32(buffer.slice(0, 4), "big"),
              rest: buffer.slice(4, buffer.length)
            };
          },
          toArg: function(value, strict) {
            if (typeof value !== "number") {
              throw new Error("expected number");
            }
            return binpack.packFloat32(value, "big");
          }
        },
        d: {
          representation: "double",
          split: function(buffer, strict) {
            return {
              value: binpack.unpackFloat64(buffer.slice(0, 8), "big"),
              rest: buffer.slice(8, buffer.length)
            };
          },
          toArg: function(value, strict) {
            if (typeof value !== "number") {
              throw new Error("expected number");
            }
            return binpack.packFloat64(value, "big");
          }
        },
        b: {
          representation: "blob",
          split: function(buffer, strict) {
            var length, ref;
            ref = exports.splitInteger(buffer), length = ref.integer, buffer = ref.rest;
            return {
              value: buffer.slice(0, length),
              rest: buffer.slice(length, buffer.length)
            };
          },
          toArg: function(value, strict) {
            var size;
            if (!Buffer.isBuffer(value)) {
              throw new Error("expected node.js Buffer");
            }
            size = exports.toIntegerBuffer(value.length);
            return exports.concat([size, value]);
          }
        },
        T: {
          representation: "true",
          split: function(buffer, strict) {
            return {
              rest: buffer,
              value: true
            };
          },
          toArg: function(value, strict) {
            if (!value && strict) {
              throw new Error("true must be true");
            }
            return new Buffer(0);
          }
        },
        F: {
          representation: "false",
          split: function(buffer, strict) {
            return {
              rest: buffer,
              value: false
            };
          },
          toArg: function(value, strict) {
            if (value && strict) {
              throw new Error("false must be false");
            }
            return new Buffer(0);
          }
        },
        N: {
          representation: "null",
          split: function(buffer, strict) {
            return {
              rest: buffer,
              value: null
            };
          },
          toArg: function(value, strict) {
            if (value && strict) {
              throw new Error("null must be false");
            }
            return new Buffer(0);
          }
        },
        I: {
          representation: "bang",
          split: function(buffer, strict) {
            return {
              rest: buffer,
              value: "bang"
            };
          },
          toArg: function(value, strict) {
            return new Buffer(0);
          }
        }
      };
      exports.oscTypeCodeToTypeString = function(code) {
        var ref;
        return (ref = oscTypeCodes[code]) != null ? ref.representation : void 0;
      };
      exports.typeStringToOscTypeCode = function(rep) {
        var code, str;
        for (code in oscTypeCodes) {
          if (!hasProp.call(oscTypeCodes, code))
            continue;
          str = oscTypeCodes[code].representation;
          if (str === rep) {
            return code;
          }
        }
        return null;
      };
      exports.argToTypeCode = function(arg, strict) {
        var code, value;
        if ((arg != null ? arg.type : void 0) != null && typeof arg.type === "string" && (code = exports.typeStringToOscTypeCode(arg.type)) != null) {
          return code;
        }
        value = (arg != null ? arg.value : void 0) != null ? arg.value : arg;
        if (strict && value == null) {
          throw new Error("Argument has no value");
        }
        if (typeof value === "string") {
          return "s";
        }
        if (typeof value === "number") {
          return "f";
        }
        if (Buffer.isBuffer(value)) {
          return "b";
        }
        if (typeof value === "boolean") {
          if (value) {
            return "T";
          } else {
            return "F";
          }
        }
        if (value === null) {
          return "N";
        }
        throw new Error("I don't know what type this is supposed to be.");
      };
      exports.splitOscArgument = function(buffer, type, strict) {
        var osctype;
        osctype = exports.typeStringToOscTypeCode(type);
        if (osctype != null) {
          return oscTypeCodes[osctype].split(buffer, strict);
        } else {
          throw new Error("I don't understand how I'm supposed to unpack " + type);
        }
      };
      exports.toOscArgument = function(value, type, strict) {
        var osctype;
        osctype = exports.typeStringToOscTypeCode(type);
        if (osctype != null) {
          return oscTypeCodes[osctype].toArg(value, strict);
        } else {
          throw new Error("I don't know how to pack " + type);
        }
      };
      exports.fromOscMessage = function(buffer, strict) {
        var address, arg, args, arrayStack, built, j, len, ref, ref1, type, typeString, types;
        ref = exports.splitOscString(buffer, strict), address = ref.string, buffer = ref.rest;
        if (strict && address[0] !== "/") {
          throw StrictError("addresses must start with /");
        }
        if (!buffer.length) {
          return {
            address,
            args: []
          };
        }
        ref1 = exports.splitOscString(buffer, strict), types = ref1.string, buffer = ref1.rest;
        if (types[0] !== ",") {
          if (strict) {
            throw StrictError("Argument lists must begin with ,");
          }
          return {
            address,
            args: []
          };
        }
        types = types.slice(1, +types.length + 1 || 9e9);
        args = [];
        arrayStack = [args];
        for (j = 0, len = types.length; j < len; j++) {
          type = types[j];
          if (type === "[") {
            arrayStack.push([]);
            continue;
          }
          if (type === "]") {
            if (arrayStack.length <= 1) {
              if (strict) {
                throw new StrictError("Mismatched ']' character.");
              }
            } else {
              built = arrayStack.pop();
              arrayStack[arrayStack.length - 1].push({
                type: "array",
                value: built
              });
            }
            continue;
          }
          typeString = exports.oscTypeCodeToTypeString(type);
          if (typeString == null) {
            throw new Error("I don't understand the argument code " + type);
          }
          arg = exports.splitOscArgument(buffer, typeString, strict);
          if (arg != null) {
            buffer = arg.rest;
          }
          arrayStack[arrayStack.length - 1].push({
            type: typeString,
            value: arg != null ? arg.value : void 0
          });
        }
        if (arrayStack.length !== 1 && strict) {
          throw new StrictError("Mismatched '[' character");
        }
        return {
          address,
          args,
          oscType: "message"
        };
      };
      exports.fromOscBundle = function(buffer, strict) {
        var bundleTag, convertedElems, ref, ref1, timetag;
        ref = exports.splitOscString(buffer, strict), bundleTag = ref.string, buffer = ref.rest;
        if (bundleTag !== "#bundle") {
          throw new Error("osc-bundles must begin with #bundle");
        }
        ref1 = exports.splitTimetag(buffer), timetag = ref1.timetag, buffer = ref1.rest;
        convertedElems = mapBundleList(buffer, function(buffer2) {
          return exports.fromOscPacket(buffer2, strict);
        });
        return {
          timetag,
          elements: convertedElems,
          oscType: "bundle"
        };
      };
      exports.fromOscPacket = function(buffer, strict) {
        if (isOscBundleBuffer(buffer, strict)) {
          return exports.fromOscBundle(buffer, strict);
        } else {
          return exports.fromOscMessage(buffer, strict);
        }
      };
      getArrayArg = function(arg) {
        if (IsArray(arg)) {
          return arg;
        } else if ((arg != null ? arg.type : void 0) === "array" && IsArray(arg != null ? arg.value : void 0)) {
          return arg.value;
        } else if (arg != null && arg.type == null && IsArray(arg.value)) {
          return arg.value;
        } else {
          return null;
        }
      };
      toOscTypeAndArgs = function(argList, strict) {
        var arg, buff, j, len, oscargs, osctype, ref, thisArgs, thisType, typeCode, value;
        osctype = "";
        oscargs = [];
        for (j = 0, len = argList.length; j < len; j++) {
          arg = argList[j];
          if (getArrayArg(arg) != null) {
            ref = toOscTypeAndArgs(getArrayArg(arg), strict), thisType = ref[0], thisArgs = ref[1];
            osctype += "[" + thisType + "]";
            oscargs = oscargs.concat(thisArgs);
            continue;
          }
          typeCode = exports.argToTypeCode(arg, strict);
          if (typeCode != null) {
            value = arg != null ? arg.value : void 0;
            if (value === void 0) {
              value = arg;
            }
            buff = exports.toOscArgument(value, exports.oscTypeCodeToTypeString(typeCode), strict);
            if (buff != null) {
              oscargs.push(buff);
              osctype += typeCode;
            }
          }
        }
        return [osctype, oscargs];
      };
      exports.toOscMessage = function(message, strict) {
        var address, allArgs, args, old_arg, oscaddr, oscargs, osctype, ref;
        address = (message != null ? message.address : void 0) != null ? message.address : message;
        if (typeof address !== "string") {
          throw new Error("message must contain an address");
        }
        args = message != null ? message.args : void 0;
        if (args === void 0) {
          args = [];
        }
        if (!IsArray(args)) {
          old_arg = args;
          args = [];
          args[0] = old_arg;
        }
        oscaddr = exports.toOscString(address, strict);
        ref = toOscTypeAndArgs(args, strict), osctype = ref[0], oscargs = ref[1];
        osctype = "," + osctype;
        allArgs = exports.concat(oscargs);
        osctype = exports.toOscString(osctype);
        return exports.concat([oscaddr, osctype, allArgs]);
      };
      exports.toOscBundle = function(bundle, strict) {
        var allElems, buff, e, elem, elements, elemstr, j, len, oscBundleTag, oscElems, oscTimeTag, ref, ref1, size, timetag;
        if (strict && (bundle != null ? bundle.timetag : void 0) == null) {
          throw StrictError("bundles must have timetags.");
        }
        timetag = (ref = bundle != null ? bundle.timetag : void 0) != null ? ref : new Date();
        elements = (ref1 = bundle != null ? bundle.elements : void 0) != null ? ref1 : [];
        if (!IsArray(elements)) {
          elemstr = elements;
          elements = [];
          elements.push(elemstr);
        }
        oscBundleTag = exports.toOscString("#bundle");
        oscTimeTag = exports.toTimetagBuffer(timetag);
        oscElems = [];
        for (j = 0, len = elements.length; j < len; j++) {
          elem = elements[j];
          try {
            buff = exports.toOscPacket(elem, strict);
            size = exports.toIntegerBuffer(buff.length);
            oscElems.push(exports.concat([size, buff]));
          } catch (error) {
            e = error;
            null;
          }
        }
        allElems = exports.concat(oscElems);
        return exports.concat([oscBundleTag, oscTimeTag, allElems]);
      };
      exports.toOscPacket = function(bundleOrMessage, strict) {
        if ((bundleOrMessage != null ? bundleOrMessage.oscType : void 0) != null) {
          if (bundleOrMessage.oscType === "bundle") {
            return exports.toOscBundle(bundleOrMessage, strict);
          }
          return exports.toOscMessage(bundleOrMessage, strict);
        }
        if ((bundleOrMessage != null ? bundleOrMessage.timetag : void 0) != null || (bundleOrMessage != null ? bundleOrMessage.elements : void 0) != null) {
          return exports.toOscBundle(bundleOrMessage, strict);
        }
        return exports.toOscMessage(bundleOrMessage, strict);
      };
      exports.applyMessageTranformerToBundle = function(transform) {
        return function(buffer) {
          var bundleTagBuffer, copyIndex, elem, elems, j, k, len, len1, lengthBuff, outBuffer, ref, string, timetagBuffer, totalLength;
          ref = exports.splitOscString(buffer), string = ref.string, buffer = ref.rest;
          if (string !== "#bundle") {
            throw new Error("osc-bundles must begin with #bundle");
          }
          bundleTagBuffer = exports.toOscString(string);
          timetagBuffer = buffer.slice(0, 8);
          buffer = buffer.slice(8, buffer.length);
          elems = mapBundleList(buffer, function(buffer2) {
            return exports.applyTransform(buffer2, transform, exports.applyMessageTranformerToBundle(transform));
          });
          totalLength = bundleTagBuffer.length + timetagBuffer.length;
          for (j = 0, len = elems.length; j < len; j++) {
            elem = elems[j];
            totalLength += 4 + elem.length;
          }
          outBuffer = new Buffer(totalLength);
          bundleTagBuffer.copy(outBuffer, 0);
          timetagBuffer.copy(outBuffer, bundleTagBuffer.length);
          copyIndex = bundleTagBuffer.length + timetagBuffer.length;
          for (k = 0, len1 = elems.length; k < len1; k++) {
            elem = elems[k];
            lengthBuff = exports.toIntegerBuffer(elem.length);
            lengthBuff.copy(outBuffer, copyIndex);
            copyIndex += 4;
            elem.copy(outBuffer, copyIndex);
            copyIndex += elem.length;
          }
          return outBuffer;
        };
      };
      exports.applyTransform = function(buffer, mTransform, bundleTransform) {
        if (bundleTransform == null) {
          bundleTransform = exports.applyMessageTranformerToBundle(mTransform);
        }
        if (isOscBundleBuffer(buffer)) {
          return bundleTransform(buffer);
        } else {
          return mTransform(buffer);
        }
      };
      exports.addressTransform = function(transform) {
        return function(buffer) {
          var ref, rest, string;
          ref = exports.splitOscString(buffer), string = ref.string, rest = ref.rest;
          string = transform(string);
          return exports.concat([exports.toOscString(string), rest]);
        };
      };
      exports.messageTransform = function(transform) {
        return function(buffer) {
          var message;
          message = exports.fromOscMessage(buffer);
          return exports.toOscMessage(transform(message));
        };
      };
      IsArray = Array.isArray;
      StrictError = function(str) {
        return new Error("Strict Error: " + str);
      };
      padding = function(str) {
        var bufflength;
        bufflength = Buffer.byteLength(str);
        return 4 - bufflength % 4;
      };
      isOscBundleBuffer = function(buffer, strict) {
        var string;
        string = exports.splitOscString(buffer, strict).string;
        return string === "#bundle";
      };
      mapBundleList = function(buffer, func) {
        var e, elem, elems, j, len, nonNullElems, size, thisElemBuffer;
        elems = function() {
          var ref, results;
          results = [];
          while (buffer.length) {
            ref = exports.splitInteger(buffer), size = ref.integer, buffer = ref.rest;
            if (size > buffer.length) {
              throw new Error("Invalid bundle list: size of element is bigger than buffer");
            }
            thisElemBuffer = buffer.slice(0, size);
            buffer = buffer.slice(size, buffer.length);
            try {
              results.push(func(thisElemBuffer));
            } catch (error) {
              e = error;
              results.push(null);
            }
          }
          return results;
        }();
        nonNullElems = [];
        for (j = 0, len = elems.length; j < len; j++) {
          elem = elems[j];
          if (elem != null) {
            nonNullElems.push(elem);
          }
        }
        return nonNullElems;
      };
    }).call(exports);
  }
});

// node_modules/osc-min/lib/index.js
var require_lib = __commonJS({
  "node_modules/osc-min/lib/index.js"(exports) {
    (function() {
      var utils, coffee;
      utils = require_osc_utilities();
      exports.fromBuffer = function(buffer, strict) {
        if (buffer instanceof ArrayBuffer) {
          buffer = new Buffer(new Uint8Array(buffer));
        } else if (buffer instanceof Uint8Array) {
          buffer = new Buffer(buffer);
        }
        return utils.fromOscPacket(buffer, strict);
      };
      exports.toBuffer = function(object, strict, opt) {
        if (typeof object === "string")
          return utils.toOscPacket({ "address": object, "args": strict }, opt);
        return utils.toOscPacket(object, strict);
      };
      exports.applyAddressTransform = function(buffer, transform) {
        return utils.applyTransform(buffer, utils.addressTransform(transform));
      };
      exports.applyMessageTransform = function(buffer, transform) {
        return utils.applyTransform(buffer, utils.messageTransform(transform));
      };
      exports.timetagToDate = utils.timetagToDate;
      exports.dateToTimetag = utils.dateToTimetag;
      exports.timetagToTimestamp = utils.timetagToTimestamp;
      exports.timestampToTimetag = utils.timestampToTimetag;
    }).call(exports);
  }
});

// node_modules/node-osc/dist/lib/internal/decode.js
var require_decode = __commonJS({
  "node_modules/node-osc/dist/lib/internal/decode.js"(exports, module2) {
    "use strict";
    var oscMin = require_lib();
    function sanitizeMessage(decoded) {
      const message = [];
      message.push(decoded.address);
      decoded.args.forEach((arg) => {
        message.push(arg.value);
      });
      return message;
    }
    function sanitizeBundle(decoded) {
      decoded.elements = decoded.elements.map((element) => {
        if (element.oscType === "bundle")
          return sanitizeBundle(element);
        else if (element.oscType === "message")
          return sanitizeMessage(element);
      });
      return decoded;
    }
    function decode(data) {
      const decoded = oscMin.fromBuffer(data);
      if (decoded.oscType === "bundle") {
        return sanitizeBundle(decoded);
      } else if (decoded.oscType === "message") {
        return sanitizeMessage(decoded);
      } else {
        throw new Error("Malformed Packet");
      }
    }
    module2.exports = decode;
  }
});

// node_modules/node-osc/dist/lib/Server.js
var require_Server = __commonJS({
  "node_modules/node-osc/dist/lib/Server.js"(exports, module2) {
    "use strict";
    var node_dgram = require("dgram");
    var node_events = require("events");
    var decode = require_decode();
    var Server2 = class extends node_events.EventEmitter {
      constructor(port, host = "127.0.0.1", cb) {
        super();
        if (typeof host === "function") {
          cb = host;
          host = "127.0.0.1";
        }
        if (!cb)
          cb = () => {
          };
        let decoded;
        this.port = port;
        this.host = host;
        this._sock = node_dgram.createSocket({
          type: "udp4",
          reuseAddr: true
        });
        this._sock.bind(port, host);
        this._sock.on("listening", () => {
          this.emit("listening");
          cb();
        });
        this._sock.on("message", (msg, rinfo) => {
          try {
            decoded = decode(msg);
          } catch (e) {
            const error = new Error(`can't decode incoming message: ${e.message}`);
            this.emit("error", error, rinfo);
            return;
          }
          if (decoded.elements) {
            this.emit("bundle", decoded, rinfo);
          } else if (decoded) {
            this.emit("message", decoded, rinfo);
            this.emit(decoded[0], decoded, rinfo);
          }
        });
      }
      close(cb) {
        this._sock.close(cb);
      }
    };
    module2.exports = Server2;
  }
});

// node_modules/node-osc/dist/lib/Client.js
var require_Client = __commonJS({
  "node_modules/node-osc/dist/lib/Client.js"(exports, module2) {
    "use strict";
    var node_dgram = require("dgram");
    var oscMin = require_lib();
    var Message2 = require_Message();
    var { toBuffer } = oscMin;
    var Client2 = class {
      constructor(host, port) {
        this.host = host;
        this.port = port;
        this._sock = node_dgram.createSocket({
          type: "udp4",
          reuseAddr: true
        });
      }
      close(cb) {
        this._sock.close(cb);
      }
      send(...args) {
        let message = args[0];
        let callback;
        if (typeof args[args.length - 1] === "function") {
          callback = args.pop();
        } else {
          callback = () => {
          };
        }
        if (message instanceof Array) {
          message = {
            address: message[0],
            args: message.splice(1)
          };
        }
        let mes;
        let buf;
        try {
          switch (typeof message) {
            case "object":
              buf = toBuffer(message);
              this._sock.send(buf, 0, buf.length, this.port, this.host, callback);
              break;
            case "string":
              mes = new Message2(args[0]);
              for (let i = 1; i < args.length; i++) {
                mes.append(args[i]);
              }
              buf = toBuffer(mes);
              this._sock.send(buf, 0, buf.length, this.port, this.host, callback);
              break;
            default:
              throw new TypeError("That Message Just Doesn't Seem Right");
          }
        } catch (e) {
          if (e.code !== "ERR_SOCKET_DGRAM_NOT_RUNNING")
            throw e;
          const error = new ReferenceError("Cannot send message on closed socket.");
          error.code = e.code;
          callback(error);
        }
      }
    };
    module2.exports = Client2;
  }
});

// node_modules/node-osc/dist/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/node-osc/dist/lib/index.js"(exports) {
    "use strict";
    var Message2 = require_Message();
    var Bundle = require_Bundle();
    var Server2 = require_Server();
    var Client2 = require_Client();
    exports.Message = Message2;
    exports.Bundle = Bundle;
    exports.Server = Server2;
    exports.Client = Client2;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util = require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter;
    }
  }
});

// node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/ws/lib/constants.js"(exports, module2) {
    "use strict";
    var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
    var hasBlob = typeof Blob !== "undefined";
    if (hasBlob)
      BINARY_TYPES.push("blob");
    module2.exports = {
      BINARY_TYPES,
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      hasBlob,
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports, module2) {
    "use strict";
    var { isUtf8 } = require("buffer");
    var { hasBlob } = require_constants();
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    function isBlob(value) {
      return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
    }
    module2.exports = {
      isBlob,
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var DEFER_EVENT = 6;
    var Receiver = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n,
            buf.length - n
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n,
              buf.length - n
            );
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);
        if (!this._errored)
          cb();
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @param {Function} cb Callback
       * @private
       */
      getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          const error = this.createError(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
          cb(error);
          return;
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          const error = this.createError(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
          cb(error);
          return;
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (!this._fragmented) {
            const error = this.createError(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            const error = this.createError(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            const error = this.createError(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
            cb(error);
            return;
          }
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            const error = this.createError(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
            cb(error);
            return;
          }
        } else {
          const error = this.createError(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
          cb(error);
          return;
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            const error = this.createError(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
            cb(error);
            return;
          }
        } else if (this._masked) {
          const error = this.createError(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
          cb(error);
          return;
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          const error = this.createError(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
          cb(error);
          return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
      }
      /**
       * Payload length has been read.
       *
       * @param {Function} cb Callback
       * @private
       */
      haveLength(cb) {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
            cb(error);
            return;
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) {
          this.controlMessage(data, cb);
          return;
        }
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        this.dataMessage(cb);
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              const error = this.createError(
                RangeError,
                "Max payload size exceeded",
                false,
                1009,
                "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
              );
              cb(error);
              return;
            }
            this._fragments.push(buf);
          }
          this.dataMessage(cb);
          if (this._state === GET_INFO)
            this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @param {Function} cb Callback
       * @private
       */
      dataMessage(cb) {
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else if (this._binaryType === "blob") {
            data = new Blob(fragments);
          } else {
            data = fragments;
          }
          if (this._allowSynchronousEvents) {
            this.emit("message", data, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", data, true);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        } else {
          const buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(
              Error,
              "invalid UTF-8 sequence",
              true,
              1007,
              "WS_ERR_INVALID_UTF8"
            );
            cb(error);
            return;
          }
          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit("message", buf, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", buf, false);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        }
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data, cb) {
        if (this._opcode === 8) {
          if (data.length === 0) {
            this._loop = false;
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              const error = this.createError(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
              cb(error);
              return;
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              const error = this.createError(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
              cb(error);
              return;
            }
            this._loop = false;
            this.emit("conclude", code, buf);
            this.end();
          }
          this._state = GET_INFO;
          return;
        }
        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit(this._opcode === 9 ? "ping" : "pong", data);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
      /**
       * Builds an error object.
       *
       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
       * @param {String} message The error message
       * @param {Boolean} prefix Specifies whether or not to add a default prefix to
       *     `message`
       * @param {Number} statusCode The status code
       * @param {String} errorCode The exposed error code
       * @return {(Error|RangeError)} The error
       * @private
       */
      createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        const err = new ErrorCtor(
          prefix ? `Invalid WebSocket frame: ${message}` : message
        );
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
      }
    };
    module2.exports = Receiver;
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports, module2) {
    "use strict";
    var { Duplex } = require("stream");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants();
    var { isBlob, isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var RANDOM_POOL_SIZE = 8 * 1024;
    var randomPool;
    var randomPoolPointer = RANDOM_POOL_SIZE;
    var DEFAULT = 0;
    var DEFLATING = 1;
    var GET_BLOB_DATA = 2;
    var Sender = class {
      /**
       * Creates a Sender instance.
       *
       * @param {Duplex} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._queue = [];
        this._state = DEFAULT;
        this.onerror = NOOP;
        this[kWebSocket] = void 0;
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              if (randomPool === void 0) {
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }
              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }
            mask[0] = randomPool[randomPoolPointer++];
            mask[1] = randomPool[randomPoolPointer++];
            mask[2] = randomPool[randomPoolPointer++];
            mask[3] = randomPool[randomPoolPointer++];
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask)
          return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking)
          return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        const opts = {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
          } else {
            this.getBlobData(data, this._compress, opts, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      }
      /**
       * Gets the contents of a blob as binary data.
       *
       * @param {Blob} blob The blob
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     the data
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      getBlobData(blob, compress, options, cb) {
        this._bufferedBytes += options[kByteLength];
        this._state = GET_BLOB_DATA;
        blob.arrayBuffer().then((arrayBuffer) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while the blob was being read"
            );
            process.nextTick(callCallbacks, this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          const data = toBuffer(arrayBuffer);
          if (!compress) {
            this._state = DEFAULT;
            this.sendFrame(Sender.frame(data, options), cb);
            this.dequeue();
          } else {
            this.dispatch(data, compress, options, cb);
          }
        }).catch((err) => {
          process.nextTick(onError, this, err, cb);
        });
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._state = DEFLATING;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            callCallbacks(this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._state = DEFAULT;
          options.readOnly = false;
          this.sendFrame(Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (this._state === DEFAULT && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
    function callCallbacks(sender, err, cb) {
      if (typeof cb === "function")
        cb(err);
      for (let i = 0; i < sender._queue.length; i++) {
        const params = sender._queue[i];
        const callback = params[params.length - 1];
        if (typeof callback === "function")
          callback(err);
      }
    }
    function onError(sender, err, cb) {
      callCallbacks(sender, err, cb);
      sender.onerror(err);
    }
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values))
                values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Duplex, Readable } = require("stream");
    var { URL } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var { isBlob } = require_validation();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket = class extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._errorEmitted = false;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._autoPong = options.autoPong;
          this._isServer = true;
        }
      }
      /**
       * For historical reasons, the custom "nodebuffer" type is used by the default
       * instead of "blob".
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver({
          allowSynchronousEvents: options.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        const sender = new Sender(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._sender = sender;
        this._socket = socket;
        receiver[kWebSocket] = this;
        sender[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        sender.onerror = senderOnError;
        if (socket.setTimeout)
          socket.setTimeout(0);
        if (socket.setNoDelay)
          socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        setCloseTimer(this);
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain)
          this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute])
              return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function")
            return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket.prototype.addEventListener = addEventListener;
    WebSocket.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        allowSynchronousEvents: true,
        autoPong: true,
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      websocket._autoPong = opts.autoPong;
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL) {
        parsedUrl = address;
      } else {
        try {
          parsedUrl = new URL(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
      }
      if (parsedUrl.protocol === "http:") {
        parsedUrl.protocol = "ws:";
      } else if (parsedUrl.protocol === "https:") {
        parsedUrl.protocol = "wss:";
      }
      websocket._url = parsedUrl.href;
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https.request : http.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost)
              delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted])
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL(location, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket.CONNECTING)
          return;
        req = websocket._req = null;
        const upgrade = res.headers.upgrade;
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          allowSynchronousEvents: opts.allowSynchronousEvents,
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket.CLOSING;
      websocket._errorEmitted = true;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = isBlob(data) ? data.size : toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused)
        websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      if (websocket._autoPong)
        websocket.pong(data, !this._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function senderOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket.readyState === WebSocket.CLOSED)
        return;
      if (websocket.readyState === WebSocket.OPEN) {
        websocket._readyState = WebSocket.CLOSING;
        setCloseTimer(websocket);
      }
      this._socket.end();
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function setCloseTimer(websocket) {
      websocket._closeTimer = setTimeout(
        websocket._socket.destroy.bind(websocket._socket),
        closeTimeout
      );
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/ws/lib/stream.js"(exports, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data))
          ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused)
          ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/ws/lib/subprotocol.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse };
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http = require("http");
    var { Duplex } = require("stream");
    var { createHash } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket = require_websocket();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Boolean} [options.autoPong=true] Specifies whether or not to
       *     automatically send a pong in response to a ping
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          allowSynchronousEvents: true,
          autoPong: true,
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const upgrade = req.headers.upgrade;
        const version = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (key === void 0 || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version !== 8 && version !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null, void 0, this.options);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message);
      }
    }
  }
});

// node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/ws/index.js"(exports, module2) {
    "use strict";
    var WebSocket = require_websocket();
    WebSocket.createWebSocketStream = require_stream();
    WebSocket.Server = require_websocket_server();
    WebSocket.Receiver = require_receiver();
    WebSocket.Sender = require_sender();
    WebSocket.WebSocket = WebSocket;
    WebSocket.WebSocketServer = WebSocket.Server;
    module2.exports = WebSocket;
  }
});

// node_modules/isomorphic-ws/node.js
var require_node2 = __commonJS({
  "node_modules/isomorphic-ws/node.js"(exports, module2) {
    "use strict";
    module2.exports = require_ws();
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports, module2) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module2.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof global !== "undefined" && global.crypto) {
          crypto = global.crypto;
        }
        if (!crypto && typeof require === "function") {
          try {
            crypto = require("crypto");
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/crypto-js/sha256.js"(exports, module2) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module2.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n2) {
            var sqrtN = Math2.sqrt(n2);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n2 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n2) {
            return (n2 - (n2 | 0)) * 4294967296 | 0;
          }
          var n = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
              nPrime++;
            }
            n++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H2 = this._hash.words;
            var a = H2[0];
            var b2 = H2[1];
            var c = H2[2];
            var d = H2[3];
            var e = H2[4];
            var f = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f ^ ~e & g;
              var maj = a & b2 ^ a & c ^ b2 & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K[i] + W[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f;
              f = e;
              e = d + t1 | 0;
              d = c;
              c = b2;
              b2 = a;
              a = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b2 | 0;
            H2[2] = H2[2] + c | 0;
            H2[3] = H2[3] + d | 0;
            H2[4] = H2[4] + e | 0;
            H2[5] = H2[5] + f | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  }
});

// node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "node_modules/crypto-js/enc-base64.js"(exports, module2) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module2.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64 = C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  }
});

// node_modules/obs-websocket-js/dist/chunk-RL7MGYX4.cjs
var require_chunk_RL7MGYX4 = __commonJS({
  "node_modules/obs-websocket-js/dist/chunk-RL7MGYX4.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _class;
    var WebSocketOpCode = /* @__PURE__ */ ((WebSocketOpCode2) => {
      WebSocketOpCode2[WebSocketOpCode2["Hello"] = 0] = "Hello";
      WebSocketOpCode2[WebSocketOpCode2["Identify"] = 1] = "Identify";
      WebSocketOpCode2[WebSocketOpCode2["Identified"] = 2] = "Identified";
      WebSocketOpCode2[WebSocketOpCode2["Reidentify"] = 3] = "Reidentify";
      WebSocketOpCode2[WebSocketOpCode2["Event"] = 5] = "Event";
      WebSocketOpCode2[WebSocketOpCode2["Request"] = 6] = "Request";
      WebSocketOpCode2[WebSocketOpCode2["RequestResponse"] = 7] = "RequestResponse";
      WebSocketOpCode2[WebSocketOpCode2["RequestBatch"] = 8] = "RequestBatch";
      WebSocketOpCode2[WebSocketOpCode2["RequestBatchResponse"] = 9] = "RequestBatchResponse";
      return WebSocketOpCode2;
    })(WebSocketOpCode || {});
    var EventSubscription = /* @__PURE__ */ ((EventSubscription2) => {
      EventSubscription2[EventSubscription2["None"] = 0] = "None";
      EventSubscription2[EventSubscription2["General"] = 1] = "General";
      EventSubscription2[EventSubscription2["Config"] = 2] = "Config";
      EventSubscription2[EventSubscription2["Scenes"] = 4] = "Scenes";
      EventSubscription2[EventSubscription2["Inputs"] = 8] = "Inputs";
      EventSubscription2[EventSubscription2["Transitions"] = 16] = "Transitions";
      EventSubscription2[EventSubscription2["Filters"] = 32] = "Filters";
      EventSubscription2[EventSubscription2["Outputs"] = 64] = "Outputs";
      EventSubscription2[EventSubscription2["SceneItems"] = 128] = "SceneItems";
      EventSubscription2[EventSubscription2["MediaInputs"] = 256] = "MediaInputs";
      EventSubscription2[EventSubscription2["Vendors"] = 512] = "Vendors";
      EventSubscription2[EventSubscription2["Ui"] = 1024] = "Ui";
      EventSubscription2[EventSubscription2["All"] = 2047] = "All";
      EventSubscription2[EventSubscription2["InputVolumeMeters"] = 65536] = "InputVolumeMeters";
      EventSubscription2[EventSubscription2["InputActiveStateChanged"] = 131072] = "InputActiveStateChanged";
      EventSubscription2[EventSubscription2["InputShowStateChanged"] = 262144] = "InputShowStateChanged";
      EventSubscription2[EventSubscription2["SceneItemTransformChanged"] = 524288] = "SceneItemTransformChanged";
      return EventSubscription2;
    })(EventSubscription || {});
    var RequestBatchExecutionType = /* @__PURE__ */ ((RequestBatchExecutionType2) => {
      RequestBatchExecutionType2[RequestBatchExecutionType2["None"] = -1] = "None";
      RequestBatchExecutionType2[RequestBatchExecutionType2["SerialRealtime"] = 0] = "SerialRealtime";
      RequestBatchExecutionType2[RequestBatchExecutionType2["SerialFrame"] = 1] = "SerialFrame";
      RequestBatchExecutionType2[RequestBatchExecutionType2["Parallel"] = 2] = "Parallel";
      return RequestBatchExecutionType2;
    })(RequestBatchExecutionType || {});
    var _debug = require_src();
    var _debug2 = _interopRequireDefault(_debug);
    var _eventemitter3 = require_eventemitter3();
    var _isomorphicws = require_node2();
    var _isomorphicws2 = _interopRequireDefault(_isomorphicws);
    var _sha256js = require_sha256();
    var _sha256js2 = _interopRequireDefault(_sha256js);
    var _encbase64js = require_enc_base64();
    var _encbase64js2 = _interopRequireDefault(_encbase64js);
    function authenticationHashing_default(salt, challenge, msg) {
      const hash = _encbase64js2.default.stringify(_sha256js2.default.call(void 0, msg + salt));
      return _encbase64js2.default.stringify(_sha256js2.default.call(void 0, hash + challenge));
    }
    var debug = _debug2.default.call(void 0, "obs-websocket-js");
    var OBSWebSocketError = class extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
      }
    };
    var BaseOBSWebSocket = (_class = class _BaseOBSWebSocket extends _eventemitter3.EventEmitter {
      constructor(...args) {
        super(...args);
        _class.prototype.__init.call(this);
        _class.prototype.__init2.call(this);
      }
      static __initStatic() {
        this.requestCounter = 1;
      }
      static generateMessageId() {
        return String(_BaseOBSWebSocket.requestCounter++);
      }
      __init() {
        this._identified = false;
      }
      __init2() {
        this.internalListeners = new (0, _eventemitter3.EventEmitter)();
      }
      get identified() {
        return this._identified;
      }
      /**
       * Connect to an obs-websocket server
       * @param url Websocket server to connect to (including ws:// or wss:// protocol)
       * @param password Password
       * @param identificationParams Data for Identify event
       * @returns Hello & Identified messages data (combined)
       */
      async connect(url = "ws://127.0.0.1:4455", password, identificationParams = {}) {
        if (this.socket) {
          await this.disconnect();
        }
        try {
          const connectionClosedPromise = this.internalEventPromise("ConnectionClosed");
          const connectionErrorPromise = this.internalEventPromise("ConnectionError");
          return await Promise.race([
            (async () => {
              const hello = await this.createConnection(url);
              this.emit("Hello", hello);
              return this.identify(hello, password, identificationParams);
            })(),
            // Choose the best promise for connection error/close
            // In browser connection close has close code + reason,
            // while in node error event has these
            new Promise((resolve, reject) => {
              void connectionErrorPromise.then((e) => {
                if (e.message) {
                  reject(e);
                }
              });
              void connectionClosedPromise.then((e) => {
                reject(e);
              });
            })
          ]);
        } catch (error) {
          await this.disconnect();
          throw error;
        }
      }
      /**
       * Disconnect from obs-websocket server
       */
      async disconnect() {
        if (!this.socket || this.socket.readyState === _isomorphicws2.default.CLOSED) {
          return;
        }
        const connectionClosedPromise = this.internalEventPromise("ConnectionClosed");
        this.socket.close();
        await connectionClosedPromise;
      }
      /**
       * Update session parameters
       * @param data Reidentify data
       * @returns Identified message data
       */
      async reidentify(data) {
        const identifiedPromise = this.internalEventPromise(`op:${2}`);
        await this.message(3, data);
        return identifiedPromise;
      }
      /**
       * Send a request to obs-websocket
       * @param requestType Request name
       * @param requestData Request data
       * @returns Request response
       */
      async call(requestType, requestData) {
        const requestId = _BaseOBSWebSocket.generateMessageId();
        const responsePromise = this.internalEventPromise(`res:${requestId}`);
        await this.message(6, {
          requestId,
          requestType,
          requestData
        });
        const { requestStatus, responseData } = await responsePromise;
        if (!requestStatus.result) {
          throw new OBSWebSocketError(requestStatus.code, requestStatus.comment);
        }
        return responseData;
      }
      /**
       * Send a batch request to obs-websocket
       * @param requests Array of Request objects (type and data)
       * @param options A set of options for how the batch will be executed
       * @param options.executionType The mode of execution obs-websocket will run the batch in
       * @param options.haltOnFailure Whether obs-websocket should stop executing the batch if one request fails
       * @returns RequestBatch response
       */
      async callBatch(requests, options = {}) {
        const requestId = _BaseOBSWebSocket.generateMessageId();
        const responsePromise = this.internalEventPromise(`res:${requestId}`);
        await this.message(8, {
          requestId,
          requests,
          ...options
        });
        const { results } = await responsePromise;
        return results;
      }
      /**
       * Cleanup from socket disconnection
       */
      cleanup() {
        if (!this.socket) {
          return;
        }
        this.socket.onopen = null;
        this.socket.onmessage = null;
        this.socket.onerror = null;
        this.socket.onclose = null;
        this.socket = void 0;
        this._identified = false;
        this.internalListeners.removeAllListeners();
      }
      /**
       * Create connection to specified obs-websocket server
       *
       * @private
       * @param url Websocket address
       * @returns Promise for hello data
       */
      async createConnection(url) {
        var _a;
        const connectionOpenedPromise = this.internalEventPromise("ConnectionOpened");
        const helloPromise = this.internalEventPromise(`op:${0}`);
        this.socket = new (0, _isomorphicws2.default)(url, this.protocol);
        this.socket.onopen = this.onOpen.bind(this);
        this.socket.onmessage = this.onMessage.bind(this);
        this.socket.onerror = this.onError.bind(this);
        this.socket.onclose = this.onClose.bind(this);
        await connectionOpenedPromise;
        const protocol = (_a = this.socket) == null ? void 0 : _a.protocol;
        if (!protocol) {
          throw new OBSWebSocketError(-1, "Server sent no subprotocol");
        }
        if (protocol !== this.protocol) {
          throw new OBSWebSocketError(-1, "Server sent an invalid subprotocol");
        }
        return helloPromise;
      }
      /**
       * Send identify message
       *
       * @private
       * @param hello Hello message data
       * @param password Password
       * @param identificationParams Identification params
       * @returns Hello & Identified messages data (combined)
       */
      async identify({
        authentication,
        rpcVersion,
        ...helloRest
      }, password, identificationParams = {}) {
        const data = {
          rpcVersion,
          ...identificationParams
        };
        if (authentication && password) {
          data.authentication = authenticationHashing_default(authentication.salt, authentication.challenge, password);
        }
        const identifiedPromise = this.internalEventPromise(`op:${2}`);
        await this.message(1, data);
        const identified = await identifiedPromise;
        this._identified = true;
        this.emit("Identified", identified);
        return {
          rpcVersion,
          ...helloRest,
          ...identified
        };
      }
      /**
       * Send message to obs-websocket
       *
       * @private
       * @param op WebSocketOpCode
       * @param d Message data
       */
      async message(op, d) {
        if (!this.socket) {
          throw new Error("Not connected");
        }
        if (!this.identified && op !== 1) {
          throw new Error("Socket not identified");
        }
        const encoded = await this.encodeMessage({
          op,
          d
        });
        this.socket.send(encoded);
      }
      /**
       * Create a promise to listen for an event on internal listener
       * (will be cleaned up on disconnect)
       *
       * @private
       * @param event Event to listen to
       * @returns Event data
       */
      async internalEventPromise(event) {
        return new Promise((resolve) => {
          this.internalListeners.once(event, resolve);
        });
      }
      /**
       * Websocket open event listener
       *
       * @private
       * @param e Event
       */
      onOpen(e) {
        debug("socket.open");
        this.emit("ConnectionOpened");
        this.internalListeners.emit("ConnectionOpened", e);
      }
      /**
       * Websocket message event listener
       *
       * @private
       * @param e Event
       */
      async onMessage(e) {
        try {
          const { op, d } = await this.decodeMessage(e.data);
          debug("socket.message: %d %j", op, d);
          if (op === void 0 || d === void 0) {
            return;
          }
          switch (op) {
            case 5: {
              const { eventType, eventData } = d;
              this.emit(eventType, eventData);
              return;
            }
            case 7:
            case 9: {
              const { requestId } = d;
              this.internalListeners.emit(`res:${requestId}`, d);
              return;
            }
            default:
              this.internalListeners.emit(`op:${op}`, d);
          }
        } catch (error) {
          debug("error handling message: %o", error);
        }
      }
      /**
       * Websocket error event listener
       *
       * @private
       * @param e ErrorEvent
       */
      onError(e) {
        debug("socket.error: %o", e);
        const error = new OBSWebSocketError(-1, e.message);
        this.emit("ConnectionError", error);
        this.internalListeners.emit("ConnectionError", error);
      }
      /**
       * Websocket close event listener
       *
       * @private
       * @param e Event
       */
      onClose(e) {
        debug("socket.close: %s (%d)", e.reason, e.code);
        const error = new OBSWebSocketError(e.code, e.reason);
        this.emit("ConnectionClosed", error);
        this.internalListeners.emit("ConnectionClosed", error);
        this.cleanup();
      }
    }, _class.__initStatic(), _class);
    if (typeof exports !== "undefined") {
      Object.defineProperty(exports, "__esModule", { value: true });
    }
    exports.WebSocketOpCode = WebSocketOpCode;
    exports.EventSubscription = EventSubscription;
    exports.RequestBatchExecutionType = RequestBatchExecutionType;
    exports.OBSWebSocketError = OBSWebSocketError;
    exports.BaseOBSWebSocket = BaseOBSWebSocket;
  }
});

// node_modules/@msgpack/msgpack/dist/utils/int.js
var require_int = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/int.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUint64 = exports.getInt64 = exports.setInt64 = exports.setUint64 = exports.UINT32_MAX = void 0;
    exports.UINT32_MAX = 4294967295;
    function setUint64(view, offset, value) {
      const high = value / 4294967296;
      const low = value;
      view.setUint32(offset, high);
      view.setUint32(offset + 4, low);
    }
    exports.setUint64 = setUint64;
    function setInt64(view, offset, value) {
      const high = Math.floor(value / 4294967296);
      const low = value;
      view.setUint32(offset, high);
      view.setUint32(offset + 4, low);
    }
    exports.setInt64 = setInt64;
    function getInt64(view, offset) {
      const high = view.getInt32(offset);
      const low = view.getUint32(offset + 4);
      return high * 4294967296 + low;
    }
    exports.getInt64 = getInt64;
    function getUint64(view, offset) {
      const high = view.getUint32(offset);
      const low = view.getUint32(offset + 4);
      return high * 4294967296 + low;
    }
    exports.getUint64 = getUint64;
  }
});

// node_modules/@msgpack/msgpack/dist/utils/utf8.js
var require_utf8 = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/utf8.js"(exports) {
    "use strict";
    var _a;
    var _b;
    var _c;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utf8DecodeTD = exports.TEXT_DECODER_THRESHOLD = exports.utf8DecodeJs = exports.utf8EncodeTE = exports.TEXT_ENCODER_THRESHOLD = exports.utf8EncodeJs = exports.utf8Count = void 0;
    var int_1 = require_int();
    var TEXT_ENCODING_AVAILABLE = (typeof process === "undefined" || ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a["TEXT_ENCODING"]) !== "never") && typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined";
    function utf8Count(str) {
      const strLength = str.length;
      let byteLength = 0;
      let pos = 0;
      while (pos < strLength) {
        let value = str.charCodeAt(pos++);
        if ((value & 4294967168) === 0) {
          byteLength++;
          continue;
        } else if ((value & 4294965248) === 0) {
          byteLength += 2;
        } else {
          if (value >= 55296 && value <= 56319) {
            if (pos < strLength) {
              const extra = str.charCodeAt(pos);
              if ((extra & 64512) === 56320) {
                ++pos;
                value = ((value & 1023) << 10) + (extra & 1023) + 65536;
              }
            }
          }
          if ((value & 4294901760) === 0) {
            byteLength += 3;
          } else {
            byteLength += 4;
          }
        }
      }
      return byteLength;
    }
    exports.utf8Count = utf8Count;
    function utf8EncodeJs(str, output, outputOffset) {
      const strLength = str.length;
      let offset = outputOffset;
      let pos = 0;
      while (pos < strLength) {
        let value = str.charCodeAt(pos++);
        if ((value & 4294967168) === 0) {
          output[offset++] = value;
          continue;
        } else if ((value & 4294965248) === 0) {
          output[offset++] = value >> 6 & 31 | 192;
        } else {
          if (value >= 55296 && value <= 56319) {
            if (pos < strLength) {
              const extra = str.charCodeAt(pos);
              if ((extra & 64512) === 56320) {
                ++pos;
                value = ((value & 1023) << 10) + (extra & 1023) + 65536;
              }
            }
          }
          if ((value & 4294901760) === 0) {
            output[offset++] = value >> 12 & 15 | 224;
            output[offset++] = value >> 6 & 63 | 128;
          } else {
            output[offset++] = value >> 18 & 7 | 240;
            output[offset++] = value >> 12 & 63 | 128;
            output[offset++] = value >> 6 & 63 | 128;
          }
        }
        output[offset++] = value & 63 | 128;
      }
    }
    exports.utf8EncodeJs = utf8EncodeJs;
    var sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : void 0;
    exports.TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? int_1.UINT32_MAX : typeof process !== "undefined" && ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b["TEXT_ENCODING"]) !== "force" ? 200 : 0;
    function utf8EncodeTEencode(str, output, outputOffset) {
      output.set(sharedTextEncoder.encode(str), outputOffset);
    }
    function utf8EncodeTEencodeInto(str, output, outputOffset) {
      sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
    }
    exports.utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;
    var CHUNK_SIZE = 4096;
    function utf8DecodeJs(bytes, inputOffset, byteLength) {
      let offset = inputOffset;
      const end = offset + byteLength;
      const units = [];
      let result = "";
      while (offset < end) {
        const byte1 = bytes[offset++];
        if ((byte1 & 128) === 0) {
          units.push(byte1);
        } else if ((byte1 & 224) === 192) {
          const byte2 = bytes[offset++] & 63;
          units.push((byte1 & 31) << 6 | byte2);
        } else if ((byte1 & 240) === 224) {
          const byte2 = bytes[offset++] & 63;
          const byte3 = bytes[offset++] & 63;
          units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
        } else if ((byte1 & 248) === 240) {
          const byte2 = bytes[offset++] & 63;
          const byte3 = bytes[offset++] & 63;
          const byte4 = bytes[offset++] & 63;
          let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
          if (unit > 65535) {
            unit -= 65536;
            units.push(unit >>> 10 & 1023 | 55296);
            unit = 56320 | unit & 1023;
          }
          units.push(unit);
        } else {
          units.push(byte1);
        }
        if (units.length >= CHUNK_SIZE) {
          result += String.fromCharCode(...units);
          units.length = 0;
        }
      }
      if (units.length > 0) {
        result += String.fromCharCode(...units);
      }
      return result;
    }
    exports.utf8DecodeJs = utf8DecodeJs;
    var sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;
    exports.TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? int_1.UINT32_MAX : typeof process !== "undefined" && ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c["TEXT_DECODER"]) !== "force" ? 200 : 0;
    function utf8DecodeTD(bytes, inputOffset, byteLength) {
      const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
      return sharedTextDecoder.decode(stringBytes);
    }
    exports.utf8DecodeTD = utf8DecodeTD;
  }
});

// node_modules/@msgpack/msgpack/dist/ExtData.js
var require_ExtData = __commonJS({
  "node_modules/@msgpack/msgpack/dist/ExtData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtData = void 0;
    var ExtData = class {
      constructor(type, data) {
        this.type = type;
        this.data = data;
      }
    };
    exports.ExtData = ExtData;
  }
});

// node_modules/@msgpack/msgpack/dist/DecodeError.js
var require_DecodeError = __commonJS({
  "node_modules/@msgpack/msgpack/dist/DecodeError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecodeError = void 0;
    var DecodeError = class extends Error {
      constructor(message) {
        super(message);
        const proto = Object.create(DecodeError.prototype);
        Object.setPrototypeOf(this, proto);
        Object.defineProperty(this, "name", {
          configurable: true,
          enumerable: false,
          value: DecodeError.name
        });
      }
    };
    exports.DecodeError = DecodeError;
  }
});

// node_modules/@msgpack/msgpack/dist/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/@msgpack/msgpack/dist/timestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timestampExtension = exports.decodeTimestampExtension = exports.decodeTimestampToTimeSpec = exports.encodeTimestampExtension = exports.encodeDateToTimeSpec = exports.encodeTimeSpecToTimestamp = exports.EXT_TIMESTAMP = void 0;
    var DecodeError_1 = require_DecodeError();
    var int_1 = require_int();
    exports.EXT_TIMESTAMP = -1;
    var TIMESTAMP32_MAX_SEC = 4294967296 - 1;
    var TIMESTAMP64_MAX_SEC = 17179869184 - 1;
    function encodeTimeSpecToTimestamp({ sec, nsec }) {
      if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
          const rv = new Uint8Array(4);
          const view = new DataView(rv.buffer);
          view.setUint32(0, sec);
          return rv;
        } else {
          const secHigh = sec / 4294967296;
          const secLow = sec & 4294967295;
          const rv = new Uint8Array(8);
          const view = new DataView(rv.buffer);
          view.setUint32(0, nsec << 2 | secHigh & 3);
          view.setUint32(4, secLow);
          return rv;
        }
      } else {
        const rv = new Uint8Array(12);
        const view = new DataView(rv.buffer);
        view.setUint32(0, nsec);
        (0, int_1.setInt64)(view, 4, sec);
        return rv;
      }
    }
    exports.encodeTimeSpecToTimestamp = encodeTimeSpecToTimestamp;
    function encodeDateToTimeSpec(date) {
      const msec = date.getTime();
      const sec = Math.floor(msec / 1e3);
      const nsec = (msec - sec * 1e3) * 1e6;
      const nsecInSec = Math.floor(nsec / 1e9);
      return {
        sec: sec + nsecInSec,
        nsec: nsec - nsecInSec * 1e9
      };
    }
    exports.encodeDateToTimeSpec = encodeDateToTimeSpec;
    function encodeTimestampExtension(object) {
      if (object instanceof Date) {
        const timeSpec = encodeDateToTimeSpec(object);
        return encodeTimeSpecToTimestamp(timeSpec);
      } else {
        return null;
      }
    }
    exports.encodeTimestampExtension = encodeTimestampExtension;
    function decodeTimestampToTimeSpec(data) {
      const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
      switch (data.byteLength) {
        case 4: {
          const sec = view.getUint32(0);
          const nsec = 0;
          return { sec, nsec };
        }
        case 8: {
          const nsec30AndSecHigh2 = view.getUint32(0);
          const secLow32 = view.getUint32(4);
          const sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
          const nsec = nsec30AndSecHigh2 >>> 2;
          return { sec, nsec };
        }
        case 12: {
          const sec = (0, int_1.getInt64)(view, 4);
          const nsec = view.getUint32(0);
          return { sec, nsec };
        }
        default:
          throw new DecodeError_1.DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);
      }
    }
    exports.decodeTimestampToTimeSpec = decodeTimestampToTimeSpec;
    function decodeTimestampExtension(data) {
      const timeSpec = decodeTimestampToTimeSpec(data);
      return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
    }
    exports.decodeTimestampExtension = decodeTimestampExtension;
    exports.timestampExtension = {
      type: exports.EXT_TIMESTAMP,
      encode: encodeTimestampExtension,
      decode: decodeTimestampExtension
    };
  }
});

// node_modules/@msgpack/msgpack/dist/ExtensionCodec.js
var require_ExtensionCodec = __commonJS({
  "node_modules/@msgpack/msgpack/dist/ExtensionCodec.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtensionCodec = void 0;
    var ExtData_1 = require_ExtData();
    var timestamp_1 = require_timestamp();
    var ExtensionCodec = class {
      constructor() {
        this.builtInEncoders = [];
        this.builtInDecoders = [];
        this.encoders = [];
        this.decoders = [];
        this.register(timestamp_1.timestampExtension);
      }
      register({ type, encode, decode }) {
        if (type >= 0) {
          this.encoders[type] = encode;
          this.decoders[type] = decode;
        } else {
          const index = 1 + type;
          this.builtInEncoders[index] = encode;
          this.builtInDecoders[index] = decode;
        }
      }
      tryToEncode(object, context) {
        for (let i = 0; i < this.builtInEncoders.length; i++) {
          const encodeExt = this.builtInEncoders[i];
          if (encodeExt != null) {
            const data = encodeExt(object, context);
            if (data != null) {
              const type = -1 - i;
              return new ExtData_1.ExtData(type, data);
            }
          }
        }
        for (let i = 0; i < this.encoders.length; i++) {
          const encodeExt = this.encoders[i];
          if (encodeExt != null) {
            const data = encodeExt(object, context);
            if (data != null) {
              const type = i;
              return new ExtData_1.ExtData(type, data);
            }
          }
        }
        if (object instanceof ExtData_1.ExtData) {
          return object;
        }
        return null;
      }
      decode(data, type, context) {
        const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
        if (decodeExt) {
          return decodeExt(data, type, context);
        } else {
          return new ExtData_1.ExtData(type, data);
        }
      }
    };
    exports.ExtensionCodec = ExtensionCodec;
    ExtensionCodec.defaultCodec = new ExtensionCodec();
  }
});

// node_modules/@msgpack/msgpack/dist/utils/typedArrays.js
var require_typedArrays = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/typedArrays.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDataView = exports.ensureUint8Array = void 0;
    function ensureUint8Array(buffer) {
      if (buffer instanceof Uint8Array) {
        return buffer;
      } else if (ArrayBuffer.isView(buffer)) {
        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      } else if (buffer instanceof ArrayBuffer) {
        return new Uint8Array(buffer);
      } else {
        return Uint8Array.from(buffer);
      }
    }
    exports.ensureUint8Array = ensureUint8Array;
    function createDataView(buffer) {
      if (buffer instanceof ArrayBuffer) {
        return new DataView(buffer);
      }
      const bufferView = ensureUint8Array(buffer);
      return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
    }
    exports.createDataView = createDataView;
  }
});

// node_modules/@msgpack/msgpack/dist/Encoder.js
var require_Encoder = __commonJS({
  "node_modules/@msgpack/msgpack/dist/Encoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Encoder = exports.DEFAULT_INITIAL_BUFFER_SIZE = exports.DEFAULT_MAX_DEPTH = void 0;
    var utf8_1 = require_utf8();
    var ExtensionCodec_1 = require_ExtensionCodec();
    var int_1 = require_int();
    var typedArrays_1 = require_typedArrays();
    exports.DEFAULT_MAX_DEPTH = 100;
    exports.DEFAULT_INITIAL_BUFFER_SIZE = 2048;
    var Encoder = class {
      constructor(extensionCodec = ExtensionCodec_1.ExtensionCodec.defaultCodec, context = void 0, maxDepth = exports.DEFAULT_MAX_DEPTH, initialBufferSize = exports.DEFAULT_INITIAL_BUFFER_SIZE, sortKeys = false, forceFloat32 = false, ignoreUndefined = false, forceIntegerToFloat = false) {
        this.extensionCodec = extensionCodec;
        this.context = context;
        this.maxDepth = maxDepth;
        this.initialBufferSize = initialBufferSize;
        this.sortKeys = sortKeys;
        this.forceFloat32 = forceFloat32;
        this.ignoreUndefined = ignoreUndefined;
        this.forceIntegerToFloat = forceIntegerToFloat;
        this.pos = 0;
        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
        this.bytes = new Uint8Array(this.view.buffer);
      }
      reinitializeState() {
        this.pos = 0;
      }
      /**
       * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.
       *
       * @returns Encodes the object and returns a shared reference the encoder's internal buffer.
       */
      encodeSharedRef(object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.subarray(0, this.pos);
      }
      /**
       * @returns Encodes the object and returns a copy of the encoder's internal buffer.
       */
      encode(object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.slice(0, this.pos);
      }
      doEncode(object, depth) {
        if (depth > this.maxDepth) {
          throw new Error(`Too deep objects in depth ${depth}`);
        }
        if (object == null) {
          this.encodeNil();
        } else if (typeof object === "boolean") {
          this.encodeBoolean(object);
        } else if (typeof object === "number") {
          this.encodeNumber(object);
        } else if (typeof object === "string") {
          this.encodeString(object);
        } else {
          this.encodeObject(object, depth);
        }
      }
      ensureBufferSizeToWrite(sizeToWrite) {
        const requiredSize = this.pos + sizeToWrite;
        if (this.view.byteLength < requiredSize) {
          this.resizeBuffer(requiredSize * 2);
        }
      }
      resizeBuffer(newSize) {
        const newBuffer = new ArrayBuffer(newSize);
        const newBytes = new Uint8Array(newBuffer);
        const newView = new DataView(newBuffer);
        newBytes.set(this.bytes);
        this.view = newView;
        this.bytes = newBytes;
      }
      encodeNil() {
        this.writeU8(192);
      }
      encodeBoolean(object) {
        if (object === false) {
          this.writeU8(194);
        } else {
          this.writeU8(195);
        }
      }
      encodeNumber(object) {
        if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {
          if (object >= 0) {
            if (object < 128) {
              this.writeU8(object);
            } else if (object < 256) {
              this.writeU8(204);
              this.writeU8(object);
            } else if (object < 65536) {
              this.writeU8(205);
              this.writeU16(object);
            } else if (object < 4294967296) {
              this.writeU8(206);
              this.writeU32(object);
            } else {
              this.writeU8(207);
              this.writeU64(object);
            }
          } else {
            if (object >= -32) {
              this.writeU8(224 | object + 32);
            } else if (object >= -128) {
              this.writeU8(208);
              this.writeI8(object);
            } else if (object >= -32768) {
              this.writeU8(209);
              this.writeI16(object);
            } else if (object >= -2147483648) {
              this.writeU8(210);
              this.writeI32(object);
            } else {
              this.writeU8(211);
              this.writeI64(object);
            }
          }
        } else {
          if (this.forceFloat32) {
            this.writeU8(202);
            this.writeF32(object);
          } else {
            this.writeU8(203);
            this.writeF64(object);
          }
        }
      }
      writeStringHeader(byteLength) {
        if (byteLength < 32) {
          this.writeU8(160 + byteLength);
        } else if (byteLength < 256) {
          this.writeU8(217);
          this.writeU8(byteLength);
        } else if (byteLength < 65536) {
          this.writeU8(218);
          this.writeU16(byteLength);
        } else if (byteLength < 4294967296) {
          this.writeU8(219);
          this.writeU32(byteLength);
        } else {
          throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);
        }
      }
      encodeString(object) {
        const maxHeaderSize = 1 + 4;
        const strLength = object.length;
        if (strLength > utf8_1.TEXT_ENCODER_THRESHOLD) {
          const byteLength = (0, utf8_1.utf8Count)(object);
          this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
          this.writeStringHeader(byteLength);
          (0, utf8_1.utf8EncodeTE)(object, this.bytes, this.pos);
          this.pos += byteLength;
        } else {
          const byteLength = (0, utf8_1.utf8Count)(object);
          this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
          this.writeStringHeader(byteLength);
          (0, utf8_1.utf8EncodeJs)(object, this.bytes, this.pos);
          this.pos += byteLength;
        }
      }
      encodeObject(object, depth) {
        const ext = this.extensionCodec.tryToEncode(object, this.context);
        if (ext != null) {
          this.encodeExtension(ext);
        } else if (Array.isArray(object)) {
          this.encodeArray(object, depth);
        } else if (ArrayBuffer.isView(object)) {
          this.encodeBinary(object);
        } else if (typeof object === "object") {
          this.encodeMap(object, depth);
        } else {
          throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);
        }
      }
      encodeBinary(object) {
        const size = object.byteLength;
        if (size < 256) {
          this.writeU8(196);
          this.writeU8(size);
        } else if (size < 65536) {
          this.writeU8(197);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(198);
          this.writeU32(size);
        } else {
          throw new Error(`Too large binary: ${size}`);
        }
        const bytes = (0, typedArrays_1.ensureUint8Array)(object);
        this.writeU8a(bytes);
      }
      encodeArray(object, depth) {
        const size = object.length;
        if (size < 16) {
          this.writeU8(144 + size);
        } else if (size < 65536) {
          this.writeU8(220);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(221);
          this.writeU32(size);
        } else {
          throw new Error(`Too large array: ${size}`);
        }
        for (const item of object) {
          this.doEncode(item, depth + 1);
        }
      }
      countWithoutUndefined(object, keys) {
        let count = 0;
        for (const key of keys) {
          if (object[key] !== void 0) {
            count++;
          }
        }
        return count;
      }
      encodeMap(object, depth) {
        const keys = Object.keys(object);
        if (this.sortKeys) {
          keys.sort();
        }
        const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;
        if (size < 16) {
          this.writeU8(128 + size);
        } else if (size < 65536) {
          this.writeU8(222);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(223);
          this.writeU32(size);
        } else {
          throw new Error(`Too large map object: ${size}`);
        }
        for (const key of keys) {
          const value = object[key];
          if (!(this.ignoreUndefined && value === void 0)) {
            this.encodeString(key);
            this.doEncode(value, depth + 1);
          }
        }
      }
      encodeExtension(ext) {
        const size = ext.data.length;
        if (size === 1) {
          this.writeU8(212);
        } else if (size === 2) {
          this.writeU8(213);
        } else if (size === 4) {
          this.writeU8(214);
        } else if (size === 8) {
          this.writeU8(215);
        } else if (size === 16) {
          this.writeU8(216);
        } else if (size < 256) {
          this.writeU8(199);
          this.writeU8(size);
        } else if (size < 65536) {
          this.writeU8(200);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(201);
          this.writeU32(size);
        } else {
          throw new Error(`Too large extension object: ${size}`);
        }
        this.writeI8(ext.type);
        this.writeU8a(ext.data);
      }
      writeU8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setUint8(this.pos, value);
        this.pos++;
      }
      writeU8a(values) {
        const size = values.length;
        this.ensureBufferSizeToWrite(size);
        this.bytes.set(values, this.pos);
        this.pos += size;
      }
      writeI8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setInt8(this.pos, value);
        this.pos++;
      }
      writeU16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setUint16(this.pos, value);
        this.pos += 2;
      }
      writeI16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setInt16(this.pos, value);
        this.pos += 2;
      }
      writeU32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setUint32(this.pos, value);
        this.pos += 4;
      }
      writeI32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setInt32(this.pos, value);
        this.pos += 4;
      }
      writeF32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setFloat32(this.pos, value);
        this.pos += 4;
      }
      writeF64(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setFloat64(this.pos, value);
        this.pos += 8;
      }
      writeU64(value) {
        this.ensureBufferSizeToWrite(8);
        (0, int_1.setUint64)(this.view, this.pos, value);
        this.pos += 8;
      }
      writeI64(value) {
        this.ensureBufferSizeToWrite(8);
        (0, int_1.setInt64)(this.view, this.pos, value);
        this.pos += 8;
      }
    };
    exports.Encoder = Encoder;
  }
});

// node_modules/@msgpack/msgpack/dist/encode.js
var require_encode = __commonJS({
  "node_modules/@msgpack/msgpack/dist/encode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = void 0;
    var Encoder_1 = require_Encoder();
    var defaultEncodeOptions = {};
    function encode(value, options = defaultEncodeOptions) {
      const encoder = new Encoder_1.Encoder(options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);
      return encoder.encodeSharedRef(value);
    }
    exports.encode = encode;
  }
});

// node_modules/@msgpack/msgpack/dist/utils/prettyByte.js
var require_prettyByte = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/prettyByte.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prettyByte = void 0;
    function prettyByte(byte) {
      return `${byte < 0 ? "-" : ""}0x${Math.abs(byte).toString(16).padStart(2, "0")}`;
    }
    exports.prettyByte = prettyByte;
  }
});

// node_modules/@msgpack/msgpack/dist/CachedKeyDecoder.js
var require_CachedKeyDecoder = __commonJS({
  "node_modules/@msgpack/msgpack/dist/CachedKeyDecoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CachedKeyDecoder = void 0;
    var utf8_1 = require_utf8();
    var DEFAULT_MAX_KEY_LENGTH = 16;
    var DEFAULT_MAX_LENGTH_PER_KEY = 16;
    var CachedKeyDecoder = class {
      constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {
        this.maxKeyLength = maxKeyLength;
        this.maxLengthPerKey = maxLengthPerKey;
        this.hit = 0;
        this.miss = 0;
        this.caches = [];
        for (let i = 0; i < this.maxKeyLength; i++) {
          this.caches.push([]);
        }
      }
      canBeCached(byteLength) {
        return byteLength > 0 && byteLength <= this.maxKeyLength;
      }
      find(bytes, inputOffset, byteLength) {
        const records = this.caches[byteLength - 1];
        FIND_CHUNK:
          for (const record of records) {
            const recordBytes = record.bytes;
            for (let j = 0; j < byteLength; j++) {
              if (recordBytes[j] !== bytes[inputOffset + j]) {
                continue FIND_CHUNK;
              }
            }
            return record.str;
          }
        return null;
      }
      store(bytes, value) {
        const records = this.caches[bytes.length - 1];
        const record = { bytes, str: value };
        if (records.length >= this.maxLengthPerKey) {
          records[Math.random() * records.length | 0] = record;
        } else {
          records.push(record);
        }
      }
      decode(bytes, inputOffset, byteLength) {
        const cachedValue = this.find(bytes, inputOffset, byteLength);
        if (cachedValue != null) {
          this.hit++;
          return cachedValue;
        }
        this.miss++;
        const str = (0, utf8_1.utf8DecodeJs)(bytes, inputOffset, byteLength);
        const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
        this.store(slicedCopyOfBytes, str);
        return str;
      }
    };
    exports.CachedKeyDecoder = CachedKeyDecoder;
  }
});

// node_modules/@msgpack/msgpack/dist/Decoder.js
var require_Decoder = __commonJS({
  "node_modules/@msgpack/msgpack/dist/Decoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Decoder = exports.DataViewIndexOutOfBoundsError = void 0;
    var prettyByte_1 = require_prettyByte();
    var ExtensionCodec_1 = require_ExtensionCodec();
    var int_1 = require_int();
    var utf8_1 = require_utf8();
    var typedArrays_1 = require_typedArrays();
    var CachedKeyDecoder_1 = require_CachedKeyDecoder();
    var DecodeError_1 = require_DecodeError();
    var isValidMapKeyType = (key) => {
      const keyType = typeof key;
      return keyType === "string" || keyType === "number";
    };
    var HEAD_BYTE_REQUIRED = -1;
    var EMPTY_VIEW = new DataView(new ArrayBuffer(0));
    var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
    exports.DataViewIndexOutOfBoundsError = (() => {
      try {
        EMPTY_VIEW.getInt8(0);
      } catch (e) {
        return e.constructor;
      }
      throw new Error("never reached");
    })();
    var MORE_DATA = new exports.DataViewIndexOutOfBoundsError("Insufficient data");
    var sharedCachedKeyDecoder = new CachedKeyDecoder_1.CachedKeyDecoder();
    var Decoder = class {
      constructor(extensionCodec = ExtensionCodec_1.ExtensionCodec.defaultCodec, context = void 0, maxStrLength = int_1.UINT32_MAX, maxBinLength = int_1.UINT32_MAX, maxArrayLength = int_1.UINT32_MAX, maxMapLength = int_1.UINT32_MAX, maxExtLength = int_1.UINT32_MAX, keyDecoder = sharedCachedKeyDecoder) {
        this.extensionCodec = extensionCodec;
        this.context = context;
        this.maxStrLength = maxStrLength;
        this.maxBinLength = maxBinLength;
        this.maxArrayLength = maxArrayLength;
        this.maxMapLength = maxMapLength;
        this.maxExtLength = maxExtLength;
        this.keyDecoder = keyDecoder;
        this.totalPos = 0;
        this.pos = 0;
        this.view = EMPTY_VIEW;
        this.bytes = EMPTY_BYTES;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack = [];
      }
      reinitializeState() {
        this.totalPos = 0;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack.length = 0;
      }
      setBuffer(buffer) {
        this.bytes = (0, typedArrays_1.ensureUint8Array)(buffer);
        this.view = (0, typedArrays_1.createDataView)(this.bytes);
        this.pos = 0;
      }
      appendBuffer(buffer) {
        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
          this.setBuffer(buffer);
        } else {
          const remainingData = this.bytes.subarray(this.pos);
          const newData = (0, typedArrays_1.ensureUint8Array)(buffer);
          const newBuffer = new Uint8Array(remainingData.length + newData.length);
          newBuffer.set(remainingData);
          newBuffer.set(newData, remainingData.length);
          this.setBuffer(newBuffer);
        }
      }
      hasRemaining(size) {
        return this.view.byteLength - this.pos >= size;
      }
      createExtraByteError(posToShow) {
        const { view, pos } = this;
        return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);
      }
      /**
       * @throws {@link DecodeError}
       * @throws {@link RangeError}
       */
      decode(buffer) {
        this.reinitializeState();
        this.setBuffer(buffer);
        const object = this.doDecodeSync();
        if (this.hasRemaining(1)) {
          throw this.createExtraByteError(this.pos);
        }
        return object;
      }
      *decodeMulti(buffer) {
        this.reinitializeState();
        this.setBuffer(buffer);
        while (this.hasRemaining(1)) {
          yield this.doDecodeSync();
        }
      }
      async decodeAsync(stream) {
        let decoded = false;
        let object;
        for await (const buffer of stream) {
          if (decoded) {
            throw this.createExtraByteError(this.totalPos);
          }
          this.appendBuffer(buffer);
          try {
            object = this.doDecodeSync();
            decoded = true;
          } catch (e) {
            if (!(e instanceof exports.DataViewIndexOutOfBoundsError)) {
              throw e;
            }
          }
          this.totalPos += this.pos;
        }
        if (decoded) {
          if (this.hasRemaining(1)) {
            throw this.createExtraByteError(this.totalPos);
          }
          return object;
        }
        const { headByte, pos, totalPos } = this;
        throw new RangeError(`Insufficient data in parsing ${(0, prettyByte_1.prettyByte)(headByte)} at ${totalPos} (${pos} in the current buffer)`);
      }
      decodeArrayStream(stream) {
        return this.decodeMultiAsync(stream, true);
      }
      decodeStream(stream) {
        return this.decodeMultiAsync(stream, false);
      }
      async *decodeMultiAsync(stream, isArray) {
        let isArrayHeaderRequired = isArray;
        let arrayItemsLeft = -1;
        for await (const buffer of stream) {
          if (isArray && arrayItemsLeft === 0) {
            throw this.createExtraByteError(this.totalPos);
          }
          this.appendBuffer(buffer);
          if (isArrayHeaderRequired) {
            arrayItemsLeft = this.readArraySize();
            isArrayHeaderRequired = false;
            this.complete();
          }
          try {
            while (true) {
              yield this.doDecodeSync();
              if (--arrayItemsLeft === 0) {
                break;
              }
            }
          } catch (e) {
            if (!(e instanceof exports.DataViewIndexOutOfBoundsError)) {
              throw e;
            }
          }
          this.totalPos += this.pos;
        }
      }
      doDecodeSync() {
        DECODE:
          while (true) {
            const headByte = this.readHeadByte();
            let object;
            if (headByte >= 224) {
              object = headByte - 256;
            } else if (headByte < 192) {
              if (headByte < 128) {
                object = headByte;
              } else if (headByte < 144) {
                const size = headByte - 128;
                if (size !== 0) {
                  this.pushMapState(size);
                  this.complete();
                  continue DECODE;
                } else {
                  object = {};
                }
              } else if (headByte < 160) {
                const size = headByte - 144;
                if (size !== 0) {
                  this.pushArrayState(size);
                  this.complete();
                  continue DECODE;
                } else {
                  object = [];
                }
              } else {
                const byteLength = headByte - 160;
                object = this.decodeUtf8String(byteLength, 0);
              }
            } else if (headByte === 192) {
              object = null;
            } else if (headByte === 194) {
              object = false;
            } else if (headByte === 195) {
              object = true;
            } else if (headByte === 202) {
              object = this.readF32();
            } else if (headByte === 203) {
              object = this.readF64();
            } else if (headByte === 204) {
              object = this.readU8();
            } else if (headByte === 205) {
              object = this.readU16();
            } else if (headByte === 206) {
              object = this.readU32();
            } else if (headByte === 207) {
              object = this.readU64();
            } else if (headByte === 208) {
              object = this.readI8();
            } else if (headByte === 209) {
              object = this.readI16();
            } else if (headByte === 210) {
              object = this.readI32();
            } else if (headByte === 211) {
              object = this.readI64();
            } else if (headByte === 217) {
              const byteLength = this.lookU8();
              object = this.decodeUtf8String(byteLength, 1);
            } else if (headByte === 218) {
              const byteLength = this.lookU16();
              object = this.decodeUtf8String(byteLength, 2);
            } else if (headByte === 219) {
              const byteLength = this.lookU32();
              object = this.decodeUtf8String(byteLength, 4);
            } else if (headByte === 220) {
              const size = this.readU16();
              if (size !== 0) {
                this.pushArrayState(size);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else if (headByte === 221) {
              const size = this.readU32();
              if (size !== 0) {
                this.pushArrayState(size);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else if (headByte === 222) {
              const size = this.readU16();
              if (size !== 0) {
                this.pushMapState(size);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte === 223) {
              const size = this.readU32();
              if (size !== 0) {
                this.pushMapState(size);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte === 196) {
              const size = this.lookU8();
              object = this.decodeBinary(size, 1);
            } else if (headByte === 197) {
              const size = this.lookU16();
              object = this.decodeBinary(size, 2);
            } else if (headByte === 198) {
              const size = this.lookU32();
              object = this.decodeBinary(size, 4);
            } else if (headByte === 212) {
              object = this.decodeExtension(1, 0);
            } else if (headByte === 213) {
              object = this.decodeExtension(2, 0);
            } else if (headByte === 214) {
              object = this.decodeExtension(4, 0);
            } else if (headByte === 215) {
              object = this.decodeExtension(8, 0);
            } else if (headByte === 216) {
              object = this.decodeExtension(16, 0);
            } else if (headByte === 199) {
              const size = this.lookU8();
              object = this.decodeExtension(size, 1);
            } else if (headByte === 200) {
              const size = this.lookU16();
              object = this.decodeExtension(size, 2);
            } else if (headByte === 201) {
              const size = this.lookU32();
              object = this.decodeExtension(size, 4);
            } else {
              throw new DecodeError_1.DecodeError(`Unrecognized type byte: ${(0, prettyByte_1.prettyByte)(headByte)}`);
            }
            this.complete();
            const stack = this.stack;
            while (stack.length > 0) {
              const state = stack[stack.length - 1];
              if (state.type === 0) {
                state.array[state.position] = object;
                state.position++;
                if (state.position === state.size) {
                  stack.pop();
                  object = state.array;
                } else {
                  continue DECODE;
                }
              } else if (state.type === 1) {
                if (!isValidMapKeyType(object)) {
                  throw new DecodeError_1.DecodeError("The type of key must be string or number but " + typeof object);
                }
                if (object === "__proto__") {
                  throw new DecodeError_1.DecodeError("The key __proto__ is not allowed");
                }
                state.key = object;
                state.type = 2;
                continue DECODE;
              } else {
                state.map[state.key] = object;
                state.readCount++;
                if (state.readCount === state.size) {
                  stack.pop();
                  object = state.map;
                } else {
                  state.key = null;
                  state.type = 1;
                  continue DECODE;
                }
              }
            }
            return object;
          }
      }
      readHeadByte() {
        if (this.headByte === HEAD_BYTE_REQUIRED) {
          this.headByte = this.readU8();
        }
        return this.headByte;
      }
      complete() {
        this.headByte = HEAD_BYTE_REQUIRED;
      }
      readArraySize() {
        const headByte = this.readHeadByte();
        switch (headByte) {
          case 220:
            return this.readU16();
          case 221:
            return this.readU32();
          default: {
            if (headByte < 160) {
              return headByte - 144;
            } else {
              throw new DecodeError_1.DecodeError(`Unrecognized array type byte: ${(0, prettyByte_1.prettyByte)(headByte)}`);
            }
          }
        }
      }
      pushMapState(size) {
        if (size > this.maxMapLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);
        }
        this.stack.push({
          type: 1,
          size,
          key: null,
          readCount: 0,
          map: {}
        });
      }
      pushArrayState(size) {
        if (size > this.maxArrayLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);
        }
        this.stack.push({
          type: 0,
          size,
          array: new Array(size),
          position: 0
        });
      }
      decodeUtf8String(byteLength, headerOffset) {
        var _a;
        if (byteLength > this.maxStrLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);
        }
        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
          throw MORE_DATA;
        }
        const offset = this.pos + headerOffset;
        let object;
        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {
          object = this.keyDecoder.decode(this.bytes, offset, byteLength);
        } else if (byteLength > utf8_1.TEXT_DECODER_THRESHOLD) {
          object = (0, utf8_1.utf8DecodeTD)(this.bytes, offset, byteLength);
        } else {
          object = (0, utf8_1.utf8DecodeJs)(this.bytes, offset, byteLength);
        }
        this.pos += headerOffset + byteLength;
        return object;
      }
      stateIsMapKey() {
        if (this.stack.length > 0) {
          const state = this.stack[this.stack.length - 1];
          return state.type === 1;
        }
        return false;
      }
      decodeBinary(byteLength, headOffset) {
        if (byteLength > this.maxBinLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);
        }
        if (!this.hasRemaining(byteLength + headOffset)) {
          throw MORE_DATA;
        }
        const offset = this.pos + headOffset;
        const object = this.bytes.subarray(offset, offset + byteLength);
        this.pos += headOffset + byteLength;
        return object;
      }
      decodeExtension(size, headOffset) {
        if (size > this.maxExtLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);
        }
        const extType = this.view.getInt8(this.pos + headOffset);
        const data = this.decodeBinary(
          size,
          headOffset + 1
          /* extType */
        );
        return this.extensionCodec.decode(data, extType, this.context);
      }
      lookU8() {
        return this.view.getUint8(this.pos);
      }
      lookU16() {
        return this.view.getUint16(this.pos);
      }
      lookU32() {
        return this.view.getUint32(this.pos);
      }
      readU8() {
        const value = this.view.getUint8(this.pos);
        this.pos++;
        return value;
      }
      readI8() {
        const value = this.view.getInt8(this.pos);
        this.pos++;
        return value;
      }
      readU16() {
        const value = this.view.getUint16(this.pos);
        this.pos += 2;
        return value;
      }
      readI16() {
        const value = this.view.getInt16(this.pos);
        this.pos += 2;
        return value;
      }
      readU32() {
        const value = this.view.getUint32(this.pos);
        this.pos += 4;
        return value;
      }
      readI32() {
        const value = this.view.getInt32(this.pos);
        this.pos += 4;
        return value;
      }
      readU64() {
        const value = (0, int_1.getUint64)(this.view, this.pos);
        this.pos += 8;
        return value;
      }
      readI64() {
        const value = (0, int_1.getInt64)(this.view, this.pos);
        this.pos += 8;
        return value;
      }
      readF32() {
        const value = this.view.getFloat32(this.pos);
        this.pos += 4;
        return value;
      }
      readF64() {
        const value = this.view.getFloat64(this.pos);
        this.pos += 8;
        return value;
      }
    };
    exports.Decoder = Decoder;
  }
});

// node_modules/@msgpack/msgpack/dist/decode.js
var require_decode2 = __commonJS({
  "node_modules/@msgpack/msgpack/dist/decode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeMulti = exports.decode = exports.defaultDecodeOptions = void 0;
    var Decoder_1 = require_Decoder();
    exports.defaultDecodeOptions = {};
    function decode(buffer, options = exports.defaultDecodeOptions) {
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decode(buffer);
    }
    exports.decode = decode;
    function decodeMulti(buffer, options = exports.defaultDecodeOptions) {
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeMulti(buffer);
    }
    exports.decodeMulti = decodeMulti;
  }
});

// node_modules/@msgpack/msgpack/dist/utils/stream.js
var require_stream2 = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ensureAsyncIterable = exports.asyncIterableFromStream = exports.isAsyncIterable = void 0;
    function isAsyncIterable(object) {
      return object[Symbol.asyncIterator] != null;
    }
    exports.isAsyncIterable = isAsyncIterable;
    function assertNonNull(value) {
      if (value == null) {
        throw new Error("Assertion Failure: value must not be null nor undefined");
      }
    }
    async function* asyncIterableFromStream(stream) {
      const reader = stream.getReader();
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            return;
          }
          assertNonNull(value);
          yield value;
        }
      } finally {
        reader.releaseLock();
      }
    }
    exports.asyncIterableFromStream = asyncIterableFromStream;
    function ensureAsyncIterable(streamLike) {
      if (isAsyncIterable(streamLike)) {
        return streamLike;
      } else {
        return asyncIterableFromStream(streamLike);
      }
    }
    exports.ensureAsyncIterable = ensureAsyncIterable;
  }
});

// node_modules/@msgpack/msgpack/dist/decodeAsync.js
var require_decodeAsync = __commonJS({
  "node_modules/@msgpack/msgpack/dist/decodeAsync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeStream = exports.decodeMultiStream = exports.decodeArrayStream = exports.decodeAsync = void 0;
    var Decoder_1 = require_Decoder();
    var stream_1 = require_stream2();
    var decode_1 = require_decode2();
    async function decodeAsync(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = (0, stream_1.ensureAsyncIterable)(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeAsync(stream);
    }
    exports.decodeAsync = decodeAsync;
    function decodeArrayStream(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = (0, stream_1.ensureAsyncIterable)(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeArrayStream(stream);
    }
    exports.decodeArrayStream = decodeArrayStream;
    function decodeMultiStream(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = (0, stream_1.ensureAsyncIterable)(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeStream(stream);
    }
    exports.decodeMultiStream = decodeMultiStream;
    function decodeStream(streamLike, options = decode_1.defaultDecodeOptions) {
      return decodeMultiStream(streamLike, options);
    }
    exports.decodeStream = decodeStream;
  }
});

// node_modules/@msgpack/msgpack/dist/index.js
var require_dist = __commonJS({
  "node_modules/@msgpack/msgpack/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeTimestampExtension = exports.encodeTimestampExtension = exports.decodeTimestampToTimeSpec = exports.encodeTimeSpecToTimestamp = exports.encodeDateToTimeSpec = exports.EXT_TIMESTAMP = exports.ExtData = exports.ExtensionCodec = exports.Encoder = exports.DataViewIndexOutOfBoundsError = exports.DecodeError = exports.Decoder = exports.decodeStream = exports.decodeMultiStream = exports.decodeArrayStream = exports.decodeAsync = exports.decodeMulti = exports.decode = exports.encode = void 0;
    var encode_1 = require_encode();
    Object.defineProperty(exports, "encode", { enumerable: true, get: function() {
      return encode_1.encode;
    } });
    var decode_1 = require_decode2();
    Object.defineProperty(exports, "decode", { enumerable: true, get: function() {
      return decode_1.decode;
    } });
    Object.defineProperty(exports, "decodeMulti", { enumerable: true, get: function() {
      return decode_1.decodeMulti;
    } });
    var decodeAsync_1 = require_decodeAsync();
    Object.defineProperty(exports, "decodeAsync", { enumerable: true, get: function() {
      return decodeAsync_1.decodeAsync;
    } });
    Object.defineProperty(exports, "decodeArrayStream", { enumerable: true, get: function() {
      return decodeAsync_1.decodeArrayStream;
    } });
    Object.defineProperty(exports, "decodeMultiStream", { enumerable: true, get: function() {
      return decodeAsync_1.decodeMultiStream;
    } });
    Object.defineProperty(exports, "decodeStream", { enumerable: true, get: function() {
      return decodeAsync_1.decodeStream;
    } });
    var Decoder_1 = require_Decoder();
    Object.defineProperty(exports, "Decoder", { enumerable: true, get: function() {
      return Decoder_1.Decoder;
    } });
    Object.defineProperty(exports, "DataViewIndexOutOfBoundsError", { enumerable: true, get: function() {
      return Decoder_1.DataViewIndexOutOfBoundsError;
    } });
    var DecodeError_1 = require_DecodeError();
    Object.defineProperty(exports, "DecodeError", { enumerable: true, get: function() {
      return DecodeError_1.DecodeError;
    } });
    var Encoder_1 = require_Encoder();
    Object.defineProperty(exports, "Encoder", { enumerable: true, get: function() {
      return Encoder_1.Encoder;
    } });
    var ExtensionCodec_1 = require_ExtensionCodec();
    Object.defineProperty(exports, "ExtensionCodec", { enumerable: true, get: function() {
      return ExtensionCodec_1.ExtensionCodec;
    } });
    var ExtData_1 = require_ExtData();
    Object.defineProperty(exports, "ExtData", { enumerable: true, get: function() {
      return ExtData_1.ExtData;
    } });
    var timestamp_1 = require_timestamp();
    Object.defineProperty(exports, "EXT_TIMESTAMP", { enumerable: true, get: function() {
      return timestamp_1.EXT_TIMESTAMP;
    } });
    Object.defineProperty(exports, "encodeDateToTimeSpec", { enumerable: true, get: function() {
      return timestamp_1.encodeDateToTimeSpec;
    } });
    Object.defineProperty(exports, "encodeTimeSpecToTimestamp", { enumerable: true, get: function() {
      return timestamp_1.encodeTimeSpecToTimestamp;
    } });
    Object.defineProperty(exports, "decodeTimestampToTimeSpec", { enumerable: true, get: function() {
      return timestamp_1.decodeTimestampToTimeSpec;
    } });
    Object.defineProperty(exports, "encodeTimestampExtension", { enumerable: true, get: function() {
      return timestamp_1.encodeTimestampExtension;
    } });
    Object.defineProperty(exports, "decodeTimestampExtension", { enumerable: true, get: function() {
      return timestamp_1.decodeTimestampExtension;
    } });
  }
});

// node_modules/obs-websocket-js/dist/msgpack.cjs
var require_msgpack = __commonJS({
  "node_modules/obs-websocket-js/dist/msgpack.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _class;
    var _chunkRL7MGYX4cjs = require_chunk_RL7MGYX4();
    var _msgpack = require_dist();
    var OBSWebSocket2 = (_class = class extends _chunkRL7MGYX4cjs.BaseOBSWebSocket {
      constructor(...args) {
        super(...args);
        _class.prototype.__init.call(this);
      }
      __init() {
        this.protocol = "obswebsocket.msgpack";
      }
      async encodeMessage(data) {
        return _msgpack.encode.call(void 0, data);
      }
      async decodeMessage(data) {
        if (typeof Blob !== "undefined" && data instanceof Blob) {
          data = await data.arrayBuffer();
        }
        return _msgpack.decode.call(void 0, data);
      }
    }, _class);
    var msgpack_default = OBSWebSocket2;
    exports.EventSubscription = _chunkRL7MGYX4cjs.EventSubscription;
    exports.OBSWebSocket = OBSWebSocket2;
    exports.OBSWebSocketError = _chunkRL7MGYX4cjs.OBSWebSocketError;
    exports.RequestBatchExecutionType = _chunkRL7MGYX4cjs.RequestBatchExecutionType;
    exports.WebSocketOpCode = _chunkRL7MGYX4cjs.WebSocketOpCode;
    exports.default = msgpack_default;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => uuhimsyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// settings.ts
var import_obsidian = require("obsidian");
var uuhimsySettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("OBS WebSocket Server").setHeading().setDesc("Set the OBS Websocket Server Settings");
    new import_obsidian.Setting(containerEl).setName("IP").setDesc("Enter the IP address or 'localhost'").addText((item) => {
      item.setValue(this.plugin.settings.websocketIP_Text).onChange(
        (value) => {
          this.plugin.settings.websocketIP_Text = value;
          this.plugin.saveSettings();
          refresh_websocketDetailsJS(this);
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("PORT").addText((item) => {
      item.setValue(this.plugin.settings.websocketPort_Text).onChange(
        (value) => {
          this.plugin.settings.websocketPort_Text = value;
          this.plugin.saveSettings();
          refresh_websocketDetailsJS(this);
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("Password").addText((item) => {
      item.setValue(this.plugin.settings.websocketPW_Text).onChange(
        (value) => {
          this.plugin.settings.websocketPW_Text = value;
          this.plugin.saveSettings();
          refresh_websocketDetailsJS(this);
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("OBS Launch Parameters").setHeading().setDesc("Open OBS with these options.");
    if (process.platform === "darwin") {
      new import_obsidian.Setting(containerEl).setName("Name").setDesc("Enter 'OBS' or a custom name").addText((item) => {
        item.setValue(this.plugin.settings.obsAppName_Text).onChange(
          (value) => {
            this.plugin.settings.obsAppName_Text = value;
            this.plugin.saveSettings();
          }
        );
      });
    }
    if (process.platform === "win32") {
      new import_obsidian.Setting(containerEl).setName("Name").setDesc("Enter 'obs64.exe' or a custom name").addText((item) => {
        item.setValue(this.plugin.settings.obsAppName_Text).onChange(
          (value) => {
            this.plugin.settings.obsAppName_Text = value;
            this.plugin.saveSettings();
          }
        );
      });
      new import_obsidian.Setting(containerEl).setName("Path to OBS app").addText((item) => {
        item.setValue(this.plugin.settings.obsAppPath_Text).onChange(
          (value) => {
            this.plugin.settings.obsAppPath_Text = value;
            this.plugin.saveSettings();
          }
        );
      });
    }
    new import_obsidian.Setting(containerEl).setName("Collection").addText((item) => {
      item.setValue(this.plugin.settings.obsCollection_Text).onChange(
        (value) => {
          this.plugin.settings.obsCollection_Text = value;
          this.plugin.saveSettings();
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("OBS Browser Source Debug Port").setDesc("Enter a Port for the Remote Debugger, or leave blank to skip this option").addText((item) => {
      item.setValue(this.plugin.settings.obsDebugPort_Text).onChange(
        (value) => {
          this.plugin.settings.obsDebugPort_Text = value;
          this.plugin.saveSettings();
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("OSC Server").setHeading();
    new import_obsidian.Setting(containerEl).setName("IP").setDesc("Enter the IP address or 'localhost'").addText((item) => {
      item.setValue(this.plugin.settings.oscIP_Text).onChange(
        (value) => {
          this.plugin.settings.oscIP_Text = value;
          this.plugin.saveSettings();
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("Incoming Message PORT").addText((item) => {
      item.setValue(this.plugin.settings.oscInPort_Text).onChange(
        (value) => {
          this.plugin.settings.oscInPort_Text = value;
          this.plugin.saveSettings();
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("Out going Message PORT").addText((item) => {
      item.setValue(this.plugin.settings.oscOutPort_Text).onChange(
        (value) => {
          this.plugin.settings.oscOutPort_Text = value;
          this.plugin.saveSettings();
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("Add UUhimsy scripts to Slides Extended Template").setHeading().setDesc("UUhimsy scripts will be included when exporting Slides Extended slides").addButton((button) => {
      button.setButtonText("Add UUhimsy scripts to Slides Extended Template").setTooltip("UUhimsy scripts are included when exporting from Slides Extended").setCta().onClick(async () => {
        const fileName = `.obsidian/plugins/slides-extended/template/reveal.html`;
        const existing = await this.app.vault.adapter.exists((0, import_obsidian.normalizePath)(`${fileName}`));
        if (existing) {
          let file = await this.app.vault.adapter.read((0, import_obsidian.normalizePath)(`${fileName}`));
          if (file.includes(`<script src="/_browser_Sources/js/revealSlideControls.js"></script>`)) {
            new import_obsidian.Notice("template already includes uuhimsy scripts");
          } else {
            new import_obsidian.Notice("adding UUhimsy scripts to Slides Extended Template");
            return await this.app.vault.adapter.process((0, import_obsidian.normalizePath)(`${fileName}`), (data) => {
              return data.replace("</body>", `    <script src="/_browser_Sources/obs_webSocket_details/websocketDetails.js"></script>
    <script src="/_browser_Sources/obs_webSocket_details/obs-ws.js"></script>
    <script src="/_browser_Sources/obs_webSocket_details/obsConnect.js"></script>
    <script src="/_browser_Sources/obs_webSocket_details/startConnection.js"></script>
    <script src="/_browser_Sources/js/revealSlideControls.js"></script>
</body>`);
            });
          }
        }
      });
    });
    async function refresh_websocketDetailsJS(obsidian) {
      const fileName = `_browser_Sources/obs_webSocket_details/websocketDetails.js`;
      const existing = await obsidian.app.vault.adapter.exists((0, import_obsidian.normalizePath)(`${fileName}`));
      if (!existing) {
        await obsidian.app.vault.create(
          `${fileName}`,
          `var wssDetails = {
                    "IP":"${obsidian.plugin.settings.websocketIP_Text}",
                    "PORT":"${obsidian.plugin.settings.websocketPort_Text}",
                    "PW":"${obsidian.plugin.settings.websocketPW_Text}"
                };`
        );
      } else {
        await obsidian.app.vault.delete(obsidian.app.vault.getFileByPath(fileName));
        await obsidian.app.vault.create(
          `${fileName}`,
          `var wssDetails = {
    "IP":"${obsidian.plugin.settings.websocketIP_Text}",
    "PORT":"${obsidian.plugin.settings.websocketPort_Text}",
    "PW":"${obsidian.plugin.settings.websocketPW_Text}"
};`
        );
      }
    }
  }
};

// suggest.ts
var import_obsidian2 = require("obsidian");
var UUhimsyEntranceSuggest = class extends import_obsidian2.FuzzySuggestModal {
  getItems() {
    const files = this.app.vault.getFolderByPath("_slide_Tags").children;
    const choices = files;
    return choices;
  }
  getItemText(item) {
    return item.basename;
  }
  async onChooseItem(item, evt) {
    var _a, _b;
    new Notice("Selected " + item.basename);
    const tag = item.basename.toLowerCase().split(" - ");
    (_b = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.editor) == null ? void 0 : _b.replaceSelection(`<!-- slide data-${tag[0]}-entrance="${tag[1]}" -->
`);
  }
};
var UUhimsyExitSuggest = class extends import_obsidian2.FuzzySuggestModal {
  getItems() {
    const files = this.app.vault.getFolderByPath("_slide_Tags").children;
    const choices = files;
    return choices;
  }
  getItemText(item) {
    return item.basename;
  }
  async onChooseItem(item, evt) {
    var _a, _b;
    new Notice("Selected " + item.basename);
    const tag = item.basename.toLowerCase().split(" - ");
    (_b = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.editor) == null ? void 0 : _b.replaceSelection(`<!-- slide data-${tag[0]}-exit="${tag[1]}" -->
`);
  }
};

// view.ts
var import_obsidian3 = require("obsidian");
var UUHIMSY_VIEW_TYPE = "uuhimsy-view";
var UUhimsyView = class extends import_obsidian3.ItemView {
  constructor(leaf) {
    super(leaf);
  }
  getViewType() {
    return UUHIMSY_VIEW_TYPE;
  }
  getDisplayText() {
    return "UUhimsy Tags";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.createEl("h4", { text: "UUhimsy Tags" });
    const files = this.app.vault.getFolderByPath("_slide_Tags").children;
    console.log(files);
    files.forEach((file) => {
      console.log("basename", file.basename);
      console.log("files", files);
      let tag = file.basename.split(" - ");
      tag[0] = tag[0].toLowerCase();
      new import_obsidian3.Setting(container).setName(file.basename).addButton((item) => {
        console.log(item);
        console.log("tag", tag);
        item.setButtonText("Entrance").setCta().onClick(() => {
          var _a, _b;
          const lastLeaf = this.app.workspace.getMostRecentLeaf();
          console.log("ll", lastLeaf);
          const lastLeafWorkspace = this.app.workspace.getLeafById(lastLeaf == null ? void 0 : lastLeaf.id);
          console.log(lastLeafWorkspace);
          this.app.workspace.setActiveLeaf(lastLeafWorkspace, true, true);
          lastLeaf == null ? void 0 : lastLeaf.setEphemeralState(lastLeaf == null ? void 0 : lastLeaf.getEphemeralState());
          (_b = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.editor) == null ? void 0 : _b.replaceSelection(`<!-- slide data-${tag[0]}-entrance="${tag[1]}" -->
`);
          new import_obsidian3.Notice(`Inserted tag${tag[1]}`);
        });
      }).addButton((item) => {
        console.log(file);
        item.setButtonText("Exit").onClick(() => {
          var _a, _b;
          const lastLeaf = this.app.workspace.getMostRecentLeaf();
          const lastLeafWorkspace = this.app.workspace.getLeafById(lastLeaf == null ? void 0 : lastLeaf.id);
          this.app.workspace.setActiveLeaf(lastLeafWorkspace, true, true);
          lastLeaf == null ? void 0 : lastLeaf.setEphemeralState(lastLeaf == null ? void 0 : lastLeaf.getEphemeralState());
          (_b = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.editor) == null ? void 0 : _b.replaceSelection(`<!-- slide data-${tag[0]}-exit="${tag[1]}" -->
    `);
          new import_obsidian3.Notice(`Inserted tag${tag[1]}`);
        });
      });
    });
  }
  async onClose() {
  }
};

// main.ts
var { execSync } = require("child_process");
var { Client, Server, Message } = require_lib2();
var OBSWebSocket = require_msgpack().default;
var DEFAULT_SETTINGS = {
  websocketIP_Text: "localhost",
  websocketPort_Text: "4455",
  websocketPW_Text: "password",
  oscIP_Text: "localhost",
  oscInPort_Text: "4466",
  oscOutPort_Text: "4477",
  obsAppName_Text: "OBS",
  obsAppPath_Text: "C:\\\\Program Files\\\\obs-studio\\\\bin\\\\64bit\\\\",
  obsCollection_Text: "Key_and_Mouse_Visuals_Collection",
  obsDebug_Text: "Y",
  obsDebugPort_Text: "9222"
};
var uuhimsyPlugin = class extends import_obsidian4.Plugin {
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    this.saveData(this.settings);
  }
  async onload() {
    await this.loadSettings();
    this.registerView(UUHIMSY_VIEW_TYPE, (leaf) => new UUhimsyView(leaf));
    this.addRibbonIcon("wand-sparkles", "UUhimsy tags", () => {
      this.openView();
    });
    this.addSettingTab(new uuhimsySettingsTab(this.app, this));
    new import_obsidian4.Notice("Enabled OSC plugin");
    new import_obsidian4.Notice(this.settings.websocketIP_Text);
    new import_obsidian4.Notice(this.app.vault.configDir);
    this.addCommand({
      id: "start-osc-to-websocket",
      name: "Start OSC to OBS Websocket connection",
      callback: () => {
        new import_obsidian4.Notice("Starting OSC Server");
        let websocketIP = this.settings.websocketIP_Text;
        let websocketPort = this.settings.websocketPort_Text;
        let websocketPassword = this.settings.websocketPW_Text;
        let oscIP = this.settings.oscIP_Text;
        let oscInPORT = this.settings.oscInPort_Text;
        let oscOutPORT = this.settings.oscOutPort_Text;
        setOSCconnection(
          websocketIP,
          websocketPort,
          websocketPassword,
          oscIP,
          oscInPORT,
          oscOutPORT
        );
        async function setOSCconnection(websocketIP2, websocketPort2, websocketPassword2, oscIP2, oscInPORT2, oscOutPORT2) {
          const obs = new OBSWebSocket(websocketIP2, websocketPort2, websocketPassword2);
          try {
            const { obsWebSocketVersion, negotiatedRpcVersion } = await obs.connect(
              `ws://${websocketIP2}:${websocketPort2}`,
              websocketPassword2,
              {
                rpcVersion: 1
              }
            );
            new import_obsidian4.Notice(`Connected to server ${obsWebSocketVersion} (using RPC ${negotiatedRpcVersion})`);
            new import_obsidian4.Notice("Connected to OBS WebSocket Server");
            initWebsocketFunctions();
          } catch (error) {
            new import_obsidian4.Notice("Failed to connect to OBS WebSocket Server");
            console.error("Failed to connect", error.code, error.message);
          }
          function initWebsocketFunctions() {
            obs.on("error", (err) => {
              console.error("Socket error:", err);
            });
            console.log(`ws://${websocketIP2}:${websocketPort2}`);
            let oscServer = new Server(oscInPORT2, oscIP2);
            oscServer.on("listening", () => {
              console.log("OSC Server is listening.");
            });
            oscServer.on("message", (msg) => {
              console.log(`Message: ${msg}`);
              sendToOBS(msg, obs, "osc-message");
            });
            function sendToOBS(msgParam, obsParam, eventName) {
              console.log("sending message:", JSON.stringify(msgParam));
              const webSocketMessage = JSON.stringify(msgParam);
              obsParam.call("CallVendorRequest", {
                vendorName: "obs-browser",
                requestType: "emit_event",
                requestData: {
                  event_name: eventName,
                  event_data: { webSocketMessage }
                }
              });
            }
          }
          const oscClient = new Client(oscIP2, oscOutPORT2);
          console.log("oscClient", oscClient, oscIP2, oscOutPORT2, oscInPORT2);
          obs.on("CustomEvent", function(event) {
            console.log("Message from OBS", event);
            if (event.event_name === "OSC-out") {
              const message = new Message(event.address);
              if (Object.hasOwn(event, "arg1")) {
                message.append(event.arg1);
                console.log("arg1", message);
              }
              if (Object.hasOwn(event, "arg2")) {
                message.append(event.arg2);
                console.log(message);
              }
              if (Object.hasOwn(event, "arg3")) {
                message.append(event.arg3);
                console.log(message);
              }
              if (Object.hasOwn(event, "arg4")) {
                message.append(event.arg4);
                console.log(message);
              }
              if (Object.hasOwn(event, "arg5")) {
                message.append(event.arg5);
                console.log(message);
              }
              if (Object.hasOwn(event, "arg6")) {
                message.append(event.arg6);
                console.log(message);
              }
              if (Object.hasOwn(event, "arg7")) {
                message.append(event.arg7);
                console.log(message);
              }
              console.log("message to OSC device", message);
              oscClient.send(message, (err) => {
                if (err) {
                  console.error(new Error(err));
                }
              });
            }
          });
        }
      }
    });
    this.addCommand({
      id: "get-obs-scene-tags",
      name: "Get OBS tags",
      callback: async () => {
        new import_obsidian4.Notice("Getting OBS Tags");
        let websocketIP = this.settings.websocketIP_Text;
        let websocketPort = this.settings.websocketPort_Text;
        let websocketPassword = this.settings.websocketPW_Text;
        const obs = new OBSWebSocket(websocketIP, websocketPort, websocketPassword);
        try {
          const { obsWebSocketVersion, negotiatedRpcVersion } = await obs.connect(
            `ws://${websocketIP}:${websocketPort}`,
            websocketPassword,
            {
              rpcVersion: 1
            }
          );
          console.log(
            `Connected to server ${obsWebSocketVersion} (using RPC ${negotiatedRpcVersion})`
          );
          new import_obsidian4.Notice("Connected to OBS WebSocket Server");
        } catch (error) {
          new import_obsidian4.Notice("Failed to connect to OBS WebSocket Server");
          console.error("Failed to connect", error.code, error.message);
        }
        obs.on("error", (err) => {
          console.error("Socket error:", err);
        });
        console.log(`ws://${websocketIP}:${websocketPort}`);
        const sceneList = await obs.call("GetSceneList");
        console.log(sceneList);
        sceneList.scenes.forEach(async (scene, index) => {
          if (scene.sceneName.startsWith("scene|||")) {
            const sceneName = scene.sceneName.split("|||");
            let fileName = `Scene - ${sceneName[1]}`;
            let existing = await this.app.vault.adapter.exists((0, import_obsidian4.normalizePath)(`_slide_Tags/${fileName}`));
            if (!existing) {
              await this.app.vault.create(
                `_slide_Tags/${fileName}.md`,
                ``
              );
            }
          }
        });
        let cameraSources = await obs.call("GetSceneItemList", { sceneName: "Input Camera" });
        cameraSources.sceneItems.forEach(async (source, index) => {
          let fileName = `Camera - ${source.sourceName}`;
          let existing = await this.app.vault.adapter.exists((0, import_obsidian4.normalizePath)(`_slide_Tags/${fileName}`));
          if (!existing) {
            await this.app.vault.create(
              `_slide_Tags/${fileName}.md`,
              ``
            );
          }
        });
        obs.disconnect();
      }
    });
    this.addCommand({
      id: "insert-entrance-tag",
      name: "Insert slide entrance tag",
      editorCallback: (editor, view) => {
        new UUhimsyEntranceSuggest(this.app).open();
      }
    });
    this.addCommand({
      id: "insert-exit-tag",
      name: "Insert slide exit tag",
      editorCallback: (editor, view) => {
        new UUhimsyExitSuggest(this.app).open();
      }
    });
    this.addCommand({
      id: "send-camera-position-to-obs",
      name: "Start sending camera PTZ position to OBS",
      checkCallback: async (checking) => {
        let isMac = process.platform === "darwin";
        if (isMac) {
          if (!checking) {
            console.log("true");
            let websocketIP = this.settings.websocketIP_Text;
            let websocketPort = this.settings.websocketPort_Text;
            let websocketPassword = this.settings.websocketPW_Text;
            const obs = new OBSWebSocket(websocketIP, websocketPort, websocketPassword);
            try {
              const { obsWebSocketVersion, negotiatedRpcVersion } = await obs.connect(
                `ws://${websocketIP}:${websocketPort}`,
                websocketPassword,
                {
                  rpcVersion: 1
                }
              );
              console.log(
                `Connected to server ${obsWebSocketVersion} (using RPC ${negotiatedRpcVersion})`
              );
              new import_obsidian4.Notice("Connected to OBS WebSocket Server");
            } catch (error) {
              new import_obsidian4.Notice("Failed to connect to OBS WebSocket Server");
              console.error("Failed to connect", error.code, error.message);
            }
            obs.on("error", (err) => {
              console.error("Socket error:", err);
            });
            console.log(`ws://${websocketIP}:${websocketPort}`);
            const vaultPath = (0, import_obsidian4.normalizePath)(`${this.app.vault.adapter.basePath}/${this.app.vault.configDir}/plugins/UUhimsyPlugin`);
            const util = require("util");
            const exec = util.promisify(require("child_process").exec);
            let previousPTZ = "";
            setInterval(async () => {
              let pt = await getCameraPanTilt(vaultPath, util, exec);
              let z = await getCameraZoom(vaultPath, util, exec);
              let ptzMessage = `${pt}${z}}`;
              if (ptzMessage != previousPTZ) {
                previousPTZ = ptzMessage;
                await obs.call("SetInputSettings", {
                  inputName: "PTZ values",
                  inputSettings: {
                    text: `${ptzMessage}`
                  }
                });
                obs.call("CallVendorRequest", {
                  vendorName: "obs-browser",
                  requestType: "emit_event",
                  requestData: {
                    event_name: "ptz-message",
                    event_data: { ptzMessage }
                  }
                });
              }
            }, 2e3);
            async function getCameraPanTilt(vaultPath2, util2, exec2) {
              try {
                console.log(vaultPath2);
                const { stdout, stderr } = await exec2(`'${vaultPath2}/uvc-util' -I 0 -o pan-tilt-abs`);
                let ptResult = stdout.toString();
                ptResult = ptResult.replace(/\n/g, "").replace("pan", '"pan"').replace("}", ', "zoom": ').replace(/=/g, ": ").replace("tilt", '"tilt"');
                return ptResult;
              } catch (e) {
                console.error(e);
              }
            }
            async function getCameraZoom(vaultPath2, util2, exec2) {
              try {
                const { stdout, stderr } = await exec2(`'${vaultPath2}/uvc-util' -I 0 -o zoom-abs`);
                return stdout.replace(/\n/g, "");
              } catch (e) {
                console.error(e);
              }
            }
            obs.on("CustomEvent", async function(event) {
              console.log("Message from OBS", event);
              if (event.event_name === "set-ptz") {
                console.log("command", `'shortcuts' run ${event.shortcut_name}`);
                const stdout = await exec(`'${vaultPath}/uvc-util' -I 0 -o pan-tilt-abs`);
                console.log(stdout);
              }
            });
          }
          return true;
        }
        return false;
      }
      //end get PTZ command	
    });
    this.addCommand({
      id: "stop-camera-position-to-obs",
      name: "Stop sending camera PTZ position to OBS",
      callback: () => {
        let highestTimeoutId = setTimeout(";");
        for (let i = 0; i < highestTimeoutId; i++) {
          clearTimeout(i);
        }
      }
    });
    this.addCommand({
      id: "get-shortcuts-tags",
      name: "Get Apple Shortcuts tags",
      checkCallback: async (checking) => {
        let isMac = process.platform === "darwin";
        if (isMac) {
          if (!checking) {
            const util = require("util");
            const exec = util.promisify(require("child_process").exec);
            const { stdout, stderr } = await exec(`'shortcuts' list`);
            let shortcuts = stdout.split("\n");
            shortcuts = shortcuts.filter((shortcut) => {
              return shortcut.toLowerCase().startsWith("uuhimsy");
            });
            console.log(shortcuts);
            console.log(typeof shortcuts);
            const shortcutCount = Object.keys(shortcuts).length;
            Object.entries(shortcuts).forEach(async ([key, shortcut]) => {
              console.log(key, shortcut, shortcutCount);
              let fileName = `Shortcuts - ${shortcut}.md`;
              let existing = await this.app.vault.adapter.exists((0, import_obsidian4.normalizePath)(`_slide_Tags/${fileName}`));
              if (!existing) {
                await this.app.vault.create(
                  `_slide_Tags/${fileName}`,
                  ``
                );
              }
              if (Number(key) == shortcutCount - 1) {
                this.openView();
              }
            });
          }
          ;
        }
      }
    });
    this.addCommand({
      id: "run-apple-shortcut",
      name: "Start Apple Shortcut Connection",
      callback: async () => {
        let websocketIP = this.settings.websocketIP_Text;
        let websocketPort = this.settings.websocketPort_Text;
        let websocketPassword = this.settings.websocketPW_Text;
        const obs = new OBSWebSocket(websocketIP, websocketPort, websocketPassword);
        try {
          const { obsWebSocketVersion, negotiatedRpcVersion } = await obs.connect(
            `ws://${websocketIP}:${websocketPort}`,
            websocketPassword,
            {
              rpcVersion: 1
            }
          );
          console.log(
            `Connected to server ${obsWebSocketVersion} (using RPC ${negotiatedRpcVersion})`
          );
          new import_obsidian4.Notice("Connected to OBS WebSocket Server");
        } catch (error) {
          new import_obsidian4.Notice("Failed to connect to OBS WebSocket Server");
          console.error("Failed to connect", error.code, error.message);
        }
        obs.on("error", (err) => {
          console.error("Socket error:", err);
        });
        console.log(`ws://${websocketIP}:${websocketPort}`);
        obs.on("CustomEvent", async function(event) {
          if (event.event_name === "run-shortcut") {
            console.log("message from OBS", event);
            console.log(JSON.stringify(event.event_data));
            await obs.call("SetInputSettings", {
              inputName: "CommandText",
              inputSettings: {
                text: `${event.event_name} ${event.event_data.shortcut_name}`
              }
            });
            console.log("command", `'shortcuts' run ${event.event_data.shortcut_name}`);
            console.log("prop check", Object.hasOwn(event.event_data, "shortcut_input"));
            let stdout;
            if (Object.hasOwn(event.event_data, "shortcut_input")) {
              console.log("running with input");
              stdout = execSync(`'shortcuts' run '${event.event_data.shortcut_name}' <<< '${event.event_data.shortcut_input}'`, { encoding: "utf8" });
            } else {
              console.log("running with OUT input");
              stdout = execSync(`'shortcuts' run '${event.event_data.shortcut_name}'`, { encoding: "utf8" });
            }
            console.log("shortcut result ", stdout);
            await obs.call("SetInputSettings", {
              inputName: "CommandResultsText",
              inputSettings: {
                text: `${stdout}`
              }
            });
          }
        });
      }
    });
    this.addCommand(
      {
        id: "open-obs",
        name: "Open OBS",
        callback: async () => {
          const util = require("util");
          const exec = util.promisify(require("child_process").exec);
          let commandString = "hello";
          if (process.platform === "darwin") {
            commandString = `open -n -a "${this.settings.obsAppName_Text}"`;
            commandString += ` --args --collection "${this.settings.obsCollection_Text}"`;
            commandString += ` --remote-debugging-port=${this.settings.obsDebugPort_Text}`;
            commandString += ` --remote-allow-origins=http://localhost:${this.settings.obsDebugPort_Text}`;
            commandString += ` --websocket_port "${this.settings.websocketPort_Text}"`;
            commandString += ` --websocket_password "${this.settings.websocketPW_Text}"`;
            commandString += ` --multi`;
            exec(commandString);
          }
          if (process.platform === "win32") {
            const path = require("path");
            const obsPath = `${this.settings.obsAppPath_Text}${this.settings.obsAppName_Text}`;
            const obsDir = path.dirname(obsPath);
            process.chdir(obsDir);
            commandString = `${this.settings.obsAppName_Text}`;
            commandString += ` --args --collection "${this.settings.obsCollection_Text}"`;
            commandString += ` --remote-debugging-port=${this.settings.obsDebugPort_Text}`;
            commandString += ` --remote-allow-origins=http://localhost:${this.settings.obsDebugPort_Text}`;
            commandString += ` --websocket_port "${this.settings.websocketPort_Text}"`;
            commandString += ` --websocket_password "${this.settings.websocketPW_Text}"`;
            commandString += ` --multi`;
            exec(commandString, (error, stdout, stderr) => {
              if (error) {
                console.error(`exec error: ${error}`);
                return;
              }
              console.log(`stdout: ${stdout}`);
              console.error(`stderr: ${stderr}`);
            });
          }
          console.log(commandString);
        }
      }
    );
    this.addCommand({
      id: "connect-to-obs",
      name: "Start OBS Connection",
      callback: async () => {
        let websocketIP = this.settings.websocketIP_Text;
        let websocketPort = this.settings.websocketPort_Text;
        let websocketPassword = this.settings.websocketPW_Text;
        const obs = new OBSWebSocket(websocketIP, websocketPort, websocketPassword);
        try {
          const { obsWebSocketVersion, negotiatedRpcVersion } = await obs.connect(
            `ws://${websocketIP}:${websocketPort}`,
            websocketPassword,
            {
              rpcVersion: 1
            }
          );
          console.log(
            `Connected to server ${obsWebSocketVersion} (using RPC ${negotiatedRpcVersion})`
          );
          new import_obsidian4.Notice("Connected to OBS WebSocket Server");
        } catch (error) {
          new import_obsidian4.Notice("Failed to connect to OBS WebSocket Server");
          console.error("Failed to connect", error.code, error.message);
        }
        obs.on("error", (err) => {
          console.error("Socket error:", err);
        });
        console.log(`ws://${websocketIP}:${websocketPort}`);
        obs.on("CustomEvent", async function(event) {
          var _a, _b;
          if (event.event_name === "add-obsidian-tag") {
            console.log("tag message from OBS", event);
            const tag = JSON.parse(event.event_data.tag);
            (_b = (_a = app.workspace.activeEditor) == null ? void 0 : _a.editor) == null ? void 0 : _b.replaceSelection(tag);
          }
          if (event.event_name === "open-gum-page") {
            console.log("open gum message from OBS", event);
            console.log("open gum message from OBS", this);
            const port = app.plugins.plugins["slides-extended"].port;
            window.open(`http://localhost:${port}/_GUM`);
          }
        });
      }
    });
  }
  async openView() {
    const { workspace } = this.app;
    this.app.workspace.detachLeavesOfType(UUHIMSY_VIEW_TYPE);
    let leaf = null;
    const leaves = workspace.getLeavesOfType(UUHIMSY_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await leaf.setViewState({ type: UUHIMSY_VIEW_TYPE, active: true });
    }
    workspace.revealLeaf(leaf);
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(UUHIMSY_VIEW_TYPE);
    new import_obsidian4.Notice("Disabled UUhimsy plugin");
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL25vZGUtb3NjL2Rpc3QvbGliL01lc3NhZ2UuanMiLCAibm9kZV9tb2R1bGVzL25vZGUtb3NjL2Rpc3QvbGliL0J1bmRsZS5qcyIsICJub2RlX21vZHVsZXMvYmlucGFjay9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvb3NjLW1pbi9saWIvb3NjLXV0aWxpdGllcy5qcyIsICJub2RlX21vZHVsZXMvb3NjLW1pbi9saWIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL25vZGUtb3NjL2Rpc3QvbGliL2ludGVybmFsL2RlY29kZS5qcyIsICJub2RlX21vZHVsZXMvbm9kZS1vc2MvZGlzdC9saWIvU2VydmVyLmpzIiwgIm5vZGVfbW9kdWxlcy9ub2RlLW9zYy9kaXN0L2xpYi9DbGllbnQuanMiLCAibm9kZV9tb2R1bGVzL25vZGUtb3NjL2Rpc3QvbGliL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsICJub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCAibm9kZV9tb2R1bGVzL2hhcy1mbGFnL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9zdXBwb3J0cy1jb2xvci9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanMiLCAibm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL2NvbnN0YW50cy5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL2J1ZmZlci11dGlsLmpzIiwgIm5vZGVfbW9kdWxlcy93cy9saWIvbGltaXRlci5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL3ZhbGlkYXRpb24uanMiLCAibm9kZV9tb2R1bGVzL3dzL2xpYi9yZWNlaXZlci5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL3NlbmRlci5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL2V2ZW50LXRhcmdldC5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL2V4dGVuc2lvbi5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL3N0cmVhbS5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL3N1YnByb3RvY29sLmpzIiwgIm5vZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LXNlcnZlci5qcyIsICJub2RlX21vZHVsZXMvd3MvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2lzb21vcnBoaWMtd3Mvbm9kZS5qcyIsICJub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanMiLCAibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEyNTYuanMiLCAibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtYmFzZTY0LmpzIiwgIm5vZGVfbW9kdWxlcy9vYnMtd2Vic29ja2V0LWpzL2Rpc3QvZDovcHJvamVjdHMvb2JzLXdlYnNvY2tldC1qcy9kaXN0L2NodW5rLVJMN01HWVg0LmNqcyIsICJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9zcmMvdXRpbHMvaW50LnRzIiwgIm5vZGVfbW9kdWxlcy9AbXNncGFjay9tc2dwYWNrL3NyYy91dGlscy91dGY4LnRzIiwgIm5vZGVfbW9kdWxlcy9AbXNncGFjay9tc2dwYWNrL3NyYy9FeHREYXRhLnRzIiwgIm5vZGVfbW9kdWxlcy9AbXNncGFjay9tc2dwYWNrL3NyYy9EZWNvZGVFcnJvci50cyIsICJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9zcmMvdGltZXN0YW1wLnRzIiwgIm5vZGVfbW9kdWxlcy9AbXNncGFjay9tc2dwYWNrL3NyYy9FeHRlbnNpb25Db2RlYy50cyIsICJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9zcmMvdXRpbHMvdHlwZWRBcnJheXMudHMiLCAibm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svc3JjL0VuY29kZXIudHMiLCAibm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svc3JjL2VuY29kZS50cyIsICJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9zcmMvdXRpbHMvcHJldHR5Qnl0ZS50cyIsICJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9zcmMvQ2FjaGVkS2V5RGVjb2Rlci50cyIsICJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9zcmMvRGVjb2Rlci50cyIsICJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9zcmMvZGVjb2RlLnRzIiwgIm5vZGVfbW9kdWxlcy9AbXNncGFjay9tc2dwYWNrL3NyYy91dGlscy9zdHJlYW0udHMiLCAibm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svc3JjL2RlY29kZUFzeW5jLnRzIiwgIm5vZGVfbW9kdWxlcy9AbXNncGFjay9tc2dwYWNrL3NyYy9pbmRleC50cyIsICJub2RlX21vZHVsZXMvb2JzLXdlYnNvY2tldC1qcy9kaXN0L2Q6L3Byb2plY3RzL29icy13ZWJzb2NrZXQtanMvZGlzdC9tc2dwYWNrLmNqcyIsICJtYWluLnRzIiwgInNldHRpbmdzLnRzIiwgInN1Z2dlc3QudHMiLCAidmlldy50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB0eXBlVGFncyA9IHtcbiAgczogJ3N0cmluZycsXG4gIGY6ICdmbG9hdCcsXG4gIGk6ICdpbnRlZ2VyJyxcbiAgYjogJ2Jsb2InXG59O1xuXG5jbGFzcyBBcmd1bWVudCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIHZhbHVlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbn1cblxuY2xhc3MgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGFkZHJlc3MsIC4uLmFyZ3MpIHtcbiAgICB0aGlzLm9zY1R5cGUgPSAnbWVzc2FnZSc7XG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICB9XG4gIFxuICBhcHBlbmQoYXJnKSB7XG4gICAgbGV0IGFyZ091dDtcbiAgICBzd2l0Y2ggKHR5cGVvZiBhcmcpIHtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGFyZy5mb3JFYWNoKGEgPT4gdGhpcy5hcHBlbmQoYSkpO1xuICAgICAgfSBlbHNlIGlmIChhcmcudHlwZSkge1xuICAgICAgICBpZiAodHlwZVRhZ3NbYXJnLnR5cGVdKSBhcmcudHlwZSA9IHR5cGVUYWdzW2FyZy50eXBlXTtcbiAgICAgICAgdGhpcy5hcmdzLnB1c2goYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZG9uJ3Qga25vdyBob3cgdG8gZW5jb2RlIG9iamVjdCAke2FyZ31gKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBpZiAoTWF0aC5mbG9vcihhcmcpID09PSBhcmcpIHtcbiAgICAgICAgYXJnT3V0ID0gbmV3IEFyZ3VtZW50KCdpbnRlZ2VyJywgYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ091dCA9IG5ldyBBcmd1bWVudCgnZmxvYXQnLCBhcmcpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGFyZ091dCA9IG5ldyBBcmd1bWVudCgnc3RyaW5nJywgYXJnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgYXJnT3V0ID0gbmV3IEFyZ3VtZW50KCdib29sZWFuJywgYXJnKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGRvbid0IGtub3cgaG93IHRvIGVuY29kZSAke2FyZ31gKTtcbiAgICB9XG4gICAgaWYgKGFyZ091dCkgdGhpcy5hcmdzLnB1c2goYXJnT3V0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2U7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTWVzc2FnZSA9IHJlcXVpcmUoJy4vTWVzc2FnZS5qcycpO1xuXG5mdW5jdGlvbiBzYW5pdGl6ZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQXJyYXkpIGVsZW1lbnQgPSBuZXcgTWVzc2FnZShlbGVtZW50WzBdLCAuLi5lbGVtZW50LnNsaWNlKDEpKTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmNsYXNzIEJ1bmRsZSB7XG4gIGNvbnN0cnVjdG9yKHRpbWV0YWcsIC4uLmVsZW1lbnRzKSB7XG4gICAgaWYgKCEodHlwZW9mIHRpbWV0YWcgPT09ICdudW1iZXInKSkge1xuICAgICAgZWxlbWVudHMudW5zaGlmdCh0aW1ldGFnKTtcbiAgICAgIHRpbWV0YWcgPSAwO1xuICAgIH1cbiAgICB0aGlzLnRpbWV0YWcgPSB0aW1ldGFnO1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cy5tYXAoc2FuaXRpemUpO1xuICB9XG5cbiAgYXBwZW5kKGVsZW1lbnQpIHtcbiAgICB0aGlzLmVsZW1lbnRzLnB1c2goc2FuaXRpemUoZWxlbWVudCkpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQnVuZGxlO1xuIiwgIi8vIHQgaXMgYSBiaW5wYWNrIHR5cGVuYW1lXG52YXIgc2l6ZU9mVHlwZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAvLyB1bnNpZ25lZCBhcmUgdGhlIHNhbWUgbGVuZ3RoIGFzIHNpZ25lZFxuICAgIGlmKHRbMF0gPT09ICdVJykge1xuICAgICAgICB0ID0gdC5zbGljZSgxKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAnRmxvYXQzMicgOiA0LFxuICAgICAgICAnRmxvYXQ2NCcgOiA4LFxuICAgICAgICAnSW50OCcgOiAxLFxuICAgICAgICAnSW50MTYnIDogMixcbiAgICAgICAgJ0ludDMyJyA6IDQsXG4gICAgICAgICdJbnQ2NCcgOiA4XG4gICAgfVt0XTtcbn07XG5cbnZhciBlbmRpYW5Db252ID0gZnVuY3Rpb24oZSwgdCkge1xuICAgIC8vIG5vZGUgZG9lc24ndCBkZWZpbmUgOCBiaXQgZW5kaWFubmVzc1xuICAgIGlmKHRbdC5sZW5ndGggLSAxXSA9PT0gJzgnKVxuICAgICAgICByZXR1cm4gJyc7XG5cbiAgICBpZihlID09PSAnYmlnJykge1xuICAgICAgICByZXR1cm4gJ0JFJztcbiAgICB9XG4gICAgcmV0dXJuICdMRSc7XG59O1xuXG52YXIgYWRkQmluZGluZ3MgPSBmdW5jdGlvbihiaW5wYWNrVHlwZW5hbWUsIG5vZGVUeXBlbmFtZSl7XG4gICAgaWYoISh0eXBlb2Ygbm9kZVR5cGVuYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIG5vZGVUeXBlbmFtZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgbm9kZVR5cGVuYW1lID0gYmlucGFja1R5cGVuYW1lO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0c1sncGFjaycgKyBiaW5wYWNrVHlwZW5hbWVdID0gZnVuY3Rpb24obnVtLCBlbmRpYW4pe1xuICAgICAgICBiID0gbmV3IEJ1ZmZlcihzaXplT2ZUeXBlKGJpbnBhY2tUeXBlbmFtZSkpO1xuICAgICAgICBiWyd3cml0ZScgKyBub2RlVHlwZW5hbWUgKyBlbmRpYW5Db252KGVuZGlhbiwgYmlucGFja1R5cGVuYW1lKV0obnVtLCAwLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHNbJ3VucGFjaycgKyBiaW5wYWNrVHlwZW5hbWVdID0gZnVuY3Rpb24oYnVmZiwgZW5kaWFuKXtcbiAgICAgICAgcmV0dXJuIGJ1ZmZbJ3JlYWQnICsgbm9kZVR5cGVuYW1lICsgZW5kaWFuQ29udihlbmRpYW4sIGJpbnBhY2tUeXBlbmFtZSldKDApO1xuICAgIH1cbn1cblxudmFyIGFkZEludEJpbmRpbmdzID0gZnVuY3Rpb24obikge1xuICAgIGFkZEJpbmRpbmdzKFwiSW50XCIgKyBuKTtcbiAgICBhZGRCaW5kaW5ncyhcIlVJbnRcIiArIG4pO1xufVxuXG5hZGRJbnRCaW5kaW5ncyg4KTtcbmFkZEludEJpbmRpbmdzKDE2KTtcbmFkZEludEJpbmRpbmdzKDMyKTtcblxudHdvVG9UaGUzMiA9IE1hdGgucG93KDIsIDMyKTtcblxuLy8gNjQgYml0IGJpbmRpbmdzIHJlcXVpcmUgc3BlY2lhbCBjYXJlXG52YXIgcmVhZDY0ID0gZnVuY3Rpb24odW5zaWduZWQpe3JldHVybiBmdW5jdGlvbihidWZmLCBlbmRpYW4pe1xuICAgIHZhciBlID0gZW5kaWFuQ29udihlbmRpYW4sICcnKTtcbiAgICB2YXIgdSA9IHVuc2lnbmVkID8gJ1UnIDogJyc7XG4gICAgdmFyIGxvdywgaGlnaDtcbiAgICBpZihlID09PSAnTEUnKSB7XG4gICAgICAgIGxvdyA9IGJ1ZmYucmVhZFVJbnQzMkxFKDApO1xuICAgICAgICBoaWdoID0gYnVmZlsncmVhZCcgKyB1ICsgJ0ludDMyTEUnXSg0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsb3cgPSBidWZmLnJlYWRVSW50MzJCRSg0KTtcbiAgICAgICAgaGlnaCA9IGJ1ZmZbJ3JlYWQnICsgdSArICdJbnQzMkJFJ10oMCk7XG4gICAgfVxuICAgIHJldHVybiBoaWdoICogdHdvVG9UaGUzMiArIGxvdztcbn07fTtcblxudmFyIHdyaXRlNjQgPSBmdW5jdGlvbih1bnNpZ25lZCl7cmV0dXJuIGZ1bmN0aW9uKG51bSwgZW5kaWFuKXtcbiAgICB2YXIgZSA9IGVuZGlhbkNvbnYoZW5kaWFuLCAnJyk7XG4gICAgdmFyIHUgPSB1bnNpZ25lZCA/ICdVJyA6ICcnO1xuICAgIHZhciBiID0gbmV3IEJ1ZmZlcig4KTtcbiAgICB2YXIgaGlnaCA9IE1hdGguZmxvb3IobnVtIC8gdHdvVG9UaGUzMik7XG4gICAgdmFyIGxvdyA9IE1hdGguZmxvb3IobnVtIC0gaGlnaCAqIHR3b1RvVGhlMzIpO1xuICAgIGlmKGUgPT0gJ0xFJykge1xuICAgICAgICBiLndyaXRlVUludDMyTEUobG93LCAwLCB0cnVlKTtcbiAgICAgICAgYlsnd3JpdGUnICsgdSArICdJbnQzMkxFJ10oaGlnaCwgNCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYi53cml0ZVVJbnQzMkJFKGxvdywgNCwgdHJ1ZSk7XG4gICAgICAgIGJbJ3dyaXRlJyArIHUgKyAnSW50MzJCRSddKGhpZ2gsIDAsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gYjtcbn07fTtcblxubW9kdWxlLmV4cG9ydHMudW5wYWNrSW50NjQgPSByZWFkNjQoZmFsc2UpO1xubW9kdWxlLmV4cG9ydHMudW5wYWNrVUludDY0ID0gcmVhZDY0KHRydWUpO1xubW9kdWxlLmV4cG9ydHMucGFja0ludDY0ID0gd3JpdGU2NChmYWxzZSk7XG5tb2R1bGUuZXhwb3J0cy5wYWNrVUludDY0ID0gd3JpdGU2NCh0cnVlKTtcblxuYWRkQmluZGluZ3MoXCJGbG9hdDMyXCIsIFwiRmxvYXRcIik7XG5hZGRCaW5kaW5ncyhcIkZsb2F0NjRcIiwgXCJEb3VibGVcIik7XG4iLCAiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIElzQXJyYXksIFN0cmljdEVycm9yLCBUV09fUE9XXzMyLCBVTklYX0VQT0NILCBiaW5wYWNrLCBnZXRBcnJheUFyZywgaXNPc2NCdW5kbGVCdWZmZXIsIG1ha2VUaW1ldGFnLCBtYXBCdW5kbGVMaXN0LCBvc2NUeXBlQ29kZXMsIHBhZGRpbmcsIHRvT3NjVHlwZUFuZEFyZ3MsXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIGJpbnBhY2sgPSByZXF1aXJlKFwiYmlucGFja1wiKTtcblxuICBleHBvcnRzLmNvbmNhdCA9IGZ1bmN0aW9uKGJ1ZmZlcnMpIHtcbiAgICB2YXIgYnVmZmVyLCBjb3B5VG8sIGRlc3RCdWZmZXIsIGosIGssIGwsIGxlbiwgbGVuMSwgbGVuMiwgc3VtTGVuZ3RoO1xuICAgIGlmICghSXNBcnJheShidWZmZXJzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uY2F0IG11c3QgdGFrZSBhbiBhcnJheSBvZiBidWZmZXJzXCIpO1xuICAgIH1cbiAgICBmb3IgKGogPSAwLCBsZW4gPSBidWZmZXJzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBidWZmZXIgPSBidWZmZXJzW2pdO1xuICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25jYXQgbXVzdCB0YWtlIGFuIGFycmF5IG9mIGJ1ZmZlcnNcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHN1bUxlbmd0aCA9IDA7XG4gICAgZm9yIChrID0gMCwgbGVuMSA9IGJ1ZmZlcnMubGVuZ3RoOyBrIDwgbGVuMTsgaysrKSB7XG4gICAgICBidWZmZXIgPSBidWZmZXJzW2tdO1xuICAgICAgc3VtTGVuZ3RoICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIGRlc3RCdWZmZXIgPSBuZXcgQnVmZmVyKHN1bUxlbmd0aCk7XG4gICAgY29weVRvID0gMDtcbiAgICBmb3IgKGwgPSAwLCBsZW4yID0gYnVmZmVycy5sZW5ndGg7IGwgPCBsZW4yOyBsKyspIHtcbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlcnNbbF07XG4gICAgICBidWZmZXIuY29weShkZXN0QnVmZmVyLCBjb3B5VG8pO1xuICAgICAgY29weVRvICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBkZXN0QnVmZmVyO1xuICB9O1xuXG4gIGV4cG9ydHMudG9Pc2NTdHJpbmcgPSBmdW5jdGlvbihzdHIsIHN0cmljdCkge1xuICAgIHZhciBpLCBqLCBudWxsSW5kZXgsIHJlZjtcbiAgICBpZiAoISh0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuJ3QgcGFjayBhIG5vbi1zdHJpbmcgaW50byBhbiBvc2Mtc3RyaW5nXCIpO1xuICAgIH1cbiAgICBudWxsSW5kZXggPSBzdHIuaW5kZXhPZihcIlxcdTAwMDBcIik7XG4gICAgaWYgKG51bGxJbmRleCAhPT0gLTEgJiYgc3RyaWN0KSB7XG4gICAgICB0aHJvdyBTdHJpY3RFcnJvcihcIkNhbid0IHBhY2sgYW4gb3NjLXN0cmluZyB0aGF0IGNvbnRhaW5zIE5VTEwgY2hhcmFjdGVyc1wiKTtcbiAgICB9XG4gICAgaWYgKG51bGxJbmRleCAhPT0gLTEpIHtcbiAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBudWxsSW5kZXgpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gcGFkZGluZyhzdHIpOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgIHN0ciArPSBcIlxcdTAwMDBcIjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3RyKTtcbiAgfTtcblxuICBleHBvcnRzLnNwbGl0T3NjU3RyaW5nID0gZnVuY3Rpb24oYnVmZmVyLCBzdHJpY3QpIHtcbiAgICB2YXIgaSwgaiwgbnVsbEluZGV4LCByYXdTdHIsIHJlZiwgcmVmMSwgcmVzdCwgc3BsaXRQb2ludCwgc3RyO1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICAgIHRocm93IFN0cmljdEVycm9yKFwiQ2FuJ3Qgc3BsaXQgc29tZXRoaW5nIHRoYXQgaXNuJ3QgYSBidWZmZXJcIik7XG4gICAgfVxuICAgIHJhd1N0ciA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIik7XG4gICAgbnVsbEluZGV4ID0gcmF3U3RyLmluZGV4T2YoXCJcXHUwMDAwXCIpO1xuICAgIGlmIChudWxsSW5kZXggPT09IC0xKSB7XG4gICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFsbCBvc2Mtc3RyaW5ncyBtdXN0IGNvbnRhaW4gYSBudWxsIGNoYXJhY3RlclwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmluZzogcmF3U3RyLFxuICAgICAgICByZXN0OiBuZXcgQnVmZmVyKDApXG4gICAgICB9O1xuICAgIH1cbiAgICBzdHIgPSByYXdTdHIuc2xpY2UoMCwgbnVsbEluZGV4KTtcbiAgICBzcGxpdFBvaW50ID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyKSArIHBhZGRpbmcoc3RyKTtcbiAgICBpZiAoc3RyaWN0ICYmIHNwbGl0UG9pbnQgPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBTdHJpY3RFcnJvcihcIk5vdCBlbm91Z2ggcGFkZGluZyBmb3Igb3NjLXN0cmluZ1wiKTtcbiAgICB9XG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgZm9yIChpID0gaiA9IHJlZiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN0ciksIHJlZjEgPSBzcGxpdFBvaW50OyByZWYgPD0gcmVmMSA/IGogPCByZWYxIDogaiA+IHJlZjE7IGkgPSByZWYgPD0gcmVmMSA/ICsraiA6IC0taikge1xuICAgICAgICBpZiAoYnVmZmVyW2ldICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgU3RyaWN0RXJyb3IoXCJOb3QgZW5vdWdoIG9yIGluY29ycmVjdCBwYWRkaW5nIGZvciBvc2Mtc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3QgPSBidWZmZXIuc2xpY2Uoc3BsaXRQb2ludCwgYnVmZmVyLmxlbmd0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmluZzogc3RyLFxuICAgICAgcmVzdDogcmVzdFxuICAgIH07XG4gIH07XG5cbiAgZXhwb3J0cy5zcGxpdEludGVnZXIgPSBmdW5jdGlvbihidWZmZXIsIHR5cGUpIHtcbiAgICB2YXIgYnl0ZXMsIG51bSwgcmVzdCwgdmFsdWU7XG4gICAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IFwiSW50MzJcIjtcbiAgICB9XG4gICAgYnl0ZXMgPSAoYmlucGFja1tcInBhY2tcIiArIHR5cGVdKDApKS5sZW5ndGg7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCBieXRlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnVmZmVyIGlzIG5vdCBiaWcgZW5vdWdoIGZvciBpbnRlZ2VyIHR5cGVcIik7XG4gICAgfVxuICAgIG51bSA9IDA7XG4gICAgdmFsdWUgPSBiaW5wYWNrW1widW5wYWNrXCIgKyB0eXBlXShidWZmZXIuc2xpY2UoMCwgYnl0ZXMpLCBcImJpZ1wiKTtcbiAgICByZXN0ID0gYnVmZmVyLnNsaWNlKGJ5dGVzLCBidWZmZXIubGVuZ3RoKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW50ZWdlcjogdmFsdWUsXG4gICAgICByZXN0OiByZXN0XG4gICAgfTtcbiAgfTtcblxuICBleHBvcnRzLnNwbGl0VGltZXRhZyA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgIHZhciBhLCBiLCBieXRlcywgYywgZCwgZnJhY3Rpb25hbCwgcmVzdCwgc2Vjb25kcywgdHlwZTtcbiAgICB0eXBlID0gXCJVSW50MzJcIjtcbiAgICBieXRlcyA9IChiaW5wYWNrW1wicGFja1wiICsgdHlwZV0oMCkpLmxlbmd0aDtcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IChieXRlcyAqIDIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJidWZmZXIgaXMgbm90IGJpZyBlbm91Z2ggdG8gY29udGFpbiBhIHRpbWV0YWdcIik7XG4gICAgfVxuICAgIGEgPSAwO1xuICAgIGIgPSBieXRlcztcbiAgICBzZWNvbmRzID0gYmlucGFja1tcInVucGFja1wiICsgdHlwZV0oYnVmZmVyLnNsaWNlKGEsIGIpLCBcImJpZ1wiKTtcbiAgICBjID0gYnl0ZXM7XG4gICAgZCA9IGJ5dGVzICsgYnl0ZXM7XG4gICAgZnJhY3Rpb25hbCA9IGJpbnBhY2tbXCJ1bnBhY2tcIiArIHR5cGVdKGJ1ZmZlci5zbGljZShjLCBkKSwgXCJiaWdcIik7XG4gICAgcmVzdCA9IGJ1ZmZlci5zbGljZShkLCBidWZmZXIubGVuZ3RoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdGltZXRhZzogW3NlY29uZHMsIGZyYWN0aW9uYWxdLFxuICAgICAgcmVzdDogcmVzdFxuICAgIH07XG4gIH07XG5cbiAgVU5JWF9FUE9DSCA9IDIyMDg5ODg4MDA7XG5cbiAgVFdPX1BPV18zMiA9IDQyOTQ5NjcyOTY7XG5cbiAgZXhwb3J0cy5kYXRlVG9UaW1ldGFnID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBleHBvcnRzLnRpbWVzdGFtcFRvVGltZXRhZyhkYXRlLmdldFRpbWUoKSAvIDEwMDApO1xuICB9O1xuXG4gIGV4cG9ydHMudGltZXN0YW1wVG9UaW1ldGFnID0gZnVuY3Rpb24oc2Vjcykge1xuICAgIHZhciBmcmFjU2Vjb25kcywgd2hvbGVTZWNzO1xuICAgIHdob2xlU2VjcyA9IE1hdGguZmxvb3Ioc2Vjcyk7XG4gICAgZnJhY1NlY29uZHMgPSBzZWNzIC0gd2hvbGVTZWNzO1xuICAgIHJldHVybiBtYWtlVGltZXRhZyh3aG9sZVNlY3MsIGZyYWNTZWNvbmRzKTtcbiAgfTtcblxuICBleHBvcnRzLnRpbWV0YWdUb1RpbWVzdGFtcCA9IGZ1bmN0aW9uKHRpbWV0YWcpIHtcbiAgICB2YXIgc2Vjb25kcztcbiAgICBzZWNvbmRzID0gdGltZXRhZ1swXSArIGV4cG9ydHMubnRwVG9GcmFjdGlvbmFsU2Vjb25kcyh0aW1ldGFnWzFdKTtcbiAgICByZXR1cm4gc2Vjb25kcyAtIFVOSVhfRVBPQ0g7XG4gIH07XG5cbiAgbWFrZVRpbWV0YWcgPSBmdW5jdGlvbih1bml4c2Vjb25kcywgZnJhY1NlY29uZHMpIHtcbiAgICB2YXIgbnRwRnJhY3MsIG50cFNlY3M7XG4gICAgbnRwU2VjcyA9IHVuaXhzZWNvbmRzICsgVU5JWF9FUE9DSDtcbiAgICBudHBGcmFjcyA9IE1hdGgucm91bmQoVFdPX1BPV18zMiAqIGZyYWNTZWNvbmRzKTtcbiAgICByZXR1cm4gW250cFNlY3MsIG50cEZyYWNzXTtcbiAgfTtcblxuICBleHBvcnRzLnRpbWV0YWdUb0RhdGUgPSBmdW5jdGlvbih0aW1ldGFnKSB7XG4gICAgdmFyIGRhdGUsIGRkLCBmcmFjcywgZnJhY3Rpb25hbCwgc2Vjb25kcztcbiAgICBzZWNvbmRzID0gdGltZXRhZ1swXSwgZnJhY3Rpb25hbCA9IHRpbWV0YWdbMV07XG4gICAgc2Vjb25kcyA9IHNlY29uZHMgLSBVTklYX0VQT0NIO1xuICAgIGZyYWNzID0gZXhwb3J0cy5udHBUb0ZyYWN0aW9uYWxTZWNvbmRzKGZyYWN0aW9uYWwpO1xuICAgIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIGRhdGUuc2V0VGltZSgoc2Vjb25kcyAqIDEwMDApICsgKGZyYWNzICogMTAwMCkpO1xuICAgIGRkID0gbmV3IERhdGUoKTtcbiAgICBkZC5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpO1xuICAgIGRkLnNldFVUQ01vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSk7XG4gICAgZGQuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgZGQuc2V0VVRDSG91cnMoZGF0ZS5nZXRVVENIb3VycygpKTtcbiAgICBkZC5zZXRVVENNaW51dGVzKGRhdGUuZ2V0VVRDTWludXRlcygpKTtcbiAgICBkZC5zZXRVVENTZWNvbmRzKGRhdGUuZ2V0VVRDU2Vjb25kcygpKTtcbiAgICBkZC5zZXRVVENNaWxsaXNlY29uZHMoZnJhY3MgKiAxMDAwKTtcbiAgICByZXR1cm4gZGQ7XG4gIH07XG5cbiAgZXhwb3J0cy5kZWx0YVRpbWV0YWcgPSBmdW5jdGlvbihzZWNvbmRzLCBub3cpIHtcbiAgICB2YXIgbjtcbiAgICBuID0gKG5vdyAhPSBudWxsID8gbm93IDogbmV3IERhdGUoKSkgLyAxMDAwO1xuICAgIHJldHVybiBleHBvcnRzLnRpbWVzdGFtcFRvVGltZXRhZyhuICsgc2Vjb25kcyk7XG4gIH07XG5cbiAgZXhwb3J0cy5udHBUb0ZyYWN0aW9uYWxTZWNvbmRzID0gZnVuY3Rpb24oZnJhY1NlY29uZHMpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChmcmFjU2Vjb25kcykgLyBUV09fUE9XXzMyO1xuICB9O1xuXG4gIGV4cG9ydHMudG9UaW1ldGFnQnVmZmVyID0gZnVuY3Rpb24odGltZXRhZykge1xuICAgIHZhciBoaWdoLCBsb3csIHR5cGU7XG4gICAgaWYgKHR5cGVvZiB0aW1ldGFnID09PSBcIm51bWJlclwiKSB7XG4gICAgICB0aW1ldGFnID0gZXhwb3J0cy50aW1lc3RhbXBUb1RpbWV0YWcodGltZXRhZyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGltZXRhZyA9PT0gXCJvYmplY3RcIiAmJiAoXCJnZXRUaW1lXCIgaW4gdGltZXRhZykpIHtcbiAgICAgIHRpbWV0YWcgPSBleHBvcnRzLmRhdGVUb1RpbWV0YWcodGltZXRhZyk7XG4gICAgfSBlbHNlIGlmICh0aW1ldGFnLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0aW1ldGFnXCIgKyB0aW1ldGFnKTtcbiAgICB9XG4gICAgdHlwZSA9IFwiVUludDMyXCI7XG4gICAgaGlnaCA9IGJpbnBhY2tbXCJwYWNrXCIgKyB0eXBlXSh0aW1ldGFnWzBdLCBcImJpZ1wiKTtcbiAgICBsb3cgPSBiaW5wYWNrW1wicGFja1wiICsgdHlwZV0odGltZXRhZ1sxXSwgXCJiaWdcIik7XG4gICAgcmV0dXJuIGV4cG9ydHMuY29uY2F0KFtoaWdoLCBsb3ddKTtcbiAgfTtcblxuICBleHBvcnRzLnRvSW50ZWdlckJ1ZmZlciA9IGZ1bmN0aW9uKG51bWJlciwgdHlwZSkge1xuICAgIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAgIHR5cGUgPSBcIkludDMyXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbnVtYmVyICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgcGFjayBhIG5vbi1udW1iZXIgaW50byBhbiBpbnRlZ2VyIGJ1ZmZlclwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJpbnBhY2tbXCJwYWNrXCIgKyB0eXBlXShudW1iZXIsIFwiYmlnXCIpO1xuICB9O1xuXG4gIG9zY1R5cGVDb2RlcyA9IHtcbiAgICBzOiB7XG4gICAgICByZXByZXNlbnRhdGlvbjogXCJzdHJpbmdcIixcbiAgICAgIHNwbGl0OiBmdW5jdGlvbihidWZmZXIsIHN0cmljdCkge1xuICAgICAgICB2YXIgc3BsaXQ7XG4gICAgICAgIHNwbGl0ID0gZXhwb3J0cy5zcGxpdE9zY1N0cmluZyhidWZmZXIsIHN0cmljdCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHNwbGl0LnN0cmluZyxcbiAgICAgICAgICByZXN0OiBzcGxpdC5yZXN0XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdG9Bcmc6IGZ1bmN0aW9uKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIHN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3J0cy50b09zY1N0cmluZyh2YWx1ZSwgc3RyaWN0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGk6IHtcbiAgICAgIHJlcHJlc2VudGF0aW9uOiBcImludGVnZXJcIixcbiAgICAgIHNwbGl0OiBmdW5jdGlvbihidWZmZXIsIHN0cmljdCkge1xuICAgICAgICB2YXIgc3BsaXQ7XG4gICAgICAgIHNwbGl0ID0gZXhwb3J0cy5zcGxpdEludGVnZXIoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogc3BsaXQuaW50ZWdlcixcbiAgICAgICAgICByZXN0OiBzcGxpdC5yZXN0XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdG9Bcmc6IGZ1bmN0aW9uKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIG51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3J0cy50b0ludGVnZXJCdWZmZXIodmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdDoge1xuICAgICAgcmVwcmVzZW50YXRpb246IFwidGltZXRhZ1wiLFxuICAgICAgc3BsaXQ6IGZ1bmN0aW9uKGJ1ZmZlciwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBzcGxpdDtcbiAgICAgICAgc3BsaXQgPSBleHBvcnRzLnNwbGl0VGltZXRhZyhidWZmZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBzcGxpdC50aW1ldGFnLFxuICAgICAgICAgIHJlc3Q6IHNwbGl0LnJlc3RcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB0b0FyZzogZnVuY3Rpb24odmFsdWUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy50b1RpbWV0YWdCdWZmZXIodmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZjoge1xuICAgICAgcmVwcmVzZW50YXRpb246IFwiZmxvYXRcIixcbiAgICAgIHNwbGl0OiBmdW5jdGlvbihidWZmZXIsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBiaW5wYWNrLnVucGFja0Zsb2F0MzIoYnVmZmVyLnNsaWNlKDAsIDQpLCBcImJpZ1wiKSxcbiAgICAgICAgICByZXN0OiBidWZmZXIuc2xpY2UoNCwgYnVmZmVyLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB0b0FyZzogZnVuY3Rpb24odmFsdWUsIHN0cmljdCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgbnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaW5wYWNrLnBhY2tGbG9hdDMyKHZhbHVlLCBcImJpZ1wiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGQ6IHtcbiAgICAgIHJlcHJlc2VudGF0aW9uOiBcImRvdWJsZVwiLFxuICAgICAgc3BsaXQ6IGZ1bmN0aW9uKGJ1ZmZlciwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGJpbnBhY2sudW5wYWNrRmxvYXQ2NChidWZmZXIuc2xpY2UoMCwgOCksIFwiYmlnXCIpLFxuICAgICAgICAgIHJlc3Q6IGJ1ZmZlci5zbGljZSg4LCBidWZmZXIubGVuZ3RoKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRvQXJnOiBmdW5jdGlvbih2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpbnBhY2sucGFja0Zsb2F0NjQodmFsdWUsIFwiYmlnXCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYjoge1xuICAgICAgcmVwcmVzZW50YXRpb246IFwiYmxvYlwiLFxuICAgICAgc3BsaXQ6IGZ1bmN0aW9uKGJ1ZmZlciwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBsZW5ndGgsIHJlZjtcbiAgICAgICAgcmVmID0gZXhwb3J0cy5zcGxpdEludGVnZXIoYnVmZmVyKSwgbGVuZ3RoID0gcmVmLmludGVnZXIsIGJ1ZmZlciA9IHJlZi5yZXN0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBidWZmZXIuc2xpY2UoMCwgbGVuZ3RoKSxcbiAgICAgICAgICByZXN0OiBidWZmZXIuc2xpY2UobGVuZ3RoLCBidWZmZXIubGVuZ3RoKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRvQXJnOiBmdW5jdGlvbih2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBzaXplO1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBub2RlLmpzIEJ1ZmZlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBzaXplID0gZXhwb3J0cy50b0ludGVnZXJCdWZmZXIodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuY29uY2F0KFtzaXplLCB2YWx1ZV0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgVDoge1xuICAgICAgcmVwcmVzZW50YXRpb246IFwidHJ1ZVwiLFxuICAgICAgc3BsaXQ6IGZ1bmN0aW9uKGJ1ZmZlciwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdDogYnVmZmVyLFxuICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdG9Bcmc6IGZ1bmN0aW9uKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiBzdHJpY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnVlIG11c3QgYmUgdHJ1ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIEY6IHtcbiAgICAgIHJlcHJlc2VudGF0aW9uOiBcImZhbHNlXCIsXG4gICAgICBzcGxpdDogZnVuY3Rpb24oYnVmZmVyLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN0OiBidWZmZXIsXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdG9Bcmc6IGZ1bmN0aW9uKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHN0cmljdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZhbHNlIG11c3QgYmUgZmFsc2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoMCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBOOiB7XG4gICAgICByZXByZXNlbnRhdGlvbjogXCJudWxsXCIsXG4gICAgICBzcGxpdDogZnVuY3Rpb24oYnVmZmVyLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN0OiBidWZmZXIsXG4gICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB0b0FyZzogZnVuY3Rpb24odmFsdWUsIHN0cmljdCkge1xuICAgICAgICBpZiAodmFsdWUgJiYgc3RyaWN0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibnVsbCBtdXN0IGJlIGZhbHNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKDApO1xuICAgICAgfVxuICAgIH0sXG4gICAgSToge1xuICAgICAgcmVwcmVzZW50YXRpb246IFwiYmFuZ1wiLFxuICAgICAgc3BsaXQ6IGZ1bmN0aW9uKGJ1ZmZlciwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdDogYnVmZmVyLFxuICAgICAgICAgIHZhbHVlOiBcImJhbmdcIlxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRvQXJnOiBmdW5jdGlvbih2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKDApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBleHBvcnRzLm9zY1R5cGVDb2RlVG9UeXBlU3RyaW5nID0gZnVuY3Rpb24oY29kZSkge1xuICAgIHZhciByZWY7XG4gICAgcmV0dXJuIChyZWYgPSBvc2NUeXBlQ29kZXNbY29kZV0pICE9IG51bGwgPyByZWYucmVwcmVzZW50YXRpb24gOiB2b2lkIDA7XG4gIH07XG5cbiAgZXhwb3J0cy50eXBlU3RyaW5nVG9Pc2NUeXBlQ29kZSA9IGZ1bmN0aW9uKHJlcCkge1xuICAgIHZhciBjb2RlLCBzdHI7XG4gICAgZm9yIChjb2RlIGluIG9zY1R5cGVDb2Rlcykge1xuICAgICAgaWYgKCFoYXNQcm9wLmNhbGwob3NjVHlwZUNvZGVzLCBjb2RlKSkgY29udGludWU7XG4gICAgICBzdHIgPSBvc2NUeXBlQ29kZXNbY29kZV0ucmVwcmVzZW50YXRpb247XG4gICAgICBpZiAoc3RyID09PSByZXApIHtcbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIGV4cG9ydHMuYXJnVG9UeXBlQ29kZSA9IGZ1bmN0aW9uKGFyZywgc3RyaWN0KSB7XG4gICAgdmFyIGNvZGUsIHZhbHVlO1xuICAgIGlmICgoKGFyZyAhPSBudWxsID8gYXJnLnR5cGUgOiB2b2lkIDApICE9IG51bGwpICYmICh0eXBlb2YgYXJnLnR5cGUgPT09ICdzdHJpbmcnKSAmJiAoKGNvZGUgPSBleHBvcnRzLnR5cGVTdHJpbmdUb09zY1R5cGVDb2RlKGFyZy50eXBlKSkgIT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICB2YWx1ZSA9IChhcmcgIT0gbnVsbCA/IGFyZy52YWx1ZSA6IHZvaWQgMCkgIT0gbnVsbCA/IGFyZy52YWx1ZSA6IGFyZztcbiAgICBpZiAoc3RyaWN0ICYmICh2YWx1ZSA9PSBudWxsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCBoYXMgbm8gdmFsdWUnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiAncyc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJ2YnO1xuICAgIH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuICdiJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICdUJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnRic7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICdOJztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSSBkb24ndCBrbm93IHdoYXQgdHlwZSB0aGlzIGlzIHN1cHBvc2VkIHRvIGJlLlwiKTtcbiAgfTtcblxuICBleHBvcnRzLnNwbGl0T3NjQXJndW1lbnQgPSBmdW5jdGlvbihidWZmZXIsIHR5cGUsIHN0cmljdCkge1xuICAgIHZhciBvc2N0eXBlO1xuICAgIG9zY3R5cGUgPSBleHBvcnRzLnR5cGVTdHJpbmdUb09zY1R5cGVDb2RlKHR5cGUpO1xuICAgIGlmIChvc2N0eXBlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBvc2NUeXBlQ29kZXNbb3NjdHlwZV0uc3BsaXQoYnVmZmVyLCBzdHJpY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJIGRvbid0IHVuZGVyc3RhbmQgaG93IEknbSBzdXBwb3NlZCB0byB1bnBhY2sgXCIgKyB0eXBlKTtcbiAgICB9XG4gIH07XG5cbiAgZXhwb3J0cy50b09zY0FyZ3VtZW50ID0gZnVuY3Rpb24odmFsdWUsIHR5cGUsIHN0cmljdCkge1xuICAgIHZhciBvc2N0eXBlO1xuICAgIG9zY3R5cGUgPSBleHBvcnRzLnR5cGVTdHJpbmdUb09zY1R5cGVDb2RlKHR5cGUpO1xuICAgIGlmIChvc2N0eXBlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBvc2NUeXBlQ29kZXNbb3NjdHlwZV0udG9BcmcodmFsdWUsIHN0cmljdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkkgZG9uJ3Qga25vdyBob3cgdG8gcGFjayBcIiArIHR5cGUpO1xuICAgIH1cbiAgfTtcblxuICBleHBvcnRzLmZyb21Pc2NNZXNzYWdlID0gZnVuY3Rpb24oYnVmZmVyLCBzdHJpY3QpIHtcbiAgICB2YXIgYWRkcmVzcywgYXJnLCBhcmdzLCBhcnJheVN0YWNrLCBidWlsdCwgaiwgbGVuLCByZWYsIHJlZjEsIHR5cGUsIHR5cGVTdHJpbmcsIHR5cGVzO1xuICAgIHJlZiA9IGV4cG9ydHMuc3BsaXRPc2NTdHJpbmcoYnVmZmVyLCBzdHJpY3QpLCBhZGRyZXNzID0gcmVmLnN0cmluZywgYnVmZmVyID0gcmVmLnJlc3Q7XG4gICAgaWYgKHN0cmljdCAmJiBhZGRyZXNzWzBdICE9PSAnLycpIHtcbiAgICAgIHRocm93IFN0cmljdEVycm9yKCdhZGRyZXNzZXMgbXVzdCBzdGFydCB3aXRoIC8nKTtcbiAgICB9XG4gICAgaWYgKCFidWZmZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICBhcmdzOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgcmVmMSA9IGV4cG9ydHMuc3BsaXRPc2NTdHJpbmcoYnVmZmVyLCBzdHJpY3QpLCB0eXBlcyA9IHJlZjEuc3RyaW5nLCBidWZmZXIgPSByZWYxLnJlc3Q7XG4gICAgaWYgKHR5cGVzWzBdICE9PSAnLCcpIHtcbiAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgdGhyb3cgU3RyaWN0RXJyb3IoJ0FyZ3VtZW50IGxpc3RzIG11c3QgYmVnaW4gd2l0aCAsJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICBhcmdzOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgdHlwZXMgPSB0eXBlcy5zbGljZSgxLCArdHlwZXMubGVuZ3RoICsgMSB8fCA5ZTkpO1xuICAgIGFyZ3MgPSBbXTtcbiAgICBhcnJheVN0YWNrID0gW2FyZ3NdO1xuICAgIGZvciAoaiA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICB0eXBlID0gdHlwZXNbal07XG4gICAgICBpZiAodHlwZSA9PT0gJ1snKSB7XG4gICAgICAgIGFycmF5U3RhY2sucHVzaChbXSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICddJykge1xuICAgICAgICBpZiAoYXJyYXlTdGFjay5sZW5ndGggPD0gMSkge1xuICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdHJpY3RFcnJvcihcIk1pc21hdGNoZWQgJ10nIGNoYXJhY3Rlci5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1aWx0ID0gYXJyYXlTdGFjay5wb3AoKTtcbiAgICAgICAgICBhcnJheVN0YWNrW2FycmF5U3RhY2subGVuZ3RoIC0gMV0ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgdmFsdWU6IGJ1aWx0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0eXBlU3RyaW5nID0gZXhwb3J0cy5vc2NUeXBlQ29kZVRvVHlwZVN0cmluZyh0eXBlKTtcbiAgICAgIGlmICh0eXBlU3RyaW5nID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSSBkb24ndCB1bmRlcnN0YW5kIHRoZSBhcmd1bWVudCBjb2RlIFwiICsgdHlwZSk7XG4gICAgICB9XG4gICAgICBhcmcgPSBleHBvcnRzLnNwbGl0T3NjQXJndW1lbnQoYnVmZmVyLCB0eXBlU3RyaW5nLCBzdHJpY3QpO1xuICAgICAgaWYgKGFyZyAhPSBudWxsKSB7XG4gICAgICAgIGJ1ZmZlciA9IGFyZy5yZXN0O1xuICAgICAgfVxuICAgICAgYXJyYXlTdGFja1thcnJheVN0YWNrLmxlbmd0aCAtIDFdLnB1c2goe1xuICAgICAgICB0eXBlOiB0eXBlU3RyaW5nLFxuICAgICAgICB2YWx1ZTogYXJnICE9IG51bGwgPyBhcmcudmFsdWUgOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYXJyYXlTdGFjay5sZW5ndGggIT09IDEgJiYgc3RyaWN0KSB7XG4gICAgICB0aHJvdyBuZXcgU3RyaWN0RXJyb3IoXCJNaXNtYXRjaGVkICdbJyBjaGFyYWN0ZXJcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgYXJnczogYXJncyxcbiAgICAgIG9zY1R5cGU6IFwibWVzc2FnZVwiXG4gICAgfTtcbiAgfTtcblxuICBleHBvcnRzLmZyb21Pc2NCdW5kbGUgPSBmdW5jdGlvbihidWZmZXIsIHN0cmljdCkge1xuICAgIHZhciBidW5kbGVUYWcsIGNvbnZlcnRlZEVsZW1zLCByZWYsIHJlZjEsIHRpbWV0YWc7XG4gICAgcmVmID0gZXhwb3J0cy5zcGxpdE9zY1N0cmluZyhidWZmZXIsIHN0cmljdCksIGJ1bmRsZVRhZyA9IHJlZi5zdHJpbmcsIGJ1ZmZlciA9IHJlZi5yZXN0O1xuICAgIGlmIChidW5kbGVUYWcgIT09IFwiXFwjYnVuZGxlXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9zYy1idW5kbGVzIG11c3QgYmVnaW4gd2l0aCBcXCNidW5kbGVcIik7XG4gICAgfVxuICAgIHJlZjEgPSBleHBvcnRzLnNwbGl0VGltZXRhZyhidWZmZXIpLCB0aW1ldGFnID0gcmVmMS50aW1ldGFnLCBidWZmZXIgPSByZWYxLnJlc3Q7XG4gICAgY29udmVydGVkRWxlbXMgPSBtYXBCdW5kbGVMaXN0KGJ1ZmZlciwgZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5mcm9tT3NjUGFja2V0KGJ1ZmZlciwgc3RyaWN0KTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdGltZXRhZzogdGltZXRhZyxcbiAgICAgIGVsZW1lbnRzOiBjb252ZXJ0ZWRFbGVtcyxcbiAgICAgIG9zY1R5cGU6IFwiYnVuZGxlXCJcbiAgICB9O1xuICB9O1xuXG4gIGV4cG9ydHMuZnJvbU9zY1BhY2tldCA9IGZ1bmN0aW9uKGJ1ZmZlciwgc3RyaWN0KSB7XG4gICAgaWYgKGlzT3NjQnVuZGxlQnVmZmVyKGJ1ZmZlciwgc3RyaWN0KSkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZnJvbU9zY0J1bmRsZShidWZmZXIsIHN0cmljdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmZyb21Pc2NNZXNzYWdlKGJ1ZmZlciwgc3RyaWN0KTtcbiAgICB9XG4gIH07XG5cbiAgZ2V0QXJyYXlBcmcgPSBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAoSXNBcnJheShhcmcpKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH0gZWxzZSBpZiAoKChhcmcgIT0gbnVsbCA/IGFyZy50eXBlIDogdm9pZCAwKSA9PT0gXCJhcnJheVwiKSAmJiAoSXNBcnJheShhcmcgIT0gbnVsbCA/IGFyZy52YWx1ZSA6IHZvaWQgMCkpKSB7XG4gICAgICByZXR1cm4gYXJnLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAoKGFyZyAhPSBudWxsKSAmJiAoYXJnLnR5cGUgPT0gbnVsbCkgJiYgKElzQXJyYXkoYXJnLnZhbHVlKSkpIHtcbiAgICAgIHJldHVybiBhcmcudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICB0b09zY1R5cGVBbmRBcmdzID0gZnVuY3Rpb24oYXJnTGlzdCwgc3RyaWN0KSB7XG4gICAgdmFyIGFyZywgYnVmZiwgaiwgbGVuLCBvc2NhcmdzLCBvc2N0eXBlLCByZWYsIHRoaXNBcmdzLCB0aGlzVHlwZSwgdHlwZUNvZGUsIHZhbHVlO1xuICAgIG9zY3R5cGUgPSBcIlwiO1xuICAgIG9zY2FyZ3MgPSBbXTtcbiAgICBmb3IgKGogPSAwLCBsZW4gPSBhcmdMaXN0Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBhcmcgPSBhcmdMaXN0W2pdO1xuICAgICAgaWYgKChnZXRBcnJheUFyZyhhcmcpKSAhPSBudWxsKSB7XG4gICAgICAgIHJlZiA9IHRvT3NjVHlwZUFuZEFyZ3MoZ2V0QXJyYXlBcmcoYXJnKSwgc3RyaWN0KSwgdGhpc1R5cGUgPSByZWZbMF0sIHRoaXNBcmdzID0gcmVmWzFdO1xuICAgICAgICBvc2N0eXBlICs9IFwiW1wiICsgdGhpc1R5cGUgKyBcIl1cIjtcbiAgICAgICAgb3NjYXJncyA9IG9zY2FyZ3MuY29uY2F0KHRoaXNBcmdzKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0eXBlQ29kZSA9IGV4cG9ydHMuYXJnVG9UeXBlQ29kZShhcmcsIHN0cmljdCk7XG4gICAgICBpZiAodHlwZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICB2YWx1ZSA9IGFyZyAhPSBudWxsID8gYXJnLnZhbHVlIDogdm9pZCAwO1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhbHVlID0gYXJnO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmYgPSBleHBvcnRzLnRvT3NjQXJndW1lbnQodmFsdWUsIGV4cG9ydHMub3NjVHlwZUNvZGVUb1R5cGVTdHJpbmcodHlwZUNvZGUpLCBzdHJpY3QpO1xuICAgICAgICBpZiAoYnVmZiAhPSBudWxsKSB7XG4gICAgICAgICAgb3NjYXJncy5wdXNoKGJ1ZmYpO1xuICAgICAgICAgIG9zY3R5cGUgKz0gdHlwZUNvZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtvc2N0eXBlLCBvc2NhcmdzXTtcbiAgfTtcblxuICBleHBvcnRzLnRvT3NjTWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHN0cmljdCkge1xuICAgIHZhciBhZGRyZXNzLCBhbGxBcmdzLCBhcmdzLCBvbGRfYXJnLCBvc2NhZGRyLCBvc2NhcmdzLCBvc2N0eXBlLCByZWY7XG4gICAgYWRkcmVzcyA9IChtZXNzYWdlICE9IG51bGwgPyBtZXNzYWdlLmFkZHJlc3MgOiB2b2lkIDApICE9IG51bGwgPyBtZXNzYWdlLmFkZHJlc3MgOiBtZXNzYWdlO1xuICAgIGlmICh0eXBlb2YgYWRkcmVzcyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWVzc2FnZSBtdXN0IGNvbnRhaW4gYW4gYWRkcmVzc1wiKTtcbiAgICB9XG4gICAgYXJncyA9IG1lc3NhZ2UgIT0gbnVsbCA/IG1lc3NhZ2UuYXJncyA6IHZvaWQgMDtcbiAgICBpZiAoYXJncyA9PT0gdm9pZCAwKSB7XG4gICAgICBhcmdzID0gW107XG4gICAgfVxuICAgIGlmICghSXNBcnJheShhcmdzKSkge1xuICAgICAgb2xkX2FyZyA9IGFyZ3M7XG4gICAgICBhcmdzID0gW107XG4gICAgICBhcmdzWzBdID0gb2xkX2FyZztcbiAgICB9XG4gICAgb3NjYWRkciA9IGV4cG9ydHMudG9Pc2NTdHJpbmcoYWRkcmVzcywgc3RyaWN0KTtcbiAgICByZWYgPSB0b09zY1R5cGVBbmRBcmdzKGFyZ3MsIHN0cmljdCksIG9zY3R5cGUgPSByZWZbMF0sIG9zY2FyZ3MgPSByZWZbMV07XG4gICAgb3NjdHlwZSA9IFwiLFwiICsgb3NjdHlwZTtcbiAgICBhbGxBcmdzID0gZXhwb3J0cy5jb25jYXQob3NjYXJncyk7XG4gICAgb3NjdHlwZSA9IGV4cG9ydHMudG9Pc2NTdHJpbmcob3NjdHlwZSk7XG4gICAgcmV0dXJuIGV4cG9ydHMuY29uY2F0KFtvc2NhZGRyLCBvc2N0eXBlLCBhbGxBcmdzXSk7XG4gIH07XG5cbiAgZXhwb3J0cy50b09zY0J1bmRsZSA9IGZ1bmN0aW9uKGJ1bmRsZSwgc3RyaWN0KSB7XG4gICAgdmFyIGFsbEVsZW1zLCBidWZmLCBlLCBlbGVtLCBlbGVtZW50cywgZWxlbXN0ciwgaiwgbGVuLCBvc2NCdW5kbGVUYWcsIG9zY0VsZW1zLCBvc2NUaW1lVGFnLCByZWYsIHJlZjEsIHNpemUsIHRpbWV0YWc7XG4gICAgaWYgKHN0cmljdCAmJiAoKGJ1bmRsZSAhPSBudWxsID8gYnVuZGxlLnRpbWV0YWcgOiB2b2lkIDApID09IG51bGwpKSB7XG4gICAgICB0aHJvdyBTdHJpY3RFcnJvcihcImJ1bmRsZXMgbXVzdCBoYXZlIHRpbWV0YWdzLlwiKTtcbiAgICB9XG4gICAgdGltZXRhZyA9IChyZWYgPSBidW5kbGUgIT0gbnVsbCA/IGJ1bmRsZS50aW1ldGFnIDogdm9pZCAwKSAhPSBudWxsID8gcmVmIDogbmV3IERhdGUoKTtcbiAgICBlbGVtZW50cyA9IChyZWYxID0gYnVuZGxlICE9IG51bGwgPyBidW5kbGUuZWxlbWVudHMgOiB2b2lkIDApICE9IG51bGwgPyByZWYxIDogW107XG4gICAgaWYgKCFJc0FycmF5KGVsZW1lbnRzKSkge1xuICAgICAgZWxlbXN0ciA9IGVsZW1lbnRzO1xuICAgICAgZWxlbWVudHMgPSBbXTtcbiAgICAgIGVsZW1lbnRzLnB1c2goZWxlbXN0cik7XG4gICAgfVxuICAgIG9zY0J1bmRsZVRhZyA9IGV4cG9ydHMudG9Pc2NTdHJpbmcoXCJcXCNidW5kbGVcIik7XG4gICAgb3NjVGltZVRhZyA9IGV4cG9ydHMudG9UaW1ldGFnQnVmZmVyKHRpbWV0YWcpO1xuICAgIG9zY0VsZW1zID0gW107XG4gICAgZm9yIChqID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIGVsZW0gPSBlbGVtZW50c1tqXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGJ1ZmYgPSBleHBvcnRzLnRvT3NjUGFja2V0KGVsZW0sIHN0cmljdCk7XG4gICAgICAgIHNpemUgPSBleHBvcnRzLnRvSW50ZWdlckJ1ZmZlcihidWZmLmxlbmd0aCk7XG4gICAgICAgIG9zY0VsZW1zLnB1c2goZXhwb3J0cy5jb25jYXQoW3NpemUsIGJ1ZmZdKSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBlID0gZXJyb3I7XG4gICAgICAgIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGFsbEVsZW1zID0gZXhwb3J0cy5jb25jYXQob3NjRWxlbXMpO1xuICAgIHJldHVybiBleHBvcnRzLmNvbmNhdChbb3NjQnVuZGxlVGFnLCBvc2NUaW1lVGFnLCBhbGxFbGVtc10pO1xuICB9O1xuXG4gIGV4cG9ydHMudG9Pc2NQYWNrZXQgPSBmdW5jdGlvbihidW5kbGVPck1lc3NhZ2UsIHN0cmljdCkge1xuICAgIGlmICgoYnVuZGxlT3JNZXNzYWdlICE9IG51bGwgPyBidW5kbGVPck1lc3NhZ2Uub3NjVHlwZSA6IHZvaWQgMCkgIT0gbnVsbCkge1xuICAgICAgaWYgKGJ1bmRsZU9yTWVzc2FnZS5vc2NUeXBlID09PSBcImJ1bmRsZVwiKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnRvT3NjQnVuZGxlKGJ1bmRsZU9yTWVzc2FnZSwgc3RyaWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleHBvcnRzLnRvT3NjTWVzc2FnZShidW5kbGVPck1lc3NhZ2UsIHN0cmljdCk7XG4gICAgfVxuICAgIGlmICgoKGJ1bmRsZU9yTWVzc2FnZSAhPSBudWxsID8gYnVuZGxlT3JNZXNzYWdlLnRpbWV0YWcgOiB2b2lkIDApICE9IG51bGwpIHx8ICgoYnVuZGxlT3JNZXNzYWdlICE9IG51bGwgPyBidW5kbGVPck1lc3NhZ2UuZWxlbWVudHMgOiB2b2lkIDApICE9IG51bGwpKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy50b09zY0J1bmRsZShidW5kbGVPck1lc3NhZ2UsIHN0cmljdCk7XG4gICAgfVxuICAgIHJldHVybiBleHBvcnRzLnRvT3NjTWVzc2FnZShidW5kbGVPck1lc3NhZ2UsIHN0cmljdCk7XG4gIH07XG5cbiAgZXhwb3J0cy5hcHBseU1lc3NhZ2VUcmFuZm9ybWVyVG9CdW5kbGUgPSBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICB2YXIgYnVuZGxlVGFnQnVmZmVyLCBjb3B5SW5kZXgsIGVsZW0sIGVsZW1zLCBqLCBrLCBsZW4sIGxlbjEsIGxlbmd0aEJ1ZmYsIG91dEJ1ZmZlciwgcmVmLCBzdHJpbmcsIHRpbWV0YWdCdWZmZXIsIHRvdGFsTGVuZ3RoO1xuICAgICAgcmVmID0gZXhwb3J0cy5zcGxpdE9zY1N0cmluZyhidWZmZXIpLCBzdHJpbmcgPSByZWYuc3RyaW5nLCBidWZmZXIgPSByZWYucmVzdDtcbiAgICAgIGlmIChzdHJpbmcgIT09IFwiXFwjYnVuZGxlXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3NjLWJ1bmRsZXMgbXVzdCBiZWdpbiB3aXRoIFxcI2J1bmRsZVwiKTtcbiAgICAgIH1cbiAgICAgIGJ1bmRsZVRhZ0J1ZmZlciA9IGV4cG9ydHMudG9Pc2NTdHJpbmcoc3RyaW5nKTtcbiAgICAgIHRpbWV0YWdCdWZmZXIgPSBidWZmZXIuc2xpY2UoMCwgOCk7XG4gICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoOCwgYnVmZmVyLmxlbmd0aCk7XG4gICAgICBlbGVtcyA9IG1hcEJ1bmRsZUxpc3QoYnVmZmVyLCBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuYXBwbHlUcmFuc2Zvcm0oYnVmZmVyLCB0cmFuc2Zvcm0sIGV4cG9ydHMuYXBwbHlNZXNzYWdlVHJhbmZvcm1lclRvQnVuZGxlKHRyYW5zZm9ybSkpO1xuICAgICAgfSk7XG4gICAgICB0b3RhbExlbmd0aCA9IGJ1bmRsZVRhZ0J1ZmZlci5sZW5ndGggKyB0aW1ldGFnQnVmZmVyLmxlbmd0aDtcbiAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGVsZW1zLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIGVsZW0gPSBlbGVtc1tqXTtcbiAgICAgICAgdG90YWxMZW5ndGggKz0gNCArIGVsZW0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgb3V0QnVmZmVyID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aCk7XG4gICAgICBidW5kbGVUYWdCdWZmZXIuY29weShvdXRCdWZmZXIsIDApO1xuICAgICAgdGltZXRhZ0J1ZmZlci5jb3B5KG91dEJ1ZmZlciwgYnVuZGxlVGFnQnVmZmVyLmxlbmd0aCk7XG4gICAgICBjb3B5SW5kZXggPSBidW5kbGVUYWdCdWZmZXIubGVuZ3RoICsgdGltZXRhZ0J1ZmZlci5sZW5ndGg7XG4gICAgICBmb3IgKGsgPSAwLCBsZW4xID0gZWxlbXMubGVuZ3RoOyBrIDwgbGVuMTsgaysrKSB7XG4gICAgICAgIGVsZW0gPSBlbGVtc1trXTtcbiAgICAgICAgbGVuZ3RoQnVmZiA9IGV4cG9ydHMudG9JbnRlZ2VyQnVmZmVyKGVsZW0ubGVuZ3RoKTtcbiAgICAgICAgbGVuZ3RoQnVmZi5jb3B5KG91dEJ1ZmZlciwgY29weUluZGV4KTtcbiAgICAgICAgY29weUluZGV4ICs9IDQ7XG4gICAgICAgIGVsZW0uY29weShvdXRCdWZmZXIsIGNvcHlJbmRleCk7XG4gICAgICAgIGNvcHlJbmRleCArPSBlbGVtLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRCdWZmZXI7XG4gICAgfTtcbiAgfTtcblxuICBleHBvcnRzLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24oYnVmZmVyLCBtVHJhbnNmb3JtLCBidW5kbGVUcmFuc2Zvcm0pIHtcbiAgICBpZiAoYnVuZGxlVHJhbnNmb3JtID09IG51bGwpIHtcbiAgICAgIGJ1bmRsZVRyYW5zZm9ybSA9IGV4cG9ydHMuYXBwbHlNZXNzYWdlVHJhbmZvcm1lclRvQnVuZGxlKG1UcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBpZiAoaXNPc2NCdW5kbGVCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgcmV0dXJuIGJ1bmRsZVRyYW5zZm9ybShidWZmZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbVRyYW5zZm9ybShidWZmZXIpO1xuICAgIH1cbiAgfTtcblxuICBleHBvcnRzLmFkZHJlc3NUcmFuc2Zvcm0gPSBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICB2YXIgcmVmLCByZXN0LCBzdHJpbmc7XG4gICAgICByZWYgPSBleHBvcnRzLnNwbGl0T3NjU3RyaW5nKGJ1ZmZlciksIHN0cmluZyA9IHJlZi5zdHJpbmcsIHJlc3QgPSByZWYucmVzdDtcbiAgICAgIHN0cmluZyA9IHRyYW5zZm9ybShzdHJpbmcpO1xuICAgICAgcmV0dXJuIGV4cG9ydHMuY29uY2F0KFtleHBvcnRzLnRvT3NjU3RyaW5nKHN0cmluZyksIHJlc3RdKTtcbiAgICB9O1xuICB9O1xuXG4gIGV4cG9ydHMubWVzc2FnZVRyYW5zZm9ybSA9IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgbWVzc2FnZSA9IGV4cG9ydHMuZnJvbU9zY01lc3NhZ2UoYnVmZmVyKTtcbiAgICAgIHJldHVybiBleHBvcnRzLnRvT3NjTWVzc2FnZSh0cmFuc2Zvcm0obWVzc2FnZSkpO1xuICAgIH07XG4gIH07XG5cbiAgSXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbiAgU3RyaWN0RXJyb3IgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiU3RyaWN0IEVycm9yOiBcIiArIHN0cik7XG4gIH07XG5cbiAgcGFkZGluZyA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciBidWZmbGVuZ3RoO1xuICAgIGJ1ZmZsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdHIpO1xuICAgIHJldHVybiA0IC0gKGJ1ZmZsZW5ndGggJSA0KTtcbiAgfTtcblxuICBpc09zY0J1bmRsZUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlciwgc3RyaWN0KSB7XG4gICAgdmFyIHN0cmluZztcbiAgICBzdHJpbmcgPSBleHBvcnRzLnNwbGl0T3NjU3RyaW5nKGJ1ZmZlciwgc3RyaWN0KS5zdHJpbmc7XG4gICAgcmV0dXJuIHN0cmluZyA9PT0gXCJcXCNidW5kbGVcIjtcbiAgfTtcblxuICBtYXBCdW5kbGVMaXN0ID0gZnVuY3Rpb24oYnVmZmVyLCBmdW5jKSB7XG4gICAgdmFyIGUsIGVsZW0sIGVsZW1zLCBqLCBsZW4sIG5vbk51bGxFbGVtcywgc2l6ZSwgdGhpc0VsZW1CdWZmZXI7XG4gICAgZWxlbXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVmLCByZXN1bHRzO1xuICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgd2hpbGUgKGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgcmVmID0gZXhwb3J0cy5zcGxpdEludGVnZXIoYnVmZmVyKSwgc2l6ZSA9IHJlZi5pbnRlZ2VyLCBidWZmZXIgPSByZWYucmVzdDtcbiAgICAgICAgaWYgKHNpemUgPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBidW5kbGUgbGlzdDogc2l6ZSBvZiBlbGVtZW50IGlzIGJpZ2dlciB0aGFuIGJ1ZmZlclwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzRWxlbUJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgwLCBzaXplKTtcbiAgICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKHNpemUsIGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChmdW5jKHRoaXNFbGVtQnVmZmVyKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgZSA9IGVycm9yO1xuICAgICAgICAgIHJlc3VsdHMucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSkoKTtcbiAgICBub25OdWxsRWxlbXMgPSBbXTtcbiAgICBmb3IgKGogPSAwLCBsZW4gPSBlbGVtcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgZWxlbSA9IGVsZW1zW2pdO1xuICAgICAgaWYgKGVsZW0gIT0gbnVsbCkge1xuICAgICAgICBub25OdWxsRWxlbXMucHVzaChlbGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vbk51bGxFbGVtcztcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsICIoZnVuY3Rpb24oKSB7XG4gIFxuLy9+cmVhZG1lLm91dH5cbi8vWyFbYnVpbGQgc3RhdHVzXShodHRwczovL3NlY3VyZS50cmF2aXMtY2kub3JnL3J1c3NlbGxtY2Mvbm9kZS1vc2MtbWluLnBuZyldKGh0dHA6Ly90cmF2aXMtY2kub3JnL3J1c3NlbGxtY2Mvbm9kZS1vc2MtbWluKSBbIVtDb3ZlcmFnZSBTdGF0dXNdKGh0dHBzOi8vY292ZXJhbGxzLmlvL3JlcG9zL3J1c3NlbGxtY2Mvbm9kZS1vc2MtbWluL2JhZGdlLnBuZz9icmFuY2g9bWFzdGVyKV0oaHR0cHM6Ly9jb3ZlcmFsbHMuaW8vci9ydXNzZWxsbWNjL25vZGUtb3NjLW1pbj9icmFuY2g9bWFzdGVyKSBbIVtkZXBlbmRlbmNpZXNdKGh0dHBzOi8vZGF2aWQtZG0ub3JnL3J1c3NlbGxtY2Mvbm9kZS1vc2MtbWluLnBuZyldKGh0dHBzOi8vZGF2aWQtZG0ub3JnL3J1c3NlbGxtY2Mvbm9kZS1vc2MtbWluKVxuLy8jIG9zYy1taW5cbi8vIFxuLy8gX3NpbXBsZSB1dGlsaXRpZXMgZm9yIG9wZW4gc291bmQgY29udHJvbCBpbiBub2RlLmpzX1xuLy9cbi8vIFRoaXMgcGFja2FnZSBwcm92aWRlcyBzb21lIG5vZGUuanMgdXRpbGl0aWVzIGZvciB3b3JraW5nIHdpdGggXG4vLyBbT1NDXShodHRwOi8vb3BlbnNvdW5kY29udHJvbC5vcmcvKSwgYSBmb3JtYXQgZm9yIHNvdW5kIGFuZCBzeXN0ZW1zIGNvbnRyb2wuICBcbi8vIEhlcmUgd2UgaW1wbGVtZW50IHRoZSBbT1NDIDEuMV1bc3BlYzExXSBzcGVjaWZpY2F0aW9uLiAgT1NDIGlzIGEgdHJhbnNwb3J0LWluZGVwZW5kZW50XG4vLyBwcm90b2NvbCwgc28gd2UgZG9uJ3QgcHJvdmlkZSBhbnkgc2VydmVyIG9iamVjdHMsIGFzIHlvdSBzaG91bGQgYmUgYWJsZSB0byBcbi8vIHVzZSBPU0Mgb3ZlciBhbnkgdHJhbnNwb3J0IHlvdSBsaWtlLiAgVGhlIG1vc3QgY29tbW9uIGlzIHByb2JhYmx5IHVkcCwgYnV0IHRjcFxuLy8gaXMgbm90IHVuaGVhcmQgb2YuXG4vL1xuLy8gW3NwZWMxMV06IGh0dHA6Ly9vcGVuc291bmRjb250cm9sLm9yZy9zcGVjLTFfMVxuLy9cbi8vLS0tLVxuLy8jIyBJbnN0YWxsYXRpb25cbi8vfmluc3RhbGxhdGlvbn5cbi8vLS0tLVxuLy8jIyBFeGFtcGxlc1xuLy9+ZXhhbXBsZXN+XG4vL1xuLy8gbW9yZSBleGFtcGxlcyBhcmUgYXZhaWxhYmxlIGluIHRoZSBgZXhhbXBsZXMvYCBkaXJlY3RvcnkuXG4vL1xuLy8tLS0tXG4vL35hcGl+XG4vLy0tLS1cbi8vfnJlcHJlc2VudGF0aW9uflxuLy8tLS0tXG4vLyMjIExpY2Vuc2Vcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBmb3VuZCBpbiBDT1BZSU5HICh6bGliIGxpY2Vuc2UpXG5cbi8vfnJlcHJlc2VudGF0aW9uflxuLy8jIyBKYXZhc2NyaXB0IHJlcHJlc2VudGF0aW9ucyBvZiB0aGUgT1NDIHR5cGVzLiAgXG4vLyBTZWUgdGhlIFtzcGVjXVtzcGVjXSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgT1NDIHR5cGVzLlxuLy9cbi8vICsgQW4gX09TQyBQYWNrZXRfIGlzIGFuIF9PU0MgTWVzc2FnZV8gb3IgYW4gX09TQyBCdW5kbGVfLlxuLy9cbi8vICsgQW4gX09TQyBNZXNzYWdlXzpcbi8vXG4vLyAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICBvc2NUeXBlIDogXCJtZXNzYWdlXCJcbi8vICAgICAgICAgICAgICAgYWRkcmVzcyA6IFwiL2FkZHJlc3MvcGF0dGVybi9taWdodC9oYXZlL3dpbGRjYXJkc1wiXG4vLyAgICAgICAgICAgICAgIGFyZ3MgOiBbYXJnMSxhcmcyXVxuLy8gICAgICAgICAgIH1cbi8vXG4vLyAgICBXaGVyZSBhcmdzIGlzIGFuIGFycmF5IG9mIF9PU0MgQXJndW1lbnRzXy4gIGBvc2NUeXBlYCBpcyBvcHRpb25hbC5cbi8vICAgIGBhcmdzYCBjYW4gYmUgYSBzaW5nbGUgZWxlbWVudC5cbi8vXG4vLyArIEFuIF9PU0MgQXJndW1lbnRfIGlzIHJlcHJlc2VudGVkIGFzIGEgamF2YXNjcmlwdCBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGxheW91dDpcbi8vXG4vLyAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICB0eXBlIDogXCJzdHJpbmdcIlxuLy8gICAgICAgICAgICAgICB2YWx1ZSA6IFwidmFsdWVcIlxuLy8gICAgICAgICAgIH1cbi8vXG4vLyAgICBXaGVyZSB0aGUgYHR5cGVgIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuLy8gICAgKyBgc3RyaW5nYCAtIHN0cmluZyB2YWx1ZVxuLy8gICAgKyBgZmxvYXRgIC0gbnVtZXJpYyB2YWx1ZVxuLy8gICAgKyBgaW50ZWdlcmAgLSBudW1lcmljIHZhbHVlXG4vLyAgICArIGBibG9iYCAtIG5vZGUuanMgQnVmZmVyIHZhbHVlXG4vLyAgICArIGB0cnVlYCAtIHZhbHVlIGlzIGJvb2xlYW4gdHJ1ZVxuLy8gICAgKyBgZmFsc2VgIC0gdmFsdWUgaXMgYm9vbGVhbiBmYWxzZVxuLy8gICAgKyBgbnVsbGAgLSBubyB2YWx1ZVxuLy8gICAgKyBgYmFuZ2AgLSBubyB2YWx1ZSAodGhpcyBpcyB0aGUgYElgIHR5cGUgdGFnKVxuLy8gICAgKyBgdGltZXRhZ2AgLSBudW1lcmljIHZhbHVlXG4vLyAgICArIGBhcnJheWAgLSBhcnJheSBvZiBfT1NDIEFyZ3VtZW50c19cbi8vIFxuLy8gICAgTm90ZSB0aGF0IGB0eXBlYCBpcyBhbHdheXMgYSBzdHJpbmcgLSBpLmUuIGBcInRydWVcImAgcmF0aGVyIHRoYW4gYHRydWVgLlxuLy8gICBcbi8vICAgIFRoZSBmb2xsb3dpbmcgbm9uLXN0YW5kYXJkIHR5cGVzIGFyZSBhbHNvIHN1cHBvcnRlZDpcbi8vICAgICsgYGRvdWJsZWAgLSBudW1lcmljIHZhbHVlIChlbmNvZGVzIHRvIGEgZmxvYXQ2NCB2YWx1ZSlcbi8vXG4vLyAgICBcbi8vICAgIEZvciBtZXNzYWdlcyBzZW50IHRvIHRoZSBgdG9CdWZmZXJgIGZ1bmN0aW9uLCBgdHlwZWAgaXMgb3B0aW9uYWwuXG4vLyAgICBJZiB0aGUgYXJndW1lbnQgaXMgbm90IGFuIG9iamVjdCwgaXQgd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBlaXRoZXJcbi8vICAgIGBzdHJpbmdgLCBgZmxvYXRgLCBgYXJyYXlgIG9yIGBibG9iYCwgZGVwZW5kaW5nIG9uIGl0cyBqYXZhc2NyaXB0IHR5cGVcbi8vICAgIChTdHJpbmcsIE51bWJlciwgQXJyYXksIEJ1ZmZlciwgcmVzcGVjdGl2ZWx5KVxuLy9cbi8vICsgQW4gX09TQyBCdW5kbGVfIGlzIHJlcHJlc2VudGVkIGFzIGEgamF2YXNjcmlwdCBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGZpZWxkczpcbi8vXG4vLyAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICBvc2NUeXBlIDogXCJidW5kbGVcIlxuLy8gICAgICAgICAgICAgICB0aW1ldGFnIDogN1xuLy8gICAgICAgICAgICAgICBlbGVtZW50cyA6IFtlbGVtZW50MSwgZWxlbWVudF1cbi8vICAgICAgICAgICB9XG4vL1xuLy8gICBgb3NjVHlwZWAgXCJidW5kbGVcIlxuLy9cbi8vICAgYHRpbWV0YWdgIGlzIG9uZSBvZjpcbi8vICAgIC0gYG51bGxgIC0gbWVhbmluZyBub3csIHRoZSBjdXJyZW50IHRpbWUuXG4vLyAgICAgIEJ5IHRoZSB0aW1lIHRoZSBidW5kbGUgaXMgcmVjZWl2ZWQgaXQgd2lsbCB0b28gbGF0ZSBhbmQgZGVwZW5kaW5nXG4vLyAgICAgIG9uIHRoZSByZWNlaXZlciBtYXkgYmUgZGlzY2FyZGVkIG9yIHlvdSBtYXkgYmUgc2NvbGRlZCBmb3IgYmVpbmcgbGF0ZS5cbi8vICAgIC0gYG51bWJlcmAgLSByZWxhdGl2ZSBzZWNvbmRzIGZyb20gbm93IHdpdGggbWlsbGlzZWNvbmQgYWNjdXJhY3kuXG4vLyAgICAtIGBEYXRlYCAtIGEgSmF2YVNjcmlwdCBEYXRlIG9iamVjdCBpbiB5b3VyIGxvY2FsIHRpbWUgem9uZS5cbi8vICAgICBPU0MgdGltZXRhZ3MgdXNlIFVUQyB0aW1lem9uZSwgc28gZG8gbm90IHRyeSB0byBhZGp1c3QgZm9yIHRpbWV6b25lcyxcbi8vICAgICB0aGlzIGlzIG5vdCBuZWVkZWQuXG4vLyAgICAtIGBBcnJheWAgLSBgW251bWJlck9mU2Vjb25kc1NpbmNlMTkwMCwgZnJhY3Rpb25hbFNlY29uZHNdYFxuLy8gICAgICBCb3RoIHZhbHVlcyBhcmUgYG51bWJlcmBzLiBUaGlzIGdpdmVzIGZ1bGwgdGltaW5nIGFjY3VyYWN5IG9mIDEvKDJeMzIpIHNlY29uZHMuXG4vL1xuLy8gIGBlbGVtZW50c2AgaXMgYW4gYEFycmF5YCBvZiBlaXRoZXIgX09TQyBNZXNzYWdlXyBvciBfT1NDIEJ1bmRsZV9cbi8vXG4vL1xuLy8gW3NwZWNdOiBodHRwOi8vb3BlbnNvdW5kY29udHJvbC5vcmcvc3BlYy0xXzBcblxuICB2YXIgdXRpbHMsIGNvZmZlZTtcbiAgdXRpbHMgPSByZXF1aXJlKFwiLi9vc2MtdXRpbGl0aWVzXCIpO1xuLy8gfmFwaX5cbi8vIyMgRXhwb3J0ZWQgZnVuY3Rpb25zXG4vL1xuLy8tLS0tLS1cbi8vIyMjIC5mcm9tQnVmZmVyKGJ1ZmZlciwgW3N0cmljdF0pXG4vLyB0YWtlcyBhIG5vZGUuanMgQnVmZmVyIG9mIGEgY29tcGxldGUgX09TQyBQYWNrZXRfIGFuZCBcbi8vIG91dHB1dHMgdGhlIGphdmFzY3JpcHQgcmVwcmVzZW50YXRpb24sIG9yIHRocm93cyBpZiB0aGUgYnVmZmVyIGlzIGlsbC1mb3JtZWQuXG4vL1xuLy8gYHN0cmljdGAgaXMgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgbWFrZXMgdGhlIGZ1bmN0aW9uIGZhaWwgbW9yZSBvZnRlbi5cbiAgZXhwb3J0cy5mcm9tQnVmZmVyID0gZnVuY3Rpb24oYnVmZmVyLCBzdHJpY3QpIHtcbiAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXIobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG4gICAgfSBlbHNlIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICBidWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5mcm9tT3NjUGFja2V0KGJ1ZmZlciwgc3RyaWN0KTtcbiAgfTtcblxuLy9+YXBpflxuLy8tLS0tXG4vLyMjIyAudG9CdWZmZXIob2JqZWN0LCBbc3RyaWN0XSlcbi8vIHRha2VzIGEgX09TQyBwYWNrZXRfIGphdmFzY3JpcHQgcmVwcmVzZW50YXRpb24gYXMgZGVmaW5lZCBiZWxvdyBhbmQgcmV0dXJuc1xuLy8gYSBub2RlLmpzIEJ1ZmZlciwgb3IgdGhyb3dzIGlmIHRoZSByZXByZXNlbnRhdGlvbiBpcyBpbGwtZm9ybWVkLlxuLy9cbi8vIFNlZSBcIkphdmFTY3JpcHQgcmVwcmVzZW50YXRpb25zIG9mIHRoZSBPU0MgdHlwZXNcIiBiZWxvdy5cbi8vXG4vLy0tLS1cbi8vIyMjIC50b0J1ZmZlcihhZGRyZXNzLCBhcmdzW10sIFtzdHJpY3RdKVxuLy8gYWx0ZXJuYXRpdmUgc3ludGF4IGZvciBhYm92ZS4gIEFzc3VtZXMgdGhpcyBpcyBhbiBfT1NDIE1lc3NhZ2VfIGFzIGRlZmluZWQgYmVsb3csXG4vLyBhbmQgYGFyZ3NgIGlzIGFuIGFycmF5IG9mIF9PU0MgQXJndW1lbnRzXyBvciBzaW5nbGUgX09TQyBBcmd1bWVudF9cbiAgZXhwb3J0cy50b0J1ZmZlciA9IGZ1bmN0aW9uKG9iamVjdCwgc3RyaWN0LCBvcHQpIHtcbiAgICBpZih0eXBlb2Ygb2JqZWN0ID09PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIHV0aWxzLnRvT3NjUGFja2V0KHsnYWRkcmVzcycgOiBvYmplY3QsICdhcmdzJyA6IHN0cmljdH0sIG9wdCk7XG4gICAgcmV0dXJuIHV0aWxzLnRvT3NjUGFja2V0KG9iamVjdCwgc3RyaWN0KTtcbiAgfTtcblxuLy9+YXBpflxuLy8tLS0tXG4vLyMjIyAuYXBwbHlBZGRyZXNzVHJhbnNmb3JtKGJ1ZmZlciwgdHJhbnNmb3JtKVxuLy8gdGFrZXMgYSBjYWxsYmFjayB0aGF0IHRha2VzIGEgc3RyaW5nIGFuZCBvdXRwdXRzIGEgc3RyaW5nLFxuLy8gYW5kIGFwcGxpZXMgdGhhdCB0byB0aGUgYWRkcmVzcyBvZiB0aGUgbWVzc2FnZSBlbmNvZGVkIGluIHRoZSBidWZmZXIsXG4vLyBhbmQgb3V0cHV0cyBhbiBlbmNvZGVkIGJ1ZmZlci5cbi8vXG4vLyBJZiB0aGUgYnVmZmVyIGVuY29kZXMgYW4gX09TQyBCdW5kbGVfLCB0aGlzIGFwcGxpZXMgdGhlIGZ1bmN0aW9uIHRvIGVhY2ggYWRkcmVzcyBcbi8vIGluIHRoZSBidW5kbGUuXG4vL1xuLy8gVGhlcmUncyB0d28gc3VidGxlIHJlYXNvbnMgeW91J2Qgd2FudCB0byB1c2UgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiBcbi8vIGNvbXBvc2luZyBgZnJvbUJ1ZmZlcmAgYW5kIGB0b0J1ZmZlcmA6XG4vLyAgIC0gRnV0dXJlLXByb29maW5nIC0gaWYgdGhlIE9TQyBtZXNzYWdlIHVzZXMgYW4gYXJndW1lbnQgdHlwZWNvZGUgdGhhdFxuLy8gICAgIHdlIGRvbid0IHVuZGVyc3RhbmQsIGNhbGxpbmcgYGZyb21CdWZmZXJgIHdpbGwgdGhyb3cuICBUaGUgb25seSB0aW1lXG4vLyAgICAgd2hlbiBgYXBwbHlBZGRyZXNzVHJhbmZvcm1gIG1pZ2h0IGZhaWwgaXMgaWYgdGhlIGFkZHJlc3MgaXMgbWFsZm9ybWVkLlxuLy8gICAtIEFjY3VyYWN5IC0gamF2YXNjcmlwdCByZXByZXNlbnRzIG51bWJlcnMgYXMgNjQtYml0IGZsb2F0cywgc28gc29tZVxuLy8gICAgIE9TQyB0eXBlcyB3aWxsIG5vdCBiZSBhYmxlIHRvIGJlIHJlcHJlc2VudGVkIGFjY3VyYXRlbHkuICBJZiBhY2N1cmFjeVxuLy8gICAgIGlzIGltcG9ydGFudCB0byB5b3UsIHRoZW4sIHlvdSBzaG91bGQgbmV2ZXIgY29udmVydCB0aGUgT1NDIG1lc3NhZ2UgdG8gYVxuLy8gICAgIGphdmFzY3JpcHQgcmVwcmVzZW50YXRpb24uXG4gIGV4cG9ydHMuYXBwbHlBZGRyZXNzVHJhbnNmb3JtID0gZnVuY3Rpb24oYnVmZmVyLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gdXRpbHMuYXBwbHlUcmFuc2Zvcm0oYnVmZmVyLCB1dGlscy5hZGRyZXNzVHJhbnNmb3JtKHRyYW5zZm9ybSkpO1xuICB9O1xuICBcbi8vfmFwaX5cbi8vLS0tLVxuLy8jIyMgLmFwcGx5TWVzc2FnZVRyYW5zZm9ybShidWZmZXIsIHRyYW5zZm9ybSlcbi8vIHRha2VzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbmQgcmV0dXJucyBhIGphdmFzY3JpcHQgX09TQyBNZXNzYWdlXyByZXByZXNlbnRhdGlvbixcbi8vIGFuZCBhcHBsaWVzIHRoYXQgdG8gZWFjaCBtZXNzYWdlIGVuY29kZWQgaW4gdGhlIGJ1ZmZlcixcbi8vIGFuZCBvdXRwdXRzIGEgbmV3IGJ1ZmZlciB3aXRoIHRoZSBuZXcgYWRkcmVzcy5cbi8vXG4vLyBJZiB0aGUgYnVmZmVyIGVuY29kZXMgYW4gb3NjLWJ1bmRsZSwgdGhpcyBhcHBsaWVzIHRoZSBmdW5jdGlvbiB0byBlYWNoIG1lc3NhZ2UgXG4vLyBpbiB0aGUgYnVuZGxlLlxuLy9cbi8vIFNlZSBub3RlcyBhYm92ZSBmb3IgYXBwbHlBZGRyZXNzVHJhbnNmb3JtIGZvciB3aHkgeW91IG1pZ2h0IHdhbnQgdG8gdXNlIHRoaXMuXG4vLyBXaGlsZSB0aGlzIGRvZXMgcGFyc2UgYW5kIHJlLXBhY2sgdGhlIG1lc3NhZ2VzLCB0aGUgYnVuZGxlIHRpbWV0YWdzIGFyZSBsZWZ0XG4vLyBpbiB0aGVpciBhY2N1cmF0ZSBhbmQgcHJlc3RpbmUgc3RhdGUuXG4gIGV4cG9ydHMuYXBwbHlNZXNzYWdlVHJhbnNmb3JtID0gZnVuY3Rpb24oYnVmZmVyLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gdXRpbHMuYXBwbHlUcmFuc2Zvcm0oYnVmZmVyLCB1dGlscy5tZXNzYWdlVHJhbnNmb3JtKHRyYW5zZm9ybSkpO1xuICB9O1xuXG5cbi8vfmFwaX5cbi8vLS0tLVxuLy8jIyMgLnRpbWV0YWdUb0RhdGUobnRwVGltZVRhZylcbi8vIENvbnZlcnQgYSB0aW1ldGFnIGFycmF5IHRvIGEgSmF2YVNjcmlwdCBEYXRlIG9iamVjdCBpbiB5b3VyIGxvY2FsIHRpbWV6b25lLlxuLy9cbi8vIFJlY2VpdmVkIE9TQyBidW5kbGVzIGNvbnZlcnRlZCB3aXRoIGBmcm9tQnVmZmVyYCB3aWxsIGhhdmUgYSB0aW1ldGFnIGFycmF5OlxuLy8gW3NlY29uZHNTaW5jZTE5NzAsIGZyYWN0aW9uYWxTZWNvbmRzXVxuLy8gVGhpcyB1dGlsaXR5IGlzIHVzZWZ1bCBmb3IgbG9nZ2luZy4gQWNjdXJhY3kgaXMgcmVkdWNlZCB0byBtaWxsaXNlY29uZHMuXG4gIGV4cG9ydHMudGltZXRhZ1RvRGF0ZSA9IHV0aWxzLnRpbWV0YWdUb0RhdGU7XG5cbi8vfmFwaX5cbi8vLS0tLVxuLy8jIyMgLmRhdGVUb1RpbWV0YWcoZGF0ZSlcbi8vIENvbnZlcnQgYSBKYXZhU2NyaXB0IERhdGUgdG8gYSBOVFAgdGltZXRhZyBhcnJheSBbc2Vjb25kc1NpbmNlMTk3MCwgZnJhY3Rpb25hbFNlY29uZHNdLlxuLy9cbi8vIGB0b0J1ZmZlcmAgYWxyZWFkeSBhY2NlcHRzIERhdGVzIGZvciB0aW1ldGFncyBzbyB5b3UgbWlnaHQgbm90IG5lZWQgdGhpcyBmdW5jdGlvbi4gSWYgeW91IG5lZWQgdG8gc2NoZWR1bGUgYnVuZGxlcyB3aXRoIGZpbmVyIHRoYW4gbWlsbGlzZWNvbmQgYWNjdXJhY3kgdGhlbiB5b3UgY291bGQgdXNlIHRoaXMgdG8gaGVscCBhc3NlbWJsZSB0aGUgTlRQIGFycmF5LlxuICBleHBvcnRzLmRhdGVUb1RpbWV0YWcgPSB1dGlscy5kYXRlVG9UaW1ldGFnO1xuXG4vL35hcGl+XG4vLy0tLS1cbi8vIyMjIC50aW1ldGFnVG9UaW1lc3RhbXAodGltZVRhZylcbi8vIENvbnZlcnQgYSB0aW1ldGFnIGFycmF5IHRvIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSB0aGUgVU5JWCBlcG9jaC5cbi8vXG4gIGV4cG9ydHMudGltZXRhZ1RvVGltZXN0YW1wID0gdXRpbHMudGltZXRhZ1RvVGltZXN0YW1wO1xuXG4vL35hcGl+XG4vLy0tLS1cbi8vIyMjIC50aW1lc3RhbXBUb1RpbWV0YWcodGltZVN0YW1wKVxuLy8gQ29udmVydCBhIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIHRoZSBVTklYIGVwb2NoIHRvIGEgdGltZXRhZyBhcnJheS5cbi8vXG4gIGV4cG9ydHMudGltZXN0YW1wVG9UaW1ldGFnID0gdXRpbHMudGltZXN0YW1wVG9UaW1ldGFnO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIG9zY01pbiA9IHJlcXVpcmUoJ29zYy1taW4nKTtcblxuZnVuY3Rpb24gc2FuaXRpemVNZXNzYWdlKGRlY29kZWQpIHtcbiAgY29uc3QgbWVzc2FnZSA9IFtdO1xuICBtZXNzYWdlLnB1c2goZGVjb2RlZC5hZGRyZXNzKTtcbiAgZGVjb2RlZC5hcmdzLmZvckVhY2goYXJnID0+IHtcbiAgICBtZXNzYWdlLnB1c2goYXJnLnZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBtZXNzYWdlO1xufVxuXG5mdW5jdGlvbiBzYW5pdGl6ZUJ1bmRsZShkZWNvZGVkKSB7XG4gIGRlY29kZWQuZWxlbWVudHMgPSBkZWNvZGVkLmVsZW1lbnRzLm1hcChlbGVtZW50ID0+IHtcbiAgICBpZiAoZWxlbWVudC5vc2NUeXBlID09PSAnYnVuZGxlJykgcmV0dXJuIHNhbml0aXplQnVuZGxlKGVsZW1lbnQpO1xuICAgIGVsc2UgaWYgKGVsZW1lbnQub3NjVHlwZSA9PT0gJ21lc3NhZ2UnKSByZXR1cm4gc2FuaXRpemVNZXNzYWdlKGVsZW1lbnQpO1xuICB9KTtcbiAgcmV0dXJuIGRlY29kZWQ7XG59XG5cbmZ1bmN0aW9uIGRlY29kZShkYXRhKSB7XG4gIGNvbnN0IGRlY29kZWQgPSBvc2NNaW4uZnJvbUJ1ZmZlcihkYXRhKTtcbiAgaWYgKGRlY29kZWQub3NjVHlwZSA9PT0gJ2J1bmRsZScpIHtcbiAgICByZXR1cm4gc2FuaXRpemVCdW5kbGUoZGVjb2RlZCk7XG4gIH1cbiAgZWxzZSBpZiAoZGVjb2RlZC5vc2NUeXBlID09PSAnbWVzc2FnZScpIHtcbiAgICByZXR1cm4gc2FuaXRpemVNZXNzYWdlKGRlY29kZWQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvciAoJ01hbGZvcm1lZCBQYWNrZXQnKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBub2RlX2RncmFtID0gcmVxdWlyZSgnbm9kZTpkZ3JhbScpO1xudmFyIG5vZGVfZXZlbnRzID0gcmVxdWlyZSgnbm9kZTpldmVudHMnKTtcbnZhciBkZWNvZGUgPSByZXF1aXJlKCcjZGVjb2RlJyk7XG5cbmNsYXNzIFNlcnZlciBleHRlbmRzIG5vZGVfZXZlbnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKHBvcnQsIGhvc3Q9JzEyNy4wLjAuMScsIGNiKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAodHlwZW9mIGhvc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gaG9zdDtcbiAgICAgIGhvc3QgPSAnMTI3LjAuMC4xJztcbiAgICB9XG4gICAgaWYgKCFjYikgY2IgPSAoKSA9PiB7fTtcbiAgICBsZXQgZGVjb2RlZDtcbiAgICB0aGlzLnBvcnQgPSBwb3J0O1xuICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgdGhpcy5fc29jayA9IG5vZGVfZGdyYW0uY3JlYXRlU29ja2V0KHtcbiAgICAgIHR5cGU6ICd1ZHA0JyxcbiAgICAgIHJldXNlQWRkcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuX3NvY2suYmluZChwb3J0LCBob3N0KTtcbiAgICB0aGlzLl9zb2NrLm9uKCdsaXN0ZW5pbmcnLCAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ2xpc3RlbmluZycpO1xuICAgICAgY2IoKTtcbiAgICB9KTtcbiAgICB0aGlzLl9zb2NrLm9uKCdtZXNzYWdlJywgKG1zZywgcmluZm8pID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRlY29kZWQgPSBkZWNvZGUobXNnKTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBjYW4ndCBkZWNvZGUgaW5jb21pbmcgbWVzc2FnZTogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvciwgcmluZm8pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGVjb2RlZC5lbGVtZW50cykge1xuICAgICAgICB0aGlzLmVtaXQoJ2J1bmRsZScsIGRlY29kZWQsIHJpbmZvKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGRlY29kZWQpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGVjb2RlZCwgcmluZm8pO1xuICAgICAgICB0aGlzLmVtaXQoZGVjb2RlZFswXSwgZGVjb2RlZCwgcmluZm8pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNsb3NlKGNiKSB7XG4gICAgdGhpcy5fc29jay5jbG9zZShjYik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZXJ2ZXI7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9kZV9kZ3JhbSA9IHJlcXVpcmUoJ25vZGU6ZGdyYW0nKTtcbnZhciBvc2NNaW4gPSByZXF1aXJlKCdvc2MtbWluJyk7XG52YXIgTWVzc2FnZSA9IHJlcXVpcmUoJy4vTWVzc2FnZS5qcycpO1xuXG5jb25zdCB7IHRvQnVmZmVyIH0gPSBvc2NNaW47XG5cbmNsYXNzIENsaWVudCB7XG4gIGNvbnN0cnVjdG9yKGhvc3QsIHBvcnQpIHtcbiAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgIHRoaXMucG9ydCA9IHBvcnQ7XG4gICAgdGhpcy5fc29jayA9IG5vZGVfZGdyYW0uY3JlYXRlU29ja2V0KHtcbiAgICAgIHR5cGU6ICd1ZHA0JyxcbiAgICAgIHJldXNlQWRkcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGNsb3NlKGNiKSB7XG4gICAgdGhpcy5fc29jay5jbG9zZShjYik7XG4gIH1cbiAgc2VuZCguLi5hcmdzKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBhcmdzWzBdO1xuICAgIGxldCBjYWxsYmFjaztcbiAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbGxiYWNrID0gKCkgPT4ge307XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgbWVzc2FnZSA9IHtcbiAgICAgICAgYWRkcmVzczogbWVzc2FnZVswXSxcbiAgICAgICAgYXJnczogbWVzc2FnZS5zcGxpY2UoMSlcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIGxldCBtZXM7XG4gICAgbGV0IGJ1ZjtcbiAgICB0cnkge1xuICAgICAgc3dpdGNoICh0eXBlb2YgbWVzc2FnZSkge1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgIGJ1ZiA9IHRvQnVmZmVyKG1lc3NhZ2UpO1xuICAgICAgICAgIHRoaXMuX3NvY2suc2VuZChidWYsIDAsIGJ1Zi5sZW5ndGgsIHRoaXMucG9ydCwgdGhpcy5ob3N0LCBjYWxsYmFjayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgbWVzID0gbmV3IE1lc3NhZ2UoYXJnc1swXSk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtZXMuYXBwZW5kKGFyZ3NbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWYgPSB0b0J1ZmZlcihtZXMpO1xuICAgICAgICAgIHRoaXMuX3NvY2suc2VuZChidWYsIDAsIGJ1Zi5sZW5ndGgsIHRoaXMucG9ydCwgdGhpcy5ob3N0LCBjYWxsYmFjayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhhdCBNZXNzYWdlIEp1c3QgRG9lc25cXCd0IFNlZW0gUmlnaHQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLmNvZGUgIT09ICdFUlJfU09DS0VUX0RHUkFNX05PVF9SVU5OSU5HJykgdGhyb3cgZTtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IFJlZmVyZW5jZUVycm9yKCdDYW5ub3Qgc2VuZCBtZXNzYWdlIG9uIGNsb3NlZCBzb2NrZXQuJyk7XG4gICAgICBlcnJvci5jb2RlID0gZS5jb2RlO1xuICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENsaWVudDtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBNZXNzYWdlID0gcmVxdWlyZSgnLi9NZXNzYWdlLmpzJyk7XG52YXIgQnVuZGxlID0gcmVxdWlyZSgnLi9CdW5kbGUuanMnKTtcbnZhciBTZXJ2ZXIgPSByZXF1aXJlKCcuL1NlcnZlci5qcycpO1xudmFyIENsaWVudCA9IHJlcXVpcmUoJy4vQ2xpZW50LmpzJyk7XG5cblxuXG5leHBvcnRzLk1lc3NhZ2UgPSBNZXNzYWdlO1xuZXhwb3J0cy5CdW5kbGUgPSBCdW5kbGU7XG5leHBvcnRzLlNlcnZlciA9IFNlcnZlcjtcbmV4cG9ydHMuQ2xpZW50ID0gQ2xpZW50O1xuIiwgIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiIsICJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblx0XHRsZXQgbmFtZXNwYWNlc0NhY2hlO1xuXHRcdGxldCBlbmFibGVkQ2FjaGU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95OyAvLyBYWFggVGVtcG9yYXJ5LiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgJ2VuYWJsZWQnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoZW5hYmxlT3ZlcnJpZGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZW5hYmxlT3ZlcnJpZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcubmFtZXNwYWNlcykge1xuXHRcdFx0XHRcdG5hbWVzcGFjZXNDYWNoZSA9IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXM7XG5cdFx0XHRcdFx0ZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVuYWJsZWRDYWNoZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cdFx0Y3JlYXRlRGVidWcubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zbGljZSgxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQqIFhYWCBETyBOT1QgVVNFLiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHN0dWIgZnVuY3Rpb24uXG5cdCogWFhYIEl0IFdJTEwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHQqL1xuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIiwgIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRsZXQgbTtcblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiAobSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pKSAmJiBwYXJzZUludChtWzFdLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAoZmxhZywgYXJndiA9IHByb2Nlc3MuYXJndikgPT4ge1xuXHRjb25zdCBwcmVmaXggPSBmbGFnLnN0YXJ0c1dpdGgoJy0nKSA/ICcnIDogKGZsYWcubGVuZ3RoID09PSAxID8gJy0nIDogJy0tJyk7XG5cdGNvbnN0IHBvc2l0aW9uID0gYXJndi5pbmRleE9mKHByZWZpeCArIGZsYWcpO1xuXHRjb25zdCB0ZXJtaW5hdG9yUG9zaXRpb24gPSBhcmd2LmluZGV4T2YoJy0tJyk7XG5cdHJldHVybiBwb3NpdGlvbiAhPT0gLTEgJiYgKHRlcm1pbmF0b3JQb3NpdGlvbiA9PT0gLTEgfHwgcG9zaXRpb24gPCB0ZXJtaW5hdG9yUG9zaXRpb24pO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCB0dHkgPSByZXF1aXJlKCd0dHknKTtcbmNvbnN0IGhhc0ZsYWcgPSByZXF1aXJlKCdoYXMtZmxhZycpO1xuXG5jb25zdCB7ZW52fSA9IHByb2Nlc3M7XG5cbmxldCBmb3JjZUNvbG9yO1xuaWYgKGhhc0ZsYWcoJ25vLWNvbG9yJykgfHxcblx0aGFzRmxhZygnbm8tY29sb3JzJykgfHxcblx0aGFzRmxhZygnY29sb3I9ZmFsc2UnKSB8fFxuXHRoYXNGbGFnKCdjb2xvcj1uZXZlcicpKSB7XG5cdGZvcmNlQ29sb3IgPSAwO1xufSBlbHNlIGlmIChoYXNGbGFnKCdjb2xvcicpIHx8XG5cdGhhc0ZsYWcoJ2NvbG9ycycpIHx8XG5cdGhhc0ZsYWcoJ2NvbG9yPXRydWUnKSB8fFxuXHRoYXNGbGFnKCdjb2xvcj1hbHdheXMnKSkge1xuXHRmb3JjZUNvbG9yID0gMTtcbn1cblxuaWYgKCdGT1JDRV9DT0xPUicgaW4gZW52KSB7XG5cdGlmIChlbnYuRk9SQ0VfQ09MT1IgPT09ICd0cnVlJykge1xuXHRcdGZvcmNlQ29sb3IgPSAxO1xuXHR9IGVsc2UgaWYgKGVudi5GT1JDRV9DT0xPUiA9PT0gJ2ZhbHNlJykge1xuXHRcdGZvcmNlQ29sb3IgPSAwO1xuXHR9IGVsc2Uge1xuXHRcdGZvcmNlQ29sb3IgPSBlbnYuRk9SQ0VfQ09MT1IubGVuZ3RoID09PSAwID8gMSA6IE1hdGgubWluKHBhcnNlSW50KGVudi5GT1JDRV9DT0xPUiwgMTApLCAzKTtcblx0fVxufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVMZXZlbChsZXZlbCkge1xuXHRpZiAobGV2ZWwgPT09IDApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGxldmVsLFxuXHRcdGhhc0Jhc2ljOiB0cnVlLFxuXHRcdGhhczI1NjogbGV2ZWwgPj0gMixcblx0XHRoYXMxNm06IGxldmVsID49IDNcblx0fTtcbn1cblxuZnVuY3Rpb24gc3VwcG9ydHNDb2xvcihoYXZlU3RyZWFtLCBzdHJlYW1Jc1RUWSkge1xuXHRpZiAoZm9yY2VDb2xvciA9PT0gMCkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0aWYgKGhhc0ZsYWcoJ2NvbG9yPTE2bScpIHx8XG5cdFx0aGFzRmxhZygnY29sb3I9ZnVsbCcpIHx8XG5cdFx0aGFzRmxhZygnY29sb3I9dHJ1ZWNvbG9yJykpIHtcblx0XHRyZXR1cm4gMztcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcj0yNTYnKSkge1xuXHRcdHJldHVybiAyO1xuXHR9XG5cblx0aWYgKGhhdmVTdHJlYW0gJiYgIXN0cmVhbUlzVFRZICYmIGZvcmNlQ29sb3IgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Y29uc3QgbWluID0gZm9yY2VDb2xvciB8fCAwO1xuXG5cdGlmIChlbnYuVEVSTSA9PT0gJ2R1bWInKSB7XG5cdFx0cmV0dXJuIG1pbjtcblx0fVxuXG5cdGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG5cdFx0Ly8gV2luZG93cyAxMCBidWlsZCAxMDU4NiBpcyB0aGUgZmlyc3QgV2luZG93cyByZWxlYXNlIHRoYXQgc3VwcG9ydHMgMjU2IGNvbG9ycy5cblx0XHQvLyBXaW5kb3dzIDEwIGJ1aWxkIDE0OTMxIGlzIHRoZSBmaXJzdCByZWxlYXNlIHRoYXQgc3VwcG9ydHMgMTZtL1RydWVDb2xvci5cblx0XHRjb25zdCBvc1JlbGVhc2UgPSBvcy5yZWxlYXNlKCkuc3BsaXQoJy4nKTtcblx0XHRpZiAoXG5cdFx0XHROdW1iZXIob3NSZWxlYXNlWzBdKSA+PSAxMCAmJlxuXHRcdFx0TnVtYmVyKG9zUmVsZWFzZVsyXSkgPj0gMTA1ODZcblx0XHQpIHtcblx0XHRcdHJldHVybiBOdW1iZXIob3NSZWxlYXNlWzJdKSA+PSAxNDkzMSA/IDMgOiAyO1xuXHRcdH1cblxuXHRcdHJldHVybiAxO1xuXHR9XG5cblx0aWYgKCdDSScgaW4gZW52KSB7XG5cdFx0aWYgKFsnVFJBVklTJywgJ0NJUkNMRUNJJywgJ0FQUFZFWU9SJywgJ0dJVExBQl9DSScsICdHSVRIVUJfQUNUSU9OUycsICdCVUlMREtJVEUnXS5zb21lKHNpZ24gPT4gc2lnbiBpbiBlbnYpIHx8IGVudi5DSV9OQU1FID09PSAnY29kZXNoaXAnKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWluO1xuXHR9XG5cblx0aWYgKCdURUFNQ0lUWV9WRVJTSU9OJyBpbiBlbnYpIHtcblx0XHRyZXR1cm4gL14oOVxcLigwKlsxLTldXFxkKilcXC58XFxkezIsfVxcLikvLnRlc3QoZW52LlRFQU1DSVRZX1ZFUlNJT04pID8gMSA6IDA7XG5cdH1cblxuXHRpZiAoZW52LkNPTE9SVEVSTSA9PT0gJ3RydWVjb2xvcicpIHtcblx0XHRyZXR1cm4gMztcblx0fVxuXG5cdGlmICgnVEVSTV9QUk9HUkFNJyBpbiBlbnYpIHtcblx0XHRjb25zdCB2ZXJzaW9uID0gcGFyc2VJbnQoKGVudi5URVJNX1BST0dSQU1fVkVSU0lPTiB8fCAnJykuc3BsaXQoJy4nKVswXSwgMTApO1xuXG5cdFx0c3dpdGNoIChlbnYuVEVSTV9QUk9HUkFNKSB7XG5cdFx0XHRjYXNlICdpVGVybS5hcHAnOlxuXHRcdFx0XHRyZXR1cm4gdmVyc2lvbiA+PSAzID8gMyA6IDI7XG5cdFx0XHRjYXNlICdBcHBsZV9UZXJtaW5hbCc6XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0Ly8gTm8gZGVmYXVsdFxuXHRcdH1cblx0fVxuXG5cdGlmICgvLTI1Nihjb2xvcik/JC9pLnRlc3QoZW52LlRFUk0pKSB7XG5cdFx0cmV0dXJuIDI7XG5cdH1cblxuXHRpZiAoL15zY3JlZW58Xnh0ZXJtfF52dDEwMHxednQyMjB8XnJ4dnR8Y29sb3J8YW5zaXxjeWd3aW58bGludXgvaS50ZXN0KGVudi5URVJNKSkge1xuXHRcdHJldHVybiAxO1xuXHR9XG5cblx0aWYgKCdDT0xPUlRFUk0nIGluIGVudikge1xuXHRcdHJldHVybiAxO1xuXHR9XG5cblx0cmV0dXJuIG1pbjtcbn1cblxuZnVuY3Rpb24gZ2V0U3VwcG9ydExldmVsKHN0cmVhbSkge1xuXHRjb25zdCBsZXZlbCA9IHN1cHBvcnRzQ29sb3Ioc3RyZWFtLCBzdHJlYW0gJiYgc3RyZWFtLmlzVFRZKTtcblx0cmV0dXJuIHRyYW5zbGF0ZUxldmVsKGxldmVsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdHN1cHBvcnRzQ29sb3I6IGdldFN1cHBvcnRMZXZlbCxcblx0c3Rkb3V0OiB0cmFuc2xhdGVMZXZlbChzdXBwb3J0c0NvbG9yKHRydWUsIHR0eS5pc2F0dHkoMSkpKSxcblx0c3RkZXJyOiB0cmFuc2xhdGVMZXZlbChzdXBwb3J0c0NvbG9yKHRydWUsIHR0eS5pc2F0dHkoMikpKVxufTtcbiIsICIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIE5vZGUuanMgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5kZXN0cm95ID0gdXRpbC5kZXByZWNhdGUoXG5cdCgpID0+IHt9LFxuXHQnSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLidcbik7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWzYsIDIsIDMsIDQsIDUsIDFdO1xuXG50cnkge1xuXHQvLyBPcHRpb25hbCBkZXBlbmRlbmN5IChhcyBpbiwgZG9lc24ndCBuZWVkIHRvIGJlIGluc3RhbGxlZCwgTk9UIGxpa2Ugb3B0aW9uYWxEZXBlbmRlbmNpZXMgaW4gcGFja2FnZS5qc29uKVxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5cdGNvbnN0IHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xuXG5cdGlmIChzdXBwb3J0c0NvbG9yICYmIChzdXBwb3J0c0NvbG9yLnN0ZGVyciB8fCBzdXBwb3J0c0NvbG9yKS5sZXZlbCA+PSAyKSB7XG5cdFx0ZXhwb3J0cy5jb2xvcnMgPSBbXG5cdFx0XHQyMCxcblx0XHRcdDIxLFxuXHRcdFx0MjYsXG5cdFx0XHQyNyxcblx0XHRcdDMyLFxuXHRcdFx0MzMsXG5cdFx0XHQzOCxcblx0XHRcdDM5LFxuXHRcdFx0NDAsXG5cdFx0XHQ0MSxcblx0XHRcdDQyLFxuXHRcdFx0NDMsXG5cdFx0XHQ0NCxcblx0XHRcdDQ1LFxuXHRcdFx0NTYsXG5cdFx0XHQ1Nyxcblx0XHRcdDYyLFxuXHRcdFx0NjMsXG5cdFx0XHQ2OCxcblx0XHRcdDY5LFxuXHRcdFx0NzQsXG5cdFx0XHQ3NSxcblx0XHRcdDc2LFxuXHRcdFx0NzcsXG5cdFx0XHQ3OCxcblx0XHRcdDc5LFxuXHRcdFx0ODAsXG5cdFx0XHQ4MSxcblx0XHRcdDkyLFxuXHRcdFx0OTMsXG5cdFx0XHQ5OCxcblx0XHRcdDk5LFxuXHRcdFx0MTEyLFxuXHRcdFx0MTEzLFxuXHRcdFx0MTI4LFxuXHRcdFx0MTI5LFxuXHRcdFx0MTM0LFxuXHRcdFx0MTM1LFxuXHRcdFx0MTQ4LFxuXHRcdFx0MTQ5LFxuXHRcdFx0MTYwLFxuXHRcdFx0MTYxLFxuXHRcdFx0MTYyLFxuXHRcdFx0MTYzLFxuXHRcdFx0MTY0LFxuXHRcdFx0MTY1LFxuXHRcdFx0MTY2LFxuXHRcdFx0MTY3LFxuXHRcdFx0MTY4LFxuXHRcdFx0MTY5LFxuXHRcdFx0MTcwLFxuXHRcdFx0MTcxLFxuXHRcdFx0MTcyLFxuXHRcdFx0MTczLFxuXHRcdFx0MTc4LFxuXHRcdFx0MTc5LFxuXHRcdFx0MTg0LFxuXHRcdFx0MTg1LFxuXHRcdFx0MTk2LFxuXHRcdFx0MTk3LFxuXHRcdFx0MTk4LFxuXHRcdFx0MTk5LFxuXHRcdFx0MjAwLFxuXHRcdFx0MjAxLFxuXHRcdFx0MjAyLFxuXHRcdFx0MjAzLFxuXHRcdFx0MjA0LFxuXHRcdFx0MjA1LFxuXHRcdFx0MjA2LFxuXHRcdFx0MjA3LFxuXHRcdFx0MjA4LFxuXHRcdFx0MjA5LFxuXHRcdFx0MjE0LFxuXHRcdFx0MjE1LFxuXHRcdFx0MjIwLFxuXHRcdFx0MjIxXG5cdFx0XTtcblx0fVxufSBjYXRjaCAoZXJyb3IpIHtcblx0Ly8gU3dhbGxvdyAtIHdlIG9ubHkgY2FyZSBpZiBgc3VwcG9ydHMtY29sb3JgIGlzIGF2YWlsYWJsZTsgaXQgZG9lc24ndCBoYXZlIHRvIGJlLlxufVxuXG4vKipcbiAqIEJ1aWxkIHVwIHRoZSBkZWZhdWx0IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiAgICQgREVCVUdfQ09MT1JTPW5vIERFQlVHX0RFUFRIPTEwIERFQlVHX1NIT1dfSElEREVOPWVuYWJsZWQgbm9kZSBzY3JpcHQuanNcbiAqL1xuXG5leHBvcnRzLmluc3BlY3RPcHRzID0gT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpLmZpbHRlcihrZXkgPT4ge1xuXHRyZXR1cm4gL15kZWJ1Z18vaS50ZXN0KGtleSk7XG59KS5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG5cdC8vIENhbWVsLWNhc2Vcblx0Y29uc3QgcHJvcCA9IGtleVxuXHRcdC5zdWJzdHJpbmcoNilcblx0XHQudG9Mb3dlckNhc2UoKVxuXHRcdC5yZXBsYWNlKC9fKFthLXpdKS9nLCAoXywgaykgPT4ge1xuXHRcdFx0cmV0dXJuIGsudG9VcHBlckNhc2UoKTtcblx0XHR9KTtcblxuXHQvLyBDb2VyY2Ugc3RyaW5nIHZhbHVlIGludG8gSlMgdmFsdWVcblx0bGV0IHZhbCA9IHByb2Nlc3MuZW52W2tleV07XG5cdGlmICgvXih5ZXN8b258dHJ1ZXxlbmFibGVkKSQvaS50ZXN0KHZhbCkpIHtcblx0XHR2YWwgPSB0cnVlO1xuXHR9IGVsc2UgaWYgKC9eKG5vfG9mZnxmYWxzZXxkaXNhYmxlZCkkL2kudGVzdCh2YWwpKSB7XG5cdFx0dmFsID0gZmFsc2U7XG5cdH0gZWxzZSBpZiAodmFsID09PSAnbnVsbCcpIHtcblx0XHR2YWwgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdHZhbCA9IE51bWJlcih2YWwpO1xuXHR9XG5cblx0b2JqW3Byb3BdID0gdmFsO1xuXHRyZXR1cm4gb2JqO1xufSwge30pO1xuXG4vKipcbiAqIElzIHN0ZG91dCBhIFRUWT8gQ29sb3JlZCBvdXRwdXQgaXMgZW5hYmxlZCB3aGVuIGB0cnVlYC5cbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdHJldHVybiAnY29sb3JzJyBpbiBleHBvcnRzLmluc3BlY3RPcHRzID9cblx0XHRCb29sZWFuKGV4cG9ydHMuaW5zcGVjdE9wdHMuY29sb3JzKSA6XG5cdFx0dHR5LmlzYXR0eShwcm9jZXNzLnN0ZGVyci5mZCk7XG59XG5cbi8qKlxuICogQWRkcyBBTlNJIGNvbG9yIGVzY2FwZSBjb2RlcyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGNvbnN0IHtuYW1lc3BhY2U6IG5hbWUsIHVzZUNvbG9yc30gPSB0aGlzO1xuXG5cdGlmICh1c2VDb2xvcnMpIHtcblx0XHRjb25zdCBjID0gdGhpcy5jb2xvcjtcblx0XHRjb25zdCBjb2xvckNvZGUgPSAnXFx1MDAxQlszJyArIChjIDwgOCA/IGMgOiAnODs1OycgKyBjKTtcblx0XHRjb25zdCBwcmVmaXggPSBgICAke2NvbG9yQ29kZX07MW0ke25hbWV9IFxcdTAwMUJbMG1gO1xuXG5cdFx0YXJnc1swXSA9IHByZWZpeCArIGFyZ3NbMF0uc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbicgKyBwcmVmaXgpO1xuXHRcdGFyZ3MucHVzaChjb2xvckNvZGUgKyAnbSsnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKSArICdcXHUwMDFCWzBtJyk7XG5cdH0gZWxzZSB7XG5cdFx0YXJnc1swXSA9IGdldERhdGUoKSArIG5hbWUgKyAnICcgKyBhcmdzWzBdO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldERhdGUoKSB7XG5cdGlmIChleHBvcnRzLmluc3BlY3RPcHRzLmhpZGVEYXRlKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cdHJldHVybiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyAnICc7XG59XG5cbi8qKlxuICogSW52b2tlcyBgdXRpbC5mb3JtYXRXaXRoT3B0aW9ucygpYCB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzIGFuZCB3cml0ZXMgdG8gc3RkZXJyLlxuICovXG5cbmZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XG5cdHJldHVybiBwcm9jZXNzLnN0ZGVyci53cml0ZSh1dGlsLmZvcm1hdFdpdGhPcHRpb25zKGV4cG9ydHMuaW5zcGVjdE9wdHMsIC4uLmFyZ3MpICsgJ1xcbicpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0cHJvY2Vzcy5lbnYuREVCVUcgPSBuYW1lc3BhY2VzO1xuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHlvdSBzZXQgYSBwcm9jZXNzLmVudiBmaWVsZCB0byBudWxsIG9yIHVuZGVmaW5lZCwgaXQgZ2V0cyBjYXN0IHRvIHRoZVxuXHRcdC8vIHN0cmluZyAnbnVsbCcgb3IgJ3VuZGVmaW5lZCcuIEp1c3QgZGVsZXRlIGluc3RlYWQuXG5cdFx0ZGVsZXRlIHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcblx0cmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xufVxuXG4vKipcbiAqIEluaXQgbG9naWMgZm9yIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICpcbiAqIENyZWF0ZSBhIG5ldyBgaW5zcGVjdE9wdHNgIG9iamVjdCBpbiBjYXNlIGB1c2VDb2xvcnNgIGlzIHNldFxuICogZGlmZmVyZW50bHkgZm9yIGEgcGFydGljdWxhciBgZGVidWdgIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGluaXQoZGVidWcpIHtcblx0ZGVidWcuaW5zcGVjdE9wdHMgPSB7fTtcblxuXHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5pbnNwZWN0T3B0cyk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdGRlYnVnLmluc3BlY3RPcHRzW2tleXNbaV1dID0gZXhwb3J0cy5pbnNwZWN0T3B0c1trZXlzW2ldXTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlbyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGwgb24gYSBzaW5nbGUgbGluZS5cbiAqL1xuXG5mb3JtYXR0ZXJzLm8gPSBmdW5jdGlvbiAodikge1xuXHR0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXHRyZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpXG5cdFx0LnNwbGl0KCdcXG4nKVxuXHRcdC5tYXAoc3RyID0+IHN0ci50cmltKCkpXG5cdFx0LmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogTWFwICVPIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbG93aW5nIG11bHRpcGxlIGxpbmVzIGlmIG5lZWRlZC5cbiAqL1xuXG5mb3JtYXR0ZXJzLk8gPSBmdW5jdGlvbiAodikge1xuXHR0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXHRyZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpO1xufTtcbiIsICIvKipcbiAqIERldGVjdCBFbGVjdHJvbiByZW5kZXJlciAvIG53anMgcHJvY2Vzcywgd2hpY2ggaXMgbm9kZSwgYnV0IHdlIHNob3VsZFxuICogdHJlYXQgYXMgYSBicm93c2VyLlxuICovXG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHByb2Nlc3MuYnJvd3NlciA9PT0gdHJ1ZSB8fCBwcm9jZXNzLl9fbndqcykge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYnJvd3Nlci5qcycpO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL25vZGUuanMnKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcbiAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcbiAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG4gICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCSU5BUllfVFlQRVMgPSBbJ25vZGVidWZmZXInLCAnYXJyYXlidWZmZXInLCAnZnJhZ21lbnRzJ107XG5jb25zdCBoYXNCbG9iID0gdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnO1xuXG5pZiAoaGFzQmxvYikgQklOQVJZX1RZUEVTLnB1c2goJ2Jsb2InKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEJJTkFSWV9UWVBFUyxcbiAgRU1QVFlfQlVGRkVSOiBCdWZmZXIuYWxsb2MoMCksXG4gIEdVSUQ6ICcyNThFQUZBNS1FOTE0LTQ3REEtOTVDQS1DNUFCMERDODVCMTEnLFxuICBoYXNCbG9iLFxuICBrRm9yT25FdmVudEF0dHJpYnV0ZTogU3ltYm9sKCdrSXNGb3JPbkV2ZW50QXR0cmlidXRlJyksXG4gIGtMaXN0ZW5lcjogU3ltYm9sKCdrTGlzdGVuZXInKSxcbiAga1N0YXR1c0NvZGU6IFN5bWJvbCgnc3RhdHVzLWNvZGUnKSxcbiAga1dlYlNvY2tldDogU3ltYm9sKCd3ZWJzb2NrZXQnKSxcbiAgTk9PUDogKCkgPT4ge31cbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IEVNUFRZX0JVRkZFUiB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XG5cbi8qKlxuICogTWVyZ2VzIGFuIGFycmF5IG9mIGJ1ZmZlcnMgaW50byBhIG5ldyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJbXX0gbGlzdCBUaGUgYXJyYXkgb2YgYnVmZmVycyB0byBjb25jYXRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbExlbmd0aCBUaGUgdG90YWwgbGVuZ3RoIG9mIGJ1ZmZlcnMgaW4gdGhlIGxpc3RcbiAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIHJlc3VsdGluZyBidWZmZXJcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY29uY2F0KGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIEVNUFRZX0JVRkZFUjtcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSByZXR1cm4gbGlzdFswXTtcblxuICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBidWYgPSBsaXN0W2ldO1xuICAgIHRhcmdldC5zZXQoYnVmLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBidWYubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG9mZnNldCA8IHRvdGFsTGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKHRhcmdldC5idWZmZXIsIHRhcmdldC5ieXRlT2Zmc2V0LCBvZmZzZXQpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBNYXNrcyBhIGJ1ZmZlciB1c2luZyB0aGUgZ2l2ZW4gbWFzay5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc291cmNlIFRoZSBidWZmZXIgdG8gbWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gb3V0cHV0IFRoZSBidWZmZXIgd2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHdyaXRpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIG51bWJlciBvZiBieXRlcyB0byBtYXNrLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBfbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHNvdXJjZVtpXSBeIG1hc2tbaSAmIDNdO1xuICB9XG59XG5cbi8qKlxuICogVW5tYXNrcyBhIGJ1ZmZlciB1c2luZyB0aGUgZ2l2ZW4gbWFzay5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gdW5tYXNrXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWFzayBUaGUgbWFzayB0byB1c2VcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX3VubWFzayhidWZmZXIsIG1hc2spIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBidWZmZXJbaV0gXj0gbWFza1tpICYgM107XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhbiBgQXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgVGhlIGJ1ZmZlciB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gQ29udmVydGVkIGJ1ZmZlclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b0FycmF5QnVmZmVyKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gYnVmLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJ1Zi5idWZmZXI7XG4gIH1cblxuICByZXR1cm4gYnVmLmJ1ZmZlci5zbGljZShidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVPZmZzZXQgKyBidWYubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZGF0YWAgdG8gYSBgQnVmZmVyYC5cbiAqXG4gKiBAcGFyYW0geyp9IGRhdGEgVGhlIGRhdGEgdG8gY29udmVydFxuICogQHJldHVybiB7QnVmZmVyfSBUaGUgYnVmZmVyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvQnVmZmVyKGRhdGEpIHtcbiAgdG9CdWZmZXIucmVhZE9ubHkgPSB0cnVlO1xuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHJldHVybiBkYXRhO1xuXG4gIGxldCBidWY7XG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIGJ1ZiA9IG5ldyBGYXN0QnVmZmVyKGRhdGEpO1xuICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIGJ1ZiA9IG5ldyBGYXN0QnVmZmVyKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgYnVmID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgdG9CdWZmZXIucmVhZE9ubHkgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBidWY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb25jYXQsXG4gIG1hc2s6IF9tYXNrLFxuICB0b0FycmF5QnVmZmVyLFxuICB0b0J1ZmZlcixcbiAgdW5tYXNrOiBfdW5tYXNrXG59O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cbmlmICghcHJvY2Vzcy5lbnYuV1NfTk9fQlVGRkVSX1VUSUwpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBidWZmZXJVdGlsID0gcmVxdWlyZSgnYnVmZmVydXRpbCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMubWFzayA9IGZ1bmN0aW9uIChzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggPCA0OCkgX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGVsc2UgYnVmZmVyVXRpbC5tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzLnVubWFzayA9IGZ1bmN0aW9uIChidWZmZXIsIG1hc2spIHtcbiAgICAgIGlmIChidWZmZXIubGVuZ3RoIDwgMzIpIF91bm1hc2soYnVmZmVyLCBtYXNrKTtcbiAgICAgIGVsc2UgYnVmZmVyVXRpbC51bm1hc2soYnVmZmVyLCBtYXNrKTtcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gQ29udGludWUgcmVnYXJkbGVzcyBvZiB0aGUgZXJyb3IuXG4gIH1cbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGtEb25lID0gU3ltYm9sKCdrRG9uZScpO1xuY29uc3Qga1J1biA9IFN5bWJvbCgna1J1bicpO1xuXG4vKipcbiAqIEEgdmVyeSBzaW1wbGUgam9iIHF1ZXVlIHdpdGggYWRqdXN0YWJsZSBjb25jdXJyZW5jeS4gQWRhcHRlZCBmcm9tXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU1RSTUwvYXN5bmMtbGltaXRlclxuICovXG5jbGFzcyBMaW1pdGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYExpbWl0ZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmN1cnJlbmN5PUluZmluaXR5XSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygam9icyBhbGxvd2VkXG4gICAqICAgICB0byBydW4gY29uY3VycmVudGx5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25jdXJyZW5jeSkge1xuICAgIHRoaXNba0RvbmVdID0gKCkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nLS07XG4gICAgICB0aGlzW2tSdW5dKCk7XG4gICAgfTtcbiAgICB0aGlzLmNvbmN1cnJlbmN5ID0gY29uY3VycmVuY3kgfHwgSW5maW5pdHk7XG4gICAgdGhpcy5qb2JzID0gW107XG4gICAgdGhpcy5wZW5kaW5nID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgam9iIHRvIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gam9iIFRoZSBqb2IgdG8gcnVuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZChqb2IpIHtcbiAgICB0aGlzLmpvYnMucHVzaChqb2IpO1xuICAgIHRoaXNba1J1bl0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgam9iIGZyb20gdGhlIHF1ZXVlIGFuZCBydW5zIGl0IGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgW2tSdW5dKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmcgPT09IHRoaXMuY29uY3VycmVuY3kpIHJldHVybjtcblxuICAgIGlmICh0aGlzLmpvYnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBqb2IgPSB0aGlzLmpvYnMuc2hpZnQoKTtcblxuICAgICAgdGhpcy5wZW5kaW5nKys7XG4gICAgICBqb2IodGhpc1trRG9uZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbWl0ZXI7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB6bGliID0gcmVxdWlyZSgnemxpYicpO1xuXG5jb25zdCBidWZmZXJVdGlsID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuY29uc3QgTGltaXRlciA9IHJlcXVpcmUoJy4vbGltaXRlcicpO1xuY29uc3QgeyBrU3RhdHVzQ29kZSB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XG5jb25zdCBUUkFJTEVSID0gQnVmZmVyLmZyb20oWzB4MDAsIDB4MDAsIDB4ZmYsIDB4ZmZdKTtcbmNvbnN0IGtQZXJNZXNzYWdlRGVmbGF0ZSA9IFN5bWJvbCgncGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBrVG90YWxMZW5ndGggPSBTeW1ib2woJ3RvdGFsLWxlbmd0aCcpO1xuY29uc3Qga0NhbGxiYWNrID0gU3ltYm9sKCdjYWxsYmFjaycpO1xuY29uc3Qga0J1ZmZlcnMgPSBTeW1ib2woJ2J1ZmZlcnMnKTtcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcblxuLy9cbi8vIFdlIGxpbWl0IHpsaWIgY29uY3VycmVuY3ksIHdoaWNoIHByZXZlbnRzIHNldmVyZSBtZW1vcnkgZnJhZ21lbnRhdGlvblxuLy8gYXMgZG9jdW1lbnRlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzg4NzEjaXNzdWVjb21tZW50LTI1MDkxNTkxM1xuLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xMjAyXG4vL1xuLy8gSW50ZW50aW9uYWxseSBnbG9iYWw7IGl0J3MgdGhlIGdsb2JhbCB0aHJlYWQgcG9vbCB0aGF0J3MgYW4gaXNzdWUuXG4vL1xubGV0IHpsaWJMaW1pdGVyO1xuXG4vKipcbiAqIHBlcm1lc3NhZ2UtZGVmbGF0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgUGVyTWVzc2FnZURlZmxhdGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFBlck1lc3NhZ2VEZWZsYXRlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHNdIEFkdmVydGlzZSBzdXBwb3J0XG4gICAqICAgICBmb3IsIG9yIHJlcXVlc3QsIGEgY3VzdG9tIGNsaWVudCB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyPWZhbHNlXSBBZHZlcnRpc2UvXG4gICAqICAgICBhY2tub3dsZWRnZSBkaXNhYmxpbmcgb2YgY2xpZW50IGNvbnRleHQgdGFrZW92ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbmN1cnJlbmN5TGltaXQ9MTBdIFRoZSBudW1iZXIgb2YgY29uY3VycmVudFxuICAgKiAgICAgY2FsbHMgdG8gemxpYlxuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHNdIFJlcXVlc3QvY29uZmlybSB0aGVcbiAgICogICAgIHVzZSBvZiBhIGN1c3RvbSBzZXJ2ZXIgd2luZG93IHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gUmVxdWVzdC9hY2NlcHRcbiAgICogICAgIGRpc2FibGluZyBvZiBzZXJ2ZXIgY29udGV4dCB0YWtlb3ZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGhyZXNob2xkPTEwMjRdIFNpemUgKGluIGJ5dGVzKSBiZWxvdyB3aGljaFxuICAgKiAgICAgbWVzc2FnZXMgc2hvdWxkIG5vdCBiZSBjb21wcmVzc2VkIGlmIGNvbnRleHQgdGFrZW92ZXIgaXMgZGlzYWJsZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cbiAgICogICAgIGRlZmxhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cbiAgICogICAgIGluZmxhdGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaXNTZXJ2ZXI9ZmFsc2VdIENyZWF0ZSB0aGUgaW5zdGFuY2UgaW4gZWl0aGVyIHNlcnZlciBvclxuICAgKiAgICAgY2xpZW50IG1vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlzU2VydmVyLCBtYXhQYXlsb2FkKSB7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX3RocmVzaG9sZCA9XG4gICAgICB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgOiAxMDI0O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFpc1NlcnZlcjtcbiAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcbiAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcblxuICAgIHRoaXMucGFyYW1zID0gbnVsbDtcblxuICAgIGlmICghemxpYkxpbWl0ZXIpIHtcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5ID1cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdFxuICAgICAgICAgIDogMTA7XG4gICAgICB6bGliTGltaXRlciA9IG5ldyBMaW1pdGVyKGNvbmN1cnJlbmN5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZXh0ZW5zaW9uTmFtZSgpIHtcbiAgICByZXR1cm4gJ3Blcm1lc3NhZ2UtZGVmbGF0ZSc7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBFeHRlbnNpb24gcGFyYW1ldGVyc1xuICAgKiBAcHVibGljXG4gICAqL1xuICBvZmZlcigpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7fTtcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09IG51bGwpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIvcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFjY2VwdChjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zID0gdGhpcy5ub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpO1xuXG4gICAgdGhpcy5wYXJhbXMgPSB0aGlzLl9pc1NlcnZlclxuICAgICAgPyB0aGlzLmFjY2VwdEFzU2VydmVyKGNvbmZpZ3VyYXRpb25zKVxuICAgICAgOiB0aGlzLmFjY2VwdEFzQ2xpZW50KGNvbmZpZ3VyYXRpb25zKTtcblxuICAgIHJldHVybiB0aGlzLnBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbGwgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGV4dGVuc2lvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5faW5mbGF0ZSkge1xuICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQnXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAgQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gb2ZmZXJzIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNTZXJ2ZXIob2ZmZXJzKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMuX29wdGlvbnM7XG4gICAgY29uc3QgYWNjZXB0ZWQgPSBvZmZlcnMuZmluZCgocGFyYW1zKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxuICAgICAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcikgfHxcbiAgICAgICAgKHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzICYmXG4gICAgICAgICAgKG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPiBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cykpKSB8fFxuICAgICAgICAodHlwZW9mIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAhcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGlmICghYWNjZXB0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9uZSBvZiB0aGUgZXh0ZW5zaW9uIG9mZmVycyBjYW4gYmUgYWNjZXB0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0cy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9IG9wdHMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9PT0gdHJ1ZSB8fFxuICAgICAgb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBmYWxzZVxuICAgICkge1xuICAgICAgZGVsZXRlIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY2VwdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCB0aGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSByZXNwb25zZSBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNDbGllbnQocmVzcG9uc2UpIHtcbiAgICBjb25zdCBwYXJhbXMgPSByZXNwb25zZVswXTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBwYXJhbWV0ZXIgXCJjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclwiJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cykge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XG4gICAgICAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdVbmV4cGVjdGVkIG9yIGludmFsaWQgcGFyYW1ldGVyIFwiY2xpZW50X21heF93aW5kb3dfYml0c1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgb2ZmZXJzL3Jlc3BvbnNlIHdpdGggbm9ybWFsaXplZCBwYXJhbWV0ZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9ucy5mb3JFYWNoKChwYXJhbXMpID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJhbWV0ZXIgXCIke2tleX1cIiBtdXN0IGhhdmUgb25seSBhIHNpbmdsZSB2YWx1ZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnY2xpZW50X21heF93aW5kb3dfYml0cycpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzJykge1xuICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobnVtKSB8fCBudW0gPCA4IHx8IG51bSA+IDE1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXInIHx8XG4gICAgICAgICAga2V5ID09PSAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJhbWV0ZXIgXCIke2tleX1cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fZGVjb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnY2xpZW50JyA6ICdzZXJ2ZXInO1xuXG4gICAgaWYgKCF0aGlzLl9pbmZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2luZmxhdGUgPSB6bGliLmNyZWF0ZUluZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tQZXJNZXNzYWdlRGVmbGF0ZV0gPSB0aGlzO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKCdlcnJvcicsIGluZmxhdGVPbkVycm9yKTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbmZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcblxuICAgIHRoaXMuX2luZmxhdGUud3JpdGUoZGF0YSk7XG4gICAgaWYgKGZpbikgdGhpcy5faW5mbGF0ZS53cml0ZShUUkFJTEVSKTtcblxuICAgIHRoaXMuX2luZmxhdGUuZmx1c2goKCkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gdGhpcy5faW5mbGF0ZVtrRXJyb3JdO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSxcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdXG4gICAgICApO1xuXG4gICAgICBpZiAodGhpcy5faW5mbGF0ZS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICAgIHRoaXMuX2luZmxhdGUucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wcmVzcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnc2VydmVyJyA6ICdjbGllbnQnO1xuXG4gICAgaWYgKCF0aGlzLl9kZWZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUgPSB6bGliLmNyZWF0ZURlZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlLm9uKCdkYXRhJywgZGVmbGF0ZU9uRGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG5cbiAgICB0aGlzLl9kZWZsYXRlLndyaXRlKGRhdGEpO1xuICAgIHRoaXMuX2RlZmxhdGUuZmx1c2goemxpYi5aX1NZTkNfRkxVU0gsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQuXG4gICAgICAgIC8vXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcblxuICAgICAgaWYgKGZpbikge1xuICAgICAgICBkYXRhID0gbmV3IEZhc3RCdWZmZXIoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5sZW5ndGggLSA0KTtcbiAgICAgIH1cblxuICAgICAgLy9cbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBjYWxsYmFjayB3aWxsIG5vdCBiZSBjYWxsZWQgYWdhaW4gaW5cbiAgICAgIC8vIGBQZXJNZXNzYWdlRGVmbGF0ZSNjbGVhbnVwKClgLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXSA9IG51bGw7XG5cbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcbiAgICAgICAgdGhpcy5fZGVmbGF0ZS5yZXNldCgpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlck1lc3NhZ2VEZWZsYXRlO1xuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuRGVmbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVPbkRhdGEoY2h1bmspIHtcbiAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZU9uRGF0YShjaHVuaykge1xuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xuXG4gIGlmIChcbiAgICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWQgPCAxIHx8XG4gICAgdGhpc1trVG90YWxMZW5ndGhdIDw9IHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5fbWF4UGF5bG9hZFxuICApIHtcbiAgICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzW2tFcnJvcl0gPSBuZXcgUmFuZ2VFcnJvcignTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcpO1xuICB0aGlzW2tFcnJvcl0uY29kZSA9ICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnO1xuICB0aGlzW2tFcnJvcl1ba1N0YXR1c0NvZGVdID0gMTAwOTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xuICB0aGlzLnJlc2V0KCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZU9uRXJyb3IoZXJyKSB7XG4gIC8vXG4gIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBgWmxpYiNjbG9zZSgpYCBhcyB0aGUgaGFuZGxlIGlzIGF1dG9tYXRpY2FsbHlcbiAgLy8gY2xvc2VkIHdoZW4gYW4gZXJyb3IgaXMgZW1pdHRlZC5cbiAgLy9cbiAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9pbmZsYXRlID0gbnVsbDtcbiAgZXJyW2tTdGF0dXNDb2RlXSA9IDEwMDc7XG4gIHRoaXNba0NhbGxiYWNrXShlcnIpO1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBpc1V0ZjggfSA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xuXG5jb25zdCB7IGhhc0Jsb2IgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbi8vXG4vLyBBbGxvd2VkIHRva2VuIGNoYXJhY3RlcnM6XG4vL1xuLy8gJyEnLCAnIycsICckJywgJyUnLCAnJicsICcnJywgJyonLCAnKycsICctJyxcbi8vICcuJywgMC05LCBBLVosICdeJywgJ18nLCAnYCcsIGEteiwgJ3wnLCAnfidcbi8vXG4vLyB0b2tlbkNoYXJzWzMyXSA9PT0gMCAvLyAnICdcbi8vIHRva2VuQ2hhcnNbMzNdID09PSAxIC8vICchJ1xuLy8gdG9rZW5DaGFyc1szNF0gPT09IDAgLy8gJ1wiJ1xuLy8gLi4uXG4vL1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB0b2tlbkNoYXJzID0gW1xuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAwIC0gMTVcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMTYgLSAzMVxuICAwLCAxLCAwLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAxLCAxLCAwLCAxLCAxLCAwLCAvLyAzMiAtIDQ3XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDQ4IC0gNjNcbiAgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gNjQgLSA3OVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAxLCAxLCAvLyA4MCAtIDk1XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDk2IC0gMTExXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDAsIDEsIDAgLy8gMTEyIC0gMTI3XG5dO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YXR1cyBjb2RlIGlzIGFsbG93ZWQgaW4gYSBjbG9zZSBmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgc3RhdHVzIGNvZGUgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSB7XG4gIHJldHVybiAoXG4gICAgKGNvZGUgPj0gMTAwMCAmJlxuICAgICAgY29kZSA8PSAxMDE0ICYmXG4gICAgICBjb2RlICE9PSAxMDA0ICYmXG4gICAgICBjb2RlICE9PSAxMDA1ICYmXG4gICAgICBjb2RlICE9PSAxMDA2KSB8fFxuICAgIChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KVxuICApO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGJ1ZmZlciBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTguXG4gKiBQb3J0ZWQgZnJvbSBodHRwczovL3d3dy5jbC5jYW0uYWMudWsvJTdFbWdrMjUvdWNzL3V0ZjhfY2hlY2suYyBieVxuICogTWFya3VzIEt1aG4uXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYGJ1ZmAgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX2lzVmFsaWRVVEY4KGJ1Zikge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBpZiAoKGJ1ZltpXSAmIDB4ODApID09PSAwKSB7XG4gICAgICAvLyAweHh4eHh4eFxuICAgICAgaSsrO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAvLyAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMSA9PT0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSAmIDB4ZmUpID09PSAweGMwIC8vIE92ZXJsb25nXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDI7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAyID49IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhlMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZTApID09PSAweDgwKSB8fCAvLyBPdmVybG9uZ1xuICAgICAgICAoYnVmW2ldID09PSAweGVkICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4YTApIC8vIFN1cnJvZ2F0ZSAoVStEODAwIC0gVStERkZGKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAzO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAvLyAxMTExMHh4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMyA+PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAyXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDNdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhmMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZjApID09PSAweDgwKSB8fCAvLyBPdmVybG9uZ1xuICAgICAgICAoYnVmW2ldID09PSAweGY0ICYmIGJ1ZltpICsgMV0gPiAweDhmKSB8fFxuICAgICAgICBidWZbaV0gPiAweGY0IC8vID4gVSsxMEZGRkZcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIHZhbHVlIGlzIGEgYEJsb2JgLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHRlc3RlZFxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBgQmxvYmAsIGVsc2UgYGZhbHNlYFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgaGFzQmxvYiAmJlxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgdmFsdWUuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgdmFsdWUudHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgdmFsdWUuc3RyZWFtID09PSAnZnVuY3Rpb24nICYmXG4gICAgKHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdCbG9iJyB8fFxuICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0ZpbGUnKVxuICApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNCbG9iLFxuICBpc1ZhbGlkU3RhdHVzQ29kZSxcbiAgaXNWYWxpZFVURjg6IF9pc1ZhbGlkVVRGOCxcbiAgdG9rZW5DaGFyc1xufTtcblxuaWYgKGlzVXRmOCkge1xuICBtb2R1bGUuZXhwb3J0cy5pc1ZhbGlkVVRGOCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDI0ID8gX2lzVmFsaWRVVEY4KGJ1ZikgOiBpc1V0ZjgoYnVmKTtcbiAgfTtcbn0gLyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovIGVsc2UgaWYgKCFwcm9jZXNzLmVudi5XU19OT19VVEZfOF9WQUxJREFURSkge1xuICB0cnkge1xuICAgIGNvbnN0IGlzVmFsaWRVVEY4ID0gcmVxdWlyZSgndXRmLTgtdmFsaWRhdGUnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzLmlzVmFsaWRVVEY4ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgICAgcmV0dXJuIGJ1Zi5sZW5ndGggPCAzMiA/IF9pc1ZhbGlkVVRGOChidWYpIDogaXNWYWxpZFVURjgoYnVmKTtcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gQ29udGludWUgcmVnYXJkbGVzcyBvZiB0aGUgZXJyb3IuXG4gIH1cbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgV3JpdGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCB7XG4gIEJJTkFSWV9UWVBFUyxcbiAgRU1QVFlfQlVGRkVSLFxuICBrU3RhdHVzQ29kZSxcbiAga1dlYlNvY2tldFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCB7IGNvbmNhdCwgdG9BcnJheUJ1ZmZlciwgdW5tYXNrIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5jb25zdCB7IGlzVmFsaWRTdGF0dXNDb2RlLCBpc1ZhbGlkVVRGOCB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xuXG5jb25zdCBHRVRfSU5GTyA9IDA7XG5jb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfMTYgPSAxO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzY0ID0gMjtcbmNvbnN0IEdFVF9NQVNLID0gMztcbmNvbnN0IEdFVF9EQVRBID0gNDtcbmNvbnN0IElORkxBVElORyA9IDU7XG5jb25zdCBERUZFUl9FVkVOVCA9IDY7XG5cbi8qKlxuICogSHlCaSBSZWNlaXZlciBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyBXcml0YWJsZVxuICovXG5jbGFzcyBSZWNlaXZlciBleHRlbmRzIFdyaXRhYmxlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBSZWNlaXZlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXJcbiAgICogICAgIGFueSBvZiB0aGUgYCdtZXNzYWdlJ2AsIGAncGluZydgLCBhbmQgYCdwb25nJ2AgZXZlbnRzIGNhbiBiZSBlbWl0dGVkXG4gICAqICAgICBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgc2FtZSB0aWNrXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5iaW5hcnlUeXBlPW5vZGVidWZmZXJdIFRoZSB0eXBlIGZvciBiaW5hcnkgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZXh0ZW5zaW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lZ290aWF0ZWRcbiAgICogICAgIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pc1NlcnZlcj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgdG8gb3BlcmF0ZSBpblxuICAgKiAgICAgY2xpZW50IG9yIHNlcnZlciBtb2RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMgPVxuICAgICAgb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHNcbiAgICAgICAgOiB0cnVlO1xuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBvcHRpb25zLmJpbmFyeVR5cGUgfHwgQklOQVJZX1RZUEVTWzBdO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBvcHRpb25zLmV4dGVuc2lvbnMgfHwge307XG4gICAgdGhpcy5faXNTZXJ2ZXIgPSAhIW9wdGlvbnMuaXNTZXJ2ZXI7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG9wdGlvbnMubWF4UGF5bG9hZCB8IDA7XG4gICAgdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uID0gISFvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbjtcbiAgICB0aGlzW2tXZWJTb2NrZXRdID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5fYnVmZmVycyA9IFtdO1xuXG4gICAgdGhpcy5fY29tcHJlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21hc2sgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZnJhZ21lbnRlZCA9IDA7XG4gICAgdGhpcy5fbWFza2VkID0gZmFsc2U7XG4gICAgdGhpcy5fZmluID0gZmFsc2U7XG4gICAgdGhpcy5fb3Bjb2RlID0gMDtcblxuICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XG4gICAgdGhpcy5fZnJhZ21lbnRzID0gW107XG5cbiAgICB0aGlzLl9lcnJvcmVkID0gZmFsc2U7XG4gICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyBgV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIFRoZSBjaHVuayBvZiBkYXRhIHRvIHdyaXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGluZyBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIG9mIGBjaHVua2BcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCAmJiB0aGlzLl9zdGF0ZSA9PSBHRVRfSU5GTykgcmV0dXJuIGNiKCk7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLl9idWZmZXJzLnB1c2goY2h1bmspO1xuICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdW1lcyBgbmAgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIG51bWJlciBvZiBieXRlcyB0byBjb25zdW1lXG4gICAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGNvbnN1bWVkIGJ5dGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdW1lKG4pIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG47XG5cbiAgICBpZiAobiA9PT0gdGhpcy5fYnVmZmVyc1swXS5sZW5ndGgpIHJldHVybiB0aGlzLl9idWZmZXJzLnNoaWZ0KCk7XG5cbiAgICBpZiAobiA8IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IG5ldyBGYXN0QnVmZmVyKFxuICAgICAgICBidWYuYnVmZmVyLFxuICAgICAgICBidWYuYnl0ZU9mZnNldCArIG4sXG4gICAgICAgIGJ1Zi5sZW5ndGggLSBuXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gbmV3IEZhc3RCdWZmZXIoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIG4pO1xuICAgIH1cblxuICAgIGNvbnN0IGRzdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcblxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX2J1ZmZlcnNbMF07XG4gICAgICBjb25zdCBvZmZzZXQgPSBkc3QubGVuZ3RoIC0gbjtcblxuICAgICAgaWYgKG4gPj0gYnVmLmxlbmd0aCkge1xuICAgICAgICBkc3Quc2V0KHRoaXMuX2J1ZmZlcnMuc2hpZnQoKSwgb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRzdC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIG4pLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLl9idWZmZXJzWzBdID0gbmV3IEZhc3RCdWZmZXIoXG4gICAgICAgICAgYnVmLmJ1ZmZlcixcbiAgICAgICAgICBidWYuYnl0ZU9mZnNldCArIG4sXG4gICAgICAgICAgYnVmLmxlbmd0aCAtIG5cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgbiAtPSBidWYubGVuZ3RoO1xuICAgIH0gd2hpbGUgKG4gPiAwKTtcblxuICAgIHJldHVybiBkc3Q7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIHRoZSBwYXJzaW5nIGxvb3AuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGFydExvb3AoY2IpIHtcbiAgICB0aGlzLl9sb29wID0gdHJ1ZTtcblxuICAgIGRvIHtcbiAgICAgIHN3aXRjaCAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgY2FzZSBHRVRfSU5GTzpcbiAgICAgICAgICB0aGlzLmdldEluZm8oY2IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF8xNjpcbiAgICAgICAgICB0aGlzLmdldFBheWxvYWRMZW5ndGgxNihjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzY0OlxuICAgICAgICAgIHRoaXMuZ2V0UGF5bG9hZExlbmd0aDY0KGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfTUFTSzpcbiAgICAgICAgICB0aGlzLmdldE1hc2soKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfREFUQTpcbiAgICAgICAgICB0aGlzLmdldERhdGEoY2IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIElORkxBVElORzpcbiAgICAgICAgY2FzZSBERUZFUl9FVkVOVDpcbiAgICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHRoaXMuX2xvb3ApO1xuXG4gICAgaWYgKCF0aGlzLl9lcnJvcmVkKSBjYigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBmaXJzdCB0d28gYnl0ZXMgb2YgYSBmcmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEluZm8oY2IpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoMik7XG5cbiAgICBpZiAoKGJ1ZlswXSAmIDB4MzApICE9PSAweDAwKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdSU1YyIGFuZCBSU1YzIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzJfMydcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wcmVzc2VkID0gKGJ1ZlswXSAmIDB4NDApID09PSAweDQwO1xuXG4gICAgaWYgKGNvbXByZXNzZWQgJiYgIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1JTVjEgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMSdcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9maW4gPSAoYnVmWzBdICYgMHg4MCkgPT09IDB4ODA7XG4gICAgdGhpcy5fb3Bjb2RlID0gYnVmWzBdICYgMHgwZjtcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gYnVmWzFdICYgMHg3ZjtcblxuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDApIHtcbiAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnaW52YWxpZCBvcGNvZGUgMCcsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29wY29kZSA9IHRoaXMuX2ZyYWdtZW50ZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDEgfHwgdGhpcy5fb3Bjb2RlID09PSAweDAyKSB7XG4gICAgICBpZiAodGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICBgaW52YWxpZCBvcGNvZGUgJHt0aGlzLl9vcGNvZGV9YCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY29tcHJlc3NlZCA9IGNvbXByZXNzZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcGNvZGUgPiAweDA3ICYmIHRoaXMuX29wY29kZSA8IDB4MGIpIHtcbiAgICAgIGlmICghdGhpcy5fZmluKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdGSU4gbXVzdCBiZSBzZXQnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0VYUEVDVEVEX0ZJTidcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ1JTVjEgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMSdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID4gMHg3ZCB8fFxuICAgICAgICAodGhpcy5fb3Bjb2RlID09PSAweDA4ICYmIHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgYGludmFsaWQgcGF5bG9hZCBsZW5ndGggJHt0aGlzLl9wYXlsb2FkTGVuZ3RofWAsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9DT05UUk9MX1BBWUxPQURfTEVOR1RIJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgIGBpbnZhbGlkIG9wY29kZSAke3RoaXMuX29wY29kZX1gLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgKTtcblxuICAgICAgY2IoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZmluICYmICF0aGlzLl9mcmFnbWVudGVkKSB0aGlzLl9mcmFnbWVudGVkID0gdGhpcy5fb3Bjb2RlO1xuICAgIHRoaXMuX21hc2tlZCA9IChidWZbMV0gJiAweDgwKSA9PT0gMHg4MDtcblxuICAgIGlmICh0aGlzLl9pc1NlcnZlcikge1xuICAgICAgaWYgKCF0aGlzLl9tYXNrZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ01BU0sgbXVzdCBiZSBzZXQnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0VYUEVDVEVEX01BU0snXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9tYXNrZWQpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ01BU0sgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9NQVNLJ1xuICAgICAgKTtcblxuICAgICAgY2IoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjYpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzE2O1xuICAgIGVsc2UgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNykgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ7XG4gICAgZWxzZSB0aGlzLmhhdmVMZW5ndGgoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrMTYpLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGF5bG9hZExlbmd0aDE2KGNiKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IHRoaXMuY29uc3VtZSgyKS5yZWFkVUludDE2QkUoMCk7XG4gICAgdGhpcy5oYXZlTGVuZ3RoKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoICg3KzY0KS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGg2NChjYikge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgOCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuY29uc3VtZSg4KTtcbiAgICBjb25zdCBudW0gPSBidWYucmVhZFVJbnQzMkJFKDApO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgbWF4aW11bSBzYWZlIGludGVnZXIgaW4gSmF2YVNjcmlwdCBpcyAyXjUzIC0gMS4gQW4gZXJyb3IgaXMgcmV0dXJuZWRcbiAgICAvLyBpZiBwYXlsb2FkIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gdGhpcyBudW1iZXIuXG4gICAgLy9cbiAgICBpZiAobnVtID4gTWF0aC5wb3coMiwgNTMgLSAzMikgLSAxKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdVbnN1cHBvcnRlZCBXZWJTb2NrZXQgZnJhbWU6IHBheWxvYWQgbGVuZ3RoID4gMl41MyAtIDEnLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgMTAwOSxcbiAgICAgICAgJ1dTX0VSUl9VTlNVUFBPUlRFRF9EQVRBX1BBWUxPQURfTEVOR1RIJ1xuICAgICAgKTtcblxuICAgICAgY2IoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSBudW0gKiBNYXRoLnBvdygyLCAzMikgKyBidWYucmVhZFVJbnQzMkJFKDQpO1xuICAgIHRoaXMuaGF2ZUxlbmd0aChjYik7XG4gIH1cblxuICAvKipcbiAgICogUGF5bG9hZCBsZW5ndGggaGFzIGJlZW4gcmVhZC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhdmVMZW5ndGgoY2IpIHtcbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCAmJiB0aGlzLl9vcGNvZGUgPCAweDA4KSB7XG4gICAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggKz0gdGhpcy5fcGF5bG9hZExlbmd0aDtcbiAgICAgIGlmICh0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAxMDA5LFxuICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX21hc2tlZCkgdGhpcy5fc3RhdGUgPSBHRVRfTUFTSztcbiAgICBlbHNlIHRoaXMuX3N0YXRlID0gR0VUX0RBVEE7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgbWFzayBieXRlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE1hc2soKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA0KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fbWFzayA9IHRoaXMuY29uc3VtZSg0KTtcbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIGRhdGEgYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXREYXRhKGNiKSB7XG4gICAgbGV0IGRhdGEgPSBFTVBUWV9CVUZGRVI7XG5cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCB0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkYXRhID0gdGhpcy5jb25zdW1lKHRoaXMuX3BheWxvYWRMZW5ndGgpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX21hc2tlZCAmJlxuICAgICAgICAodGhpcy5fbWFza1swXSB8IHRoaXMuX21hc2tbMV0gfCB0aGlzLl9tYXNrWzJdIHwgdGhpcy5fbWFza1szXSkgIT09IDBcbiAgICAgICkge1xuICAgICAgICB1bm1hc2soZGF0YSwgdGhpcy5fbWFzayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcpIHtcbiAgICAgIHRoaXMuY29udHJvbE1lc3NhZ2UoZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb21wcmVzc2VkKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IElORkxBVElORztcbiAgICAgIHRoaXMuZGVjb21wcmVzcyhkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoKSB7XG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBtZXNzYWdlIGlzIG5vdCBjb21wcmVzc2VkIHNvIGl0cyBsZW5ndGggaXMgdGhlIHN1bSBvZiB0aGUgcGF5bG9hZFxuICAgICAgLy8gbGVuZ3RoIG9mIGFsbCBmcmFnbWVudHMuXG4gICAgICAvL1xuICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YU1lc3NhZ2UoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3NlcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgY2IpIHtcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG5cbiAgICBwZXJNZXNzYWdlRGVmbGF0ZS5kZWNvbXByZXNzKGRhdGEsIHRoaXMuX2ZpbiwgKGVyciwgYnVmKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgICAgaWYgKGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5fbWVzc2FnZUxlbmd0aCA+IHRoaXMuX21heFBheWxvYWQgJiYgdGhpcy5fbWF4UGF5bG9hZCA+IDApIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICAgJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAxMDA5LFxuICAgICAgICAgICAgJ1dTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSCdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGJ1Zik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGF0YU1lc3NhZ2UoY2IpO1xuICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBHRVRfSU5GTykgdGhpcy5zdGFydExvb3AoY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBkYXRhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkYXRhTWVzc2FnZShjYikge1xuICAgIGlmICghdGhpcy5fZmluKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1lc3NhZ2VMZW5ndGggPSB0aGlzLl9tZXNzYWdlTGVuZ3RoO1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IHRoaXMuX2ZyYWdtZW50cztcblxuICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XG4gICAgdGhpcy5fZnJhZ21lbnRlZCA9IDA7XG4gICAgdGhpcy5fZnJhZ21lbnRzID0gW107XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAyKSB7XG4gICAgICBsZXQgZGF0YTtcblxuICAgICAgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09ICdub2RlYnVmZmVyJykge1xuICAgICAgICBkYXRhID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgZGF0YSA9IHRvQXJyYXlCdWZmZXIoY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBCbG9iKGZyYWdtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gZnJhZ21lbnRzO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYWxsb3dTeW5jaHJvbm91c0V2ZW50cykge1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gREVGRVJfRVZFTlQ7XG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSwgdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBidWYgPSBjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKTtcblxuICAgICAgaWYgKCF0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gJiYgIWlzVmFsaWRVVEY4KGJ1ZikpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIEVycm9yLFxuICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDcsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gSU5GTEFUSU5HIHx8IHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgYnVmLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGJ1ZiwgZmFsc2UpO1xuICAgICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICAgICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGNvbnRyb2wgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgRGF0YSB0byBoYW5kbGVcbiAgICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29udHJvbE1lc3NhZ2UoZGF0YSwgY2IpIHtcbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA4KSB7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXQoJ2NvbmNsdWRlJywgMTAwNSwgRU1QVFlfQlVGRkVSKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBkYXRhLnJlYWRVSW50MTZCRSgwKTtcblxuICAgICAgICBpZiAoIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAgIGBpbnZhbGlkIHN0YXR1cyBjb2RlICR7Y29kZX1gLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfQ0xPU0VfQ09ERSdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBGYXN0QnVmZmVyKFxuICAgICAgICAgIGRhdGEuYnVmZmVyLFxuICAgICAgICAgIGRhdGEuYnl0ZU9mZnNldCArIDIsXG4gICAgICAgICAgZGF0YS5sZW5ndGggLSAyXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gJiYgIWlzVmFsaWRVVEY4KGJ1ZikpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDA3LFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCBjb2RlLCBidWYpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzKSB7XG4gICAgICB0aGlzLmVtaXQodGhpcy5fb3Bjb2RlID09PSAweDA5ID8gJ3BpbmcnIDogJ3BvbmcnLCBkYXRhKTtcbiAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gREVGRVJfRVZFTlQ7XG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQodGhpcy5fb3Bjb2RlID09PSAweDA5ID8gJ3BpbmcnIDogJ3BvbmcnLCBkYXRhKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhbiBlcnJvciBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24obmV3OkVycm9yfFJhbmdlRXJyb3IpfSBFcnJvckN0b3IgVGhlIGVycm9yIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZml4IFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBhZGQgYSBkZWZhdWx0IHByZWZpeCB0b1xuICAgKiAgICAgYG1lc3NhZ2VgXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNDb2RlIFRoZSBzdGF0dXMgY29kZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXJyb3JDb2RlIFRoZSBleHBvc2VkIGVycm9yIGNvZGVcbiAgICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3IpfSBUaGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNyZWF0ZUVycm9yKEVycm9yQ3RvciwgbWVzc2FnZSwgcHJlZml4LCBzdGF0dXNDb2RlLCBlcnJvckNvZGUpIHtcbiAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgdGhpcy5fZXJyb3JlZCA9IHRydWU7XG5cbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3JDdG9yKFxuICAgICAgcHJlZml4ID8gYEludmFsaWQgV2ViU29ja2V0IGZyYW1lOiAke21lc3NhZ2V9YCA6IG1lc3NhZ2VcbiAgICApO1xuXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCB0aGlzLmNyZWF0ZUVycm9yKTtcbiAgICBlcnIuY29kZSA9IGVycm9yQ29kZTtcbiAgICBlcnJba1N0YXR1c0NvZGVdID0gc3RhdHVzQ29kZTtcbiAgICByZXR1cm4gZXJyO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVjZWl2ZXI7XG4iLCAiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeRHVwbGV4XCIgfV0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IHJhbmRvbUZpbGxTeW5jIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgeyBFTVBUWV9CVUZGRVIsIGtXZWJTb2NrZXQsIE5PT1AgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCB7IGlzQmxvYiwgaXNWYWxpZFN0YXR1c0NvZGUgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuY29uc3QgeyBtYXNrOiBhcHBseU1hc2ssIHRvQnVmZmVyIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5cbmNvbnN0IGtCeXRlTGVuZ3RoID0gU3ltYm9sKCdrQnl0ZUxlbmd0aCcpO1xuY29uc3QgbWFza0J1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbmNvbnN0IFJBTkRPTV9QT09MX1NJWkUgPSA4ICogMTAyNDtcbmxldCByYW5kb21Qb29sO1xubGV0IHJhbmRvbVBvb2xQb2ludGVyID0gUkFORE9NX1BPT0xfU0laRTtcblxuY29uc3QgREVGQVVMVCA9IDA7XG5jb25zdCBERUZMQVRJTkcgPSAxO1xuY29uc3QgR0VUX0JMT0JfREFUQSA9IDI7XG5cbi8qKlxuICogSHlCaSBTZW5kZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIFNlbmRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgU2VuZGVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBjb25uZWN0aW9uIHNvY2tldFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2V4dGVuc2lvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2dlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc29ja2V0LCBleHRlbnNpb25zLCBnZW5lcmF0ZU1hc2spIHtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCB7fTtcblxuICAgIGlmIChnZW5lcmF0ZU1hc2spIHtcbiAgICAgIHRoaXMuX2dlbmVyYXRlTWFzayA9IGdlbmVyYXRlTWFzaztcbiAgICAgIHRoaXMuX21hc2tCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgfVxuXG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XG4gICAgdGhpcy5fY29tcHJlc3MgPSBmYWxzZTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgdGhpcy5fc3RhdGUgPSBERUZBVUxUO1xuICAgIHRoaXMub25lcnJvciA9IE5PT1A7XG4gICAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYSBwaWVjZSBvZiBkYXRhIGFjY29yZGluZyB0byB0aGUgSHlCaSBXZWJTb2NrZXQgcHJvdG9jb2wuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIFRoZSBkYXRhIHRvIGZyYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5tYXNrQnVmZmVyXSBUaGUgYnVmZmVyIHVzZWQgdG8gc3RvcmUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBSU1YxIGJpdFxuICAgKiBAcmV0dXJuIHsoQnVmZmVyfFN0cmluZylbXX0gVGhlIGZyYW1lZCBkYXRhXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHN0YXRpYyBmcmFtZShkYXRhLCBvcHRpb25zKSB7XG4gICAgbGV0IG1hc2s7XG4gICAgbGV0IG1lcmdlID0gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9IDI7XG4gICAgbGV0IHNraXBNYXNraW5nID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5tYXNrKSB7XG4gICAgICBtYXNrID0gb3B0aW9ucy5tYXNrQnVmZmVyIHx8IG1hc2tCdWZmZXI7XG5cbiAgICAgIGlmIChvcHRpb25zLmdlbmVyYXRlTWFzaykge1xuICAgICAgICBvcHRpb25zLmdlbmVyYXRlTWFzayhtYXNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyYW5kb21Qb29sUG9pbnRlciA9PT0gUkFORE9NX1BPT0xfU0laRSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xuICAgICAgICAgIGlmIChyYW5kb21Qb29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGxhemlseSBpbml0aWFsaXplZCBiZWNhdXNlIHNlcnZlci1zZW50IGZyYW1lcyBtdXN0IG5vdFxuICAgICAgICAgICAgLy8gYmUgbWFza2VkIHNvIGl0IG1heSBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHJhbmRvbVBvb2wgPSBCdWZmZXIuYWxsb2MoUkFORE9NX1BPT0xfU0laRSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmFuZG9tRmlsbFN5bmMocmFuZG9tUG9vbCwgMCwgUkFORE9NX1BPT0xfU0laRSk7XG4gICAgICAgICAgcmFuZG9tUG9vbFBvaW50ZXIgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFza1swXSA9IHJhbmRvbVBvb2xbcmFuZG9tUG9vbFBvaW50ZXIrK107XG4gICAgICAgIG1hc2tbMV0gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuICAgICAgICBtYXNrWzJdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcbiAgICAgICAgbWFza1szXSA9IHJhbmRvbVBvb2xbcmFuZG9tUG9vbFBvaW50ZXIrK107XG4gICAgICB9XG5cbiAgICAgIHNraXBNYXNraW5nID0gKG1hc2tbMF0gfCBtYXNrWzFdIHwgbWFza1syXSB8IG1hc2tbM10pID09PSAwO1xuICAgICAgb2Zmc2V0ID0gNjtcbiAgICB9XG5cbiAgICBsZXQgZGF0YUxlbmd0aDtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKCFvcHRpb25zLm1hc2sgfHwgc2tpcE1hc2tpbmcpICYmXG4gICAgICAgIG9wdGlvbnNba0J5dGVMZW5ndGhdICE9PSB1bmRlZmluZWRcbiAgICAgICkge1xuICAgICAgICBkYXRhTGVuZ3RoID0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgbWVyZ2UgPSBvcHRpb25zLm1hc2sgJiYgb3B0aW9ucy5yZWFkT25seSAmJiAhc2tpcE1hc2tpbmc7XG4gICAgfVxuXG4gICAgbGV0IHBheWxvYWRMZW5ndGggPSBkYXRhTGVuZ3RoO1xuXG4gICAgaWYgKGRhdGFMZW5ndGggPj0gNjU1MzYpIHtcbiAgICAgIG9mZnNldCArPSA4O1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNztcbiAgICB9IGVsc2UgaWYgKGRhdGFMZW5ndGggPiAxMjUpIHtcbiAgICAgIG9mZnNldCArPSAyO1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNjtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobWVyZ2UgPyBkYXRhTGVuZ3RoICsgb2Zmc2V0IDogb2Zmc2V0KTtcblxuICAgIHRhcmdldFswXSA9IG9wdGlvbnMuZmluID8gb3B0aW9ucy5vcGNvZGUgfCAweDgwIDogb3B0aW9ucy5vcGNvZGU7XG4gICAgaWYgKG9wdGlvbnMucnN2MSkgdGFyZ2V0WzBdIHw9IDB4NDA7XG5cbiAgICB0YXJnZXRbMV0gPSBwYXlsb2FkTGVuZ3RoO1xuXG4gICAgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNikge1xuICAgICAgdGFyZ2V0LndyaXRlVUludDE2QkUoZGF0YUxlbmd0aCwgMik7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjcpIHtcbiAgICAgIHRhcmdldFsyXSA9IHRhcmdldFszXSA9IDA7XG4gICAgICB0YXJnZXQud3JpdGVVSW50QkUoZGF0YUxlbmd0aCwgNCwgNik7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLm1hc2spIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcblxuICAgIHRhcmdldFsxXSB8PSAweDgwO1xuICAgIHRhcmdldFtvZmZzZXQgLSA0XSA9IG1hc2tbMF07XG4gICAgdGFyZ2V0W29mZnNldCAtIDNdID0gbWFza1sxXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMl0gPSBtYXNrWzJdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAxXSA9IG1hc2tbM107XG5cbiAgICBpZiAoc2tpcE1hc2tpbmcpIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcblxuICAgIGlmIChtZXJnZSkge1xuICAgICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIHRhcmdldCwgb2Zmc2V0LCBkYXRhTGVuZ3RoKTtcbiAgICAgIHJldHVybiBbdGFyZ2V0XTtcbiAgICB9XG5cbiAgICBhcHBseU1hc2soZGF0YSwgbWFzaywgZGF0YSwgMCwgZGF0YUxlbmd0aCk7XG4gICAgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgY2xvc2UgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBUaGUgc3RhdHVzIGNvZGUgY29tcG9uZW50IG9mIHRoZSBib2R5XG4gICAqIEBwYXJhbSB7KFN0cmluZ3xCdWZmZXIpfSBbZGF0YV0gVGhlIG1lc3NhZ2UgY29tcG9uZW50IG9mIHRoZSBib2R5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIHRoZSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY29kZSwgZGF0YSwgbWFzaywgY2IpIHtcbiAgICBsZXQgYnVmO1xuXG4gICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYnVmID0gRU1QVFlfQlVGRkVSO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvZGUgIT09ICdudW1iZXInIHx8ICFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHZhbGlkIGVycm9yIGNvZGUgbnVtYmVyJyk7XG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMik7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShjb2RlLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG5cbiAgICAgIGlmIChsZW5ndGggPiAxMjMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBtZXNzYWdlIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjMgYnl0ZXMnKTtcbiAgICAgIH1cblxuICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIgKyBsZW5ndGgpO1xuICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYnVmLndyaXRlKGRhdGEsIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmLnNldChkYXRhLCAyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnVmLmxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDB4MDgsXG4gICAgICByZWFkT25seTogZmFsc2UsXG4gICAgICByc3YxOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgYnVmLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBwaW5nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBsZXQgYnl0ZUxlbmd0aDtcbiAgICBsZXQgcmVhZE9ubHk7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBieXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5zaXplO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRvQnVmZmVyKGRhdGEpO1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgcmVhZE9ubHkgPSB0b0J1ZmZlci5yZWFkT25seTtcbiAgICB9XG5cbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDEyNSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBkYXRhIHNpemUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyNSBieXRlcycpO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXNrLFxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgIG9wY29kZTogMHgwOSxcbiAgICAgIHJlYWRPbmx5LFxuICAgICAgcnN2MTogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5nZXRCbG9iRGF0YSwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmdldEJsb2JEYXRhKGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcG9uZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEuc2l6ZTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDB4MGEsXG4gICAgICByZWFkT25seSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgICB0aGlzLmVucXVldWUoW3RoaXMuZ2V0QmxvYkRhdGEsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nZXRCbG9iRGF0YShkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGRhdGEgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iaW5hcnk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBpcyBiaW5hcnlcbiAgICogICAgIG9yIHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gICAqICAgICBjb21wcmVzcyBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcbiAgICogICAgIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG4gICAgbGV0IG9wY29kZSA9IG9wdGlvbnMuYmluYXJ5ID8gMiA6IDE7XG4gICAgbGV0IHJzdjEgPSBvcHRpb25zLmNvbXByZXNzO1xuXG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEuc2l6ZTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZpcnN0RnJhZ21lbnQpIHtcbiAgICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSBmYWxzZTtcbiAgICAgIGlmIChcbiAgICAgICAgcnN2MSAmJlxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZSAmJlxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5wYXJhbXNbXG4gICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuX2lzU2VydmVyXG4gICAgICAgICAgICA/ICdzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgICAgIDogJ2NsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyJ1xuICAgICAgICBdXG4gICAgICApIHtcbiAgICAgICAgcnN2MSA9IGJ5dGVMZW5ndGggPj0gcGVyTWVzc2FnZURlZmxhdGUuX3RocmVzaG9sZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbXByZXNzID0gcnN2MTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnN2MSA9IGZhbHNlO1xuICAgICAgb3Bjb2RlID0gMDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5maW4pIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICBmaW46IG9wdGlvbnMuZmluLFxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXNrOiBvcHRpb25zLm1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlLFxuICAgICAgcmVhZE9ubHksXG4gICAgICByc3YxXG4gICAgfTtcblxuICAgIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgICB0aGlzLmVucXVldWUoW3RoaXMuZ2V0QmxvYkRhdGEsIGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nZXRCbG9iRGF0YShkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2goZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY29udGVudHMgb2YgYSBibG9iIGFzIGJpbmFyeSBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2IgVGhlIGJsb2JcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY29tcHJlc3M9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xuICAgKiAgICAgdGhlIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBGSU4gYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcbiAgICogICAgIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEJsb2JEYXRhKGJsb2IsIGNvbXByZXNzLCBvcHRpb25zLCBjYikge1xuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfQkxPQl9EQVRBO1xuXG4gICAgYmxvYlxuICAgICAgLmFycmF5QnVmZmVyKClcbiAgICAgIC50aGVuKChhcnJheUJ1ZmZlcikgPT4ge1xuICAgICAgICBpZiAodGhpcy5fc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgc29ja2V0IHdhcyBjbG9zZWQgd2hpbGUgdGhlIGJsb2Igd2FzIGJlaW5nIHJlYWQnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gYGNhbGxDYWxsYmFja3NgIGlzIGNhbGxlZCBpbiB0aGUgbmV4dCB0aWNrIHRvIGVuc3VyZSB0aGF0IGVycm9yc1xuICAgICAgICAgIC8vIHRoYXQgbWlnaHQgYmUgdGhyb3duIGluIHRoZSBjYWxsYmFja3MgYmVoYXZlIGxpa2UgZXJyb3JzIHRocm93blxuICAgICAgICAgIC8vIG91dHNpZGUgdGhlIHByb21pc2UgY2hhaW4uXG4gICAgICAgICAgLy9cbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxDYWxsYmFja3MsIHRoaXMsIGVyciwgY2IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0b0J1ZmZlcihhcnJheUJ1ZmZlcik7XG5cbiAgICAgICAgaWYgKCFjb21wcmVzcykge1xuICAgICAgICAgIHRoaXMuX3N0YXRlID0gREVGQVVMVDtcbiAgICAgICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICAgICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoKGRhdGEsIGNvbXByZXNzLCBvcHRpb25zLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAvL1xuICAgICAgICAvLyBgb25FcnJvcmAgaXMgY2FsbGVkIGluIHRoZSBuZXh0IHRpY2sgZm9yIHRoZSBzYW1lIHJlYXNvbiB0aGF0XG4gICAgICAgIC8vIGBjYWxsQ2FsbGJhY2tzYCBhYm92ZSBpcy5cbiAgICAgICAgLy9cbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhvbkVycm9yLCB0aGlzLCBlcnIsIGNiKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIEZJTiBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW29wdGlvbnMubWFza0J1ZmZlcl0gVGhlIGJ1ZmZlciB1c2VkIHRvIHN0b3JlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxuICAgKiAgICAgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgUlNWMSBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGlzcGF0Y2goZGF0YSwgY29tcHJlc3MsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKCFjb21wcmVzcykge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICB0aGlzLl9zdGF0ZSA9IERFRkxBVElORztcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZS5jb21wcmVzcyhkYXRhLCBvcHRpb25zLmZpbiwgKF8sIGJ1ZikgPT4ge1xuICAgICAgaWYgKHRoaXMuX3NvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgc29ja2V0IHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgY29tcHJlc3NlZCdcbiAgICAgICAgKTtcblxuICAgICAgICBjYWxsQ2FsbGJhY2tzKHRoaXMsIGVyciwgY2IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgICB0aGlzLl9zdGF0ZSA9IERFRkFVTFQ7XG4gICAgICBvcHRpb25zLnJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoYnVmLCBvcHRpb25zKSwgY2IpO1xuICAgICAgdGhpcy5kZXF1ZXVlKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgcXVldWVkIHNlbmQgb3BlcmF0aW9ucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlcXVldWUoKSB7XG4gICAgd2hpbGUgKHRoaXMuX3N0YXRlID09PSBERUZBVUxUICYmIHRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcblxuICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBwYXJhbXNbM11ba0J5dGVMZW5ndGhdO1xuICAgICAgUmVmbGVjdC5hcHBseShwYXJhbXNbMF0sIHRoaXMsIHBhcmFtcy5zbGljZSgxKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgc2VuZCBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBTZW5kIG9wZXJhdGlvbiBwYXJhbWV0ZXJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW5xdWV1ZShwYXJhbXMpIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IHBhcmFtc1szXVtrQnl0ZUxlbmd0aF07XG4gICAgdGhpcy5fcXVldWUucHVzaChwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGZyYW1lIHRvIHNlbmRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2VuZEZyYW1lKGxpc3QsIGNiKSB7XG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAyKSB7XG4gICAgICB0aGlzLl9zb2NrZXQuY29yaygpO1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMF0pO1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMV0sIGNiKTtcbiAgICAgIHRoaXMuX3NvY2tldC51bmNvcmsoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMF0sIGNiKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZW5kZXI7XG5cbi8qKlxuICogQ2FsbHMgcXVldWVkIGNhbGxiYWNrcyB3aXRoIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U2VuZGVyfSBzZW5kZXIgVGhlIGBTZW5kZXJgIGluc3RhbmNlXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yIHRvIGNhbGwgdGhlIGNhbGxiYWNrcyB3aXRoXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIFRoZSBmaXJzdCBjYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2FsbENhbGxiYWNrcyhzZW5kZXIsIGVyciwgY2IpIHtcbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykgY2IoZXJyKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbmRlci5fcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzZW5kZXIuX3F1ZXVlW2ldO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXTtcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGVzIGEgYFNlbmRlcmAgZXJyb3IuXG4gKlxuICogQHBhcmFtIHtTZW5kZXJ9IHNlbmRlciBUaGUgYFNlbmRlcmAgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gVGhlIGZpcnN0IHBlbmRpbmcgY2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG9uRXJyb3Ioc2VuZGVyLCBlcnIsIGNiKSB7XG4gIGNhbGxDYWxsYmFja3Moc2VuZGVyLCBlcnIsIGNiKTtcbiAgc2VuZGVyLm9uZXJyb3IoZXJyKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsga0Zvck9uRXZlbnRBdHRyaWJ1dGUsIGtMaXN0ZW5lciB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3Qga0NvZGUgPSBTeW1ib2woJ2tDb2RlJyk7XG5jb25zdCBrRGF0YSA9IFN5bWJvbCgna0RhdGEnKTtcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgna0Vycm9yJyk7XG5jb25zdCBrTWVzc2FnZSA9IFN5bWJvbCgna01lc3NhZ2UnKTtcbmNvbnN0IGtSZWFzb24gPSBTeW1ib2woJ2tSZWFzb24nKTtcbmNvbnN0IGtUYXJnZXQgPSBTeW1ib2woJ2tUYXJnZXQnKTtcbmNvbnN0IGtUeXBlID0gU3ltYm9sKCdrVHlwZScpO1xuY29uc3Qga1dhc0NsZWFuID0gU3ltYm9sKCdrV2FzQ2xlYW4nKTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXZlbnQuXG4gKi9cbmNsYXNzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgYHR5cGVgIGFyZ3VtZW50IGlzIG5vdCBzcGVjaWZpZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICB0aGlzW2tUYXJnZXRdID0gbnVsbDtcbiAgICB0aGlzW2tUeXBlXSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgdGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzW2tUYXJnZXRdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpc1trVHlwZV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgJ3RhcmdldCcsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsICd0eXBlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGNsb3NlIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIENsb3NlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYENsb3NlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb2RlPTBdIFRoZSBzdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGVcbiAgICogICAgIGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVhc29uPScnXSBBIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBleHBsYWluaW5nIHdoeVxuICAgKiAgICAgdGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndhc0NsZWFuPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlXG4gICAqICAgICBjb25uZWN0aW9uIHdhcyBjbGVhbmx5IGNsb3NlZFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICB0aGlzW2tDb2RlXSA9IG9wdGlvbnMuY29kZSA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdGlvbnMuY29kZTtcbiAgICB0aGlzW2tSZWFzb25dID0gb3B0aW9ucy5yZWFzb24gPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5yZWFzb247XG4gICAgdGhpc1trV2FzQ2xlYW5dID0gb3B0aW9ucy53YXNDbGVhbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zLndhc0NsZWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgY29kZSgpIHtcbiAgICByZXR1cm4gdGhpc1trQ29kZV07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCByZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXNba1JlYXNvbl07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgd2FzQ2xlYW4oKSB7XG4gICAgcmV0dXJuIHRoaXNba1dhc0NsZWFuXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICdjb2RlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAncmVhc29uJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAnd2FzQ2xlYW4nLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGVycm9yIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIEVycm9yRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYEVycm9yRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZXJyb3I9bnVsbF0gVGhlIGVycm9yIHRoYXQgZ2VuZXJhdGVkIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2U9JyddIFRoZSBlcnJvciBtZXNzYWdlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0Vycm9yXSA9IG9wdGlvbnMuZXJyb3IgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmVycm9yO1xuICAgIHRoaXNba01lc3NhZ2VdID0gb3B0aW9ucy5tZXNzYWdlID09PSB1bmRlZmluZWQgPyAnJyA6IG9wdGlvbnMubWVzc2FnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCBlcnJvcigpIHtcbiAgICByZXR1cm4gdGhpc1trRXJyb3JdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgbWVzc2FnZSgpIHtcbiAgICByZXR1cm4gdGhpc1trTWVzc2FnZV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVycm9yRXZlbnQucHJvdG90eXBlLCAnZXJyb3InLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JFdmVudC5wcm90b3R5cGUsICdtZXNzYWdlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIG1lc3NhZ2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBNZXNzYWdlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZGF0YT1udWxsXSBUaGUgbWVzc2FnZSBjb250ZW50XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0RhdGFdID0gb3B0aW9ucy5kYXRhID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5kYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXNba0RhdGFdO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlRXZlbnQucHJvdG90eXBlLCAnZGF0YScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBUaGlzIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGVtdWxhdGluZyB0aGUgYEV2ZW50VGFyZ2V0YCBpbnRlcmZhY2UuIEl0J3Mgbm90XG4gKiBtZWFudCB0byBiZSB1c2VkIGRpcmVjdGx5LlxuICpcbiAqIEBtaXhpblxuICovXG5jb25zdCBFdmVudFRhcmdldCA9IHtcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvclxuICAgKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byBhZGRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvcHRpb25zIG9iamVjdCBzcGVjaWZpZXMgY2hhcmFjdGVyaXN0aWNzIGFib3V0XG4gICAqICAgICB0aGUgZXZlbnQgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vbmNlPWZhbHNlXSBBIGBCb29sZWFuYCBpbmRpY2F0aW5nIHRoYXQgdGhlXG4gICAqICAgICBsaXN0ZW5lciBzaG91bGQgYmUgaW52b2tlZCBhdCBtb3N0IG9uY2UgYWZ0ZXIgYmVpbmcgYWRkZWQuIElmIGB0cnVlYCxcbiAgICogICAgIHRoZSBsaXN0ZW5lciB3b3VsZCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgd2hlbiBpbnZva2VkLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIW9wdGlvbnNba0Zvck9uRXZlbnRBdHRyaWJ1dGVdICYmXG4gICAgICAgIGxpc3RlbmVyW2tMaXN0ZW5lcl0gPT09IGhhbmRsZXIgJiZcbiAgICAgICAgIWxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgd3JhcHBlcjtcblxuICAgIGlmICh0eXBlID09PSAnbWVzc2FnZScpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgTWVzc2FnZUV2ZW50KCdtZXNzYWdlJywge1xuICAgICAgICAgIGRhdGE6IGlzQmluYXJ5ID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoKVxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uQ2xvc2UoY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDbG9zZUV2ZW50KCdjbG9zZScsIHtcbiAgICAgICAgICBjb2RlLFxuICAgICAgICAgIHJlYXNvbjogbWVzc2FnZS50b1N0cmluZygpLFxuICAgICAgICAgIHdhc0NsZWFuOiB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgJiYgdGhpcy5fY2xvc2VGcmFtZVNlbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEVycm9yRXZlbnQoJ2Vycm9yJywge1xuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGVuJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ29wZW4nKTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd3JhcHBlcltrRm9yT25FdmVudEF0dHJpYnV0ZV0gPSAhIW9wdGlvbnNba0Zvck9uRXZlbnRBdHRyaWJ1dGVdO1xuICAgIHdyYXBwZXJba0xpc3RlbmVyXSA9IGhhbmRsZXI7XG5cbiAgICBpZiAob3B0aW9ucy5vbmNlKSB7XG4gICAgICB0aGlzLm9uY2UodHlwZSwgd3JhcHBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub24odHlwZSwgd3JhcHBlcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byByZW1vdmVcbiAgICogQHBhcmFtIHsoRnVuY3Rpb258T2JqZWN0KX0gaGFuZGxlciBUaGUgbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcikge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcbiAgICAgIGlmIChsaXN0ZW5lcltrTGlzdGVuZXJdID09PSBoYW5kbGVyICYmICFsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENsb3NlRXZlbnQsXG4gIEVycm9yRXZlbnQsXG4gIEV2ZW50LFxuICBFdmVudFRhcmdldCxcbiAgTWVzc2FnZUV2ZW50XG59O1xuXG4vKipcbiAqIENhbGwgYW4gZXZlbnQgbGlzdGVuZXJcbiAqXG4gKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gY2FsbFxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSB2YWx1ZSB0byB1c2UgYXMgYHRoaXNgYCB3aGVuIGNhbGxpbmcgdGhlIGxpc3RlbmVyXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihsaXN0ZW5lciwgdGhpc0FyZywgZXZlbnQpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ29iamVjdCcgJiYgbGlzdGVuZXIuaGFuZGxlRXZlbnQpIHtcbiAgICBsaXN0ZW5lci5oYW5kbGVFdmVudC5jYWxsKGxpc3RlbmVyLCBldmVudCk7XG4gIH0gZWxzZSB7XG4gICAgbGlzdGVuZXIuY2FsbCh0aGlzQXJnLCBldmVudCk7XG4gIH1cbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgdG9rZW5DaGFycyB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbi8qKlxuICogQWRkcyBhbiBvZmZlciB0byB0aGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgYSBwYXJhbWV0ZXIgdG8gdGhlIG1hcCBvZlxuICogcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBUaGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGV4dGVuc2lvbiBvciBwYXJhbWV0ZXIgbmFtZVxuICogQHBhcmFtIHsoT2JqZWN0fEJvb2xlYW58U3RyaW5nKX0gZWxlbSBUaGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgb3IgdGhlXG4gKiAgICAgcGFyYW1ldGVyIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdXNoKGRlc3QsIG5hbWUsIGVsZW0pIHtcbiAgaWYgKGRlc3RbbmFtZV0gPT09IHVuZGVmaW5lZCkgZGVzdFtuYW1lXSA9IFtlbGVtXTtcbiAgZWxzZSBkZXN0W25hbWVdLnB1c2goZWxlbSk7XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zYCBoZWFkZXIgaW50byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcGFyc2VkIG9iamVjdFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3Qgb2ZmZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgbGV0IGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgbGV0IGluUXVvdGVzID0gZmFsc2U7XG4gIGxldCBleHRlbnNpb25OYW1lO1xuICBsZXQgcGFyYW1OYW1lO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGNvZGUgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGkgIT09IDAgJiZcbiAgICAgICAgKGNvZGUgPT09IDB4MjAgLyogJyAnICovIHx8IGNvZGUgPT09IDB4MDkpIC8qICdcXHQnICovXG4gICAgICApIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIC8qICc7JyAqLyB8fCBjb2RlID09PSAweDJjIC8qICcsJyAqLykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgbmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIHB1c2gocGFyYW1zLCBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCksIHRydWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2QgLyogJz0nICovICYmIHN0YXJ0ICE9PSAtMSAmJiBlbmQgPT09IC0xKSB7XG4gICAgICAgIHBhcmFtTmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9cbiAgICAgIC8vIFRoZSB2YWx1ZSBvZiBhIHF1b3RlZC1zdHJpbmcgYWZ0ZXIgdW5lc2NhcGluZyBtdXN0IGNvbmZvcm0gdG8gdGhlXG4gICAgICAvLyB0b2tlbiBBQk5GLCBzbyBvbmx5IHRva2VuIGNoYXJhY3RlcnMgYXJlIHZhbGlkLlxuICAgICAgLy8gUmVmOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxuICAgICAgLy9cbiAgICAgIGlmIChpc0VzY2FwaW5nKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICBlbHNlIGlmICghbXVzdFVuZXNjYXBlKSBtdXN0VW5lc2NhcGUgPSB0cnVlO1xuICAgICAgICBpc0VzY2FwaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGluUXVvdGVzKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgLyogJ1wiJyAqLyAmJiBzdGFydCAhPT0gLTEpIHtcbiAgICAgICAgICBpblF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1YyAvKiAnXFwnICovKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAmJiBoZWFkZXIuY2hhckNvZGVBdChpIC0gMSkgPT09IDB4M2QpIHtcbiAgICAgICAgaW5RdW90ZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCAhPT0gLTEgJiYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgfHwgY29kZSA9PT0gMHgyYykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgbGV0IHZhbHVlID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICAgICAgICBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBpblF1b3RlcyB8fCBjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgY29uc3QgdG9rZW4gPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBwdXNoKG9mZmVycywgdG9rZW4sIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdXNoKHBhcmFtcywgdG9rZW4sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbi5yZXBsYWNlKC9cXFxcL2csICcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuKTtcbiAgICB9XG4gICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gb2ZmZXJzO1xufVxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGZpZWxkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBtYXAgb2YgZXh0ZW5zaW9ucyBhbmQgcGFyYW1ldGVycyB0byBmb3JtYXRcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KGV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpXG4gICAgLm1hcCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBsZXQgY29uZmlndXJhdGlvbnMgPSBleHRlbnNpb25zW2V4dGVuc2lvbl07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlndXJhdGlvbnMpKSBjb25maWd1cmF0aW9ucyA9IFtjb25maWd1cmF0aW9uc107XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbnNcbiAgICAgICAgLm1hcCgocGFyYW1zKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25dXG4gICAgICAgICAgICAuY29uY2F0KFxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBwYXJhbXNba107XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIC5tYXAoKHYpID0+ICh2ID09PSB0cnVlID8gayA6IGAke2t9PSR7dn1gKSlcbiAgICAgICAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oJzsgJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcsICcpO1xuICAgIH0pXG4gICAgLmpvaW4oJywgJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBmb3JtYXQsIHBhcnNlIH07XG4iLCAiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeRHVwbGV4fFJlYWRhYmxlJFwiLCBcImNhdWdodEVycm9yc1wiOiBcIm5vbmVcIiB9XSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpO1xuY29uc3QgdGxzID0gcmVxdWlyZSgndGxzJyk7XG5jb25zdCB7IHJhbmRvbUJ5dGVzLCBjcmVhdGVIYXNoIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IHsgRHVwbGV4LCBSZWFkYWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgndXJsJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlcicpO1xuY29uc3QgU2VuZGVyID0gcmVxdWlyZSgnLi9zZW5kZXInKTtcbmNvbnN0IHsgaXNCbG9iIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAgR1VJRCxcbiAga0Zvck9uRXZlbnRBdHRyaWJ1dGUsXG4gIGtMaXN0ZW5lcixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXQsXG4gIE5PT1Bcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3Qge1xuICBFdmVudFRhcmdldDogeyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyIH1cbn0gPSByZXF1aXJlKCcuL2V2ZW50LXRhcmdldCcpO1xuY29uc3QgeyBmb3JtYXQsIHBhcnNlIH0gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xuY29uc3QgeyB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCBjbG9zZVRpbWVvdXQgPSAzMCAqIDEwMDA7XG5jb25zdCBrQWJvcnRlZCA9IFN5bWJvbCgna0Fib3J0ZWQnKTtcbmNvbnN0IHByb3RvY29sVmVyc2lvbnMgPSBbOCwgMTNdO1xuY29uc3QgcmVhZHlTdGF0ZXMgPSBbJ0NPTk5FQ1RJTkcnLCAnT1BFTicsICdDTE9TSU5HJywgJ0NMT1NFRCddO1xuY29uc3Qgc3VicHJvdG9jb2xSZWdleCA9IC9eWyEjJCUmJyorXFwtLjAtOUEtWl5fYHxhLXp+XSskLztcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYFdlYlNvY2tldGAuXG4gICAqXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICAgKiBAcGFyYW0geyhTdHJpbmd8U3RyaW5nW10pfSBbcHJvdG9jb2xzXSBUaGUgc3VicHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9jbG9zZUNvZGUgPSAxMDA2O1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VNZXNzYWdlID0gRU1QVFlfQlVGRkVSO1xuICAgIHRoaXMuX2Nsb3NlVGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2Vycm9yRW1pdHRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wcm90b2NvbCA9ICcnO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ09OTkVDVElORztcbiAgICB0aGlzLl9yZWNlaXZlciA9IG51bGw7XG4gICAgdGhpcy5fc2VuZGVyID0gbnVsbDtcbiAgICB0aGlzLl9zb2NrZXQgPSBudWxsO1xuXG4gICAgaWYgKGFkZHJlc3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50ID0gMDtcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWRpcmVjdHMgPSAwO1xuXG4gICAgICBpZiAocHJvdG9jb2xzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHByb3RvY29scykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm90b2NvbHMgPT09ICdvYmplY3QnICYmIHByb3RvY29scyAhPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBwcm90b2NvbHM7XG4gICAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5pdEFzQ2xpZW50KHRoaXMsIGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2F1dG9Qb25nID0gb3B0aW9ucy5hdXRvUG9uZztcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9yIGhpc3RvcmljYWwgcmVhc29ucywgdGhlIGN1c3RvbSBcIm5vZGVidWZmZXJcIiB0eXBlIGlzIHVzZWQgYnkgdGhlIGRlZmF1bHRcbiAgICogaW5zdGVhZCBvZiBcImJsb2JcIi5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBiaW5hcnlUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9iaW5hcnlUeXBlO1xuICB9XG5cbiAgc2V0IGJpbmFyeVR5cGUodHlwZSkge1xuICAgIGlmICghQklOQVJZX1RZUEVTLmluY2x1ZGVzKHR5cGUpKSByZXR1cm47XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gdHlwZTtcblxuICAgIC8vXG4gICAgLy8gQWxsb3cgdG8gY2hhbmdlIGBiaW5hcnlUeXBlYCBvbiB0aGUgZmx5LlxuICAgIC8vXG4gICAgaWYgKHRoaXMuX3JlY2VpdmVyKSB0aGlzLl9yZWNlaXZlci5fYmluYXJ5VHlwZSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBidWZmZXJlZEFtb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkgcmV0dXJuIHRoaXMuX2J1ZmZlcmVkQW1vdW50O1xuXG4gICAgcmV0dXJuIHRoaXMuX3NvY2tldC5fd3JpdGFibGVTdGF0ZS5sZW5ndGggKyB0aGlzLl9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBleHRlbnNpb25zKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9leHRlbnNpb25zKS5qb2luKCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNQYXVzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdXNlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25jbG9zZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25lcnJvcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25vcGVuKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbm1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBwcm90b2NvbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2w7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByZWFkeVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkeVN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLl91cmw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIHRoZSBzb2NrZXQgYW5kIHRoZSBpbnRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyXG4gICAqICAgICBhbnkgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZFxuICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0U29ja2V0KHNvY2tldCwgaGVhZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKHtcbiAgICAgIGFsbG93U3luY2hyb25vdXNFdmVudHM6IG9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyxcbiAgICAgIGJpbmFyeVR5cGU6IHRoaXMuYmluYXJ5VHlwZSxcbiAgICAgIGV4dGVuc2lvbnM6IHRoaXMuX2V4dGVuc2lvbnMsXG4gICAgICBpc1NlcnZlcjogdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBtYXhQYXlsb2FkOiBvcHRpb25zLm1heFBheWxvYWQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IG9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG5cbiAgICBjb25zdCBzZW5kZXIgPSBuZXcgU2VuZGVyKHNvY2tldCwgdGhpcy5fZXh0ZW5zaW9ucywgb3B0aW9ucy5nZW5lcmF0ZU1hc2spO1xuXG4gICAgdGhpcy5fcmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICB0aGlzLl9zZW5kZXIgPSBzZW5kZXI7XG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgcmVjZWl2ZXJba1dlYlNvY2tldF0gPSB0aGlzO1xuICAgIHNlbmRlcltrV2ViU29ja2V0XSA9IHRoaXM7XG4gICAgc29ja2V0W2tXZWJTb2NrZXRdID0gdGhpcztcblxuICAgIHJlY2VpdmVyLm9uKCdjb25jbHVkZScsIHJlY2VpdmVyT25Db25jbHVkZSk7XG4gICAgcmVjZWl2ZXIub24oJ2RyYWluJywgcmVjZWl2ZXJPbkRyYWluKTtcbiAgICByZWNlaXZlci5vbignZXJyb3InLCByZWNlaXZlck9uRXJyb3IpO1xuICAgIHJlY2VpdmVyLm9uKCdtZXNzYWdlJywgcmVjZWl2ZXJPbk1lc3NhZ2UpO1xuICAgIHJlY2VpdmVyLm9uKCdwaW5nJywgcmVjZWl2ZXJPblBpbmcpO1xuICAgIHJlY2VpdmVyLm9uKCdwb25nJywgcmVjZWl2ZXJPblBvbmcpO1xuXG4gICAgc2VuZGVyLm9uZXJyb3IgPSBzZW5kZXJPbkVycm9yO1xuXG4gICAgLy9cbiAgICAvLyBUaGVzZSBtZXRob2RzIG1heSBub3QgYmUgYXZhaWxhYmxlIGlmIGBzb2NrZXRgIGlzIGp1c3QgYSBgRHVwbGV4YC5cbiAgICAvL1xuICAgIGlmIChzb2NrZXQuc2V0VGltZW91dCkgc29ja2V0LnNldFRpbWVvdXQoMCk7XG4gICAgaWYgKHNvY2tldC5zZXROb0RlbGF5KSBzb2NrZXQuc2V0Tm9EZWxheSgpO1xuXG4gICAgaWYgKGhlYWQubGVuZ3RoID4gMCkgc29ja2V0LnVuc2hpZnQoaGVhZCk7XG5cbiAgICBzb2NrZXQub24oJ2Nsb3NlJywgc29ja2V0T25DbG9zZSk7XG4gICAgc29ja2V0Lm9uKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgICBzb2NrZXQub24oJ2VuZCcsIHNvY2tldE9uRW5kKTtcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0Lk9QRU47XG4gICAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gIH1cblxuICAvKipcbiAgICogRW1pdCB0aGUgYCdjbG9zZSdgIGV2ZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW1pdENsb3NlKCkge1xuICAgIGlmICghdGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0uY2xlYW51cCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlY2VpdmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYSBjbG9zaW5nIGhhbmRzaGFrZS5cbiAgICpcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tK1xuICAgKiAgICAgLSAtIC18d3MuY2xvc2UoKXwtLT58Y2xvc2UgZnJhbWV8LS0+fHdzLmNsb3NlKCl8LSAtIC1cbiAgICogICAgfCAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tKyAgICAgfFxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgICAgICAgfFxuICAgKiBDTE9TSU5HICB8d3MuY2xvc2UoKXw8LS18Y2xvc2UgZnJhbWV8PC0tKy0tLS0tKyAgICAgICBDTE9TSU5HXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICB8XG4gICAqICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLSsgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLT58ZmlufCAtIC0gLSAtXG4gICAqICAgIHwgICAgICAgICArLS0tKyAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLStcbiAgICogICAgIC0gLSAtIC0gLXxmaW58PC0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICogICAgICAgICAgICAgICstLS0rXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29kZV0gU3RhdHVzIGNvZGUgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyKX0gW2RhdGFdIFRoZSByZWFzb24gd2h5IHRoZSBjb25uZWN0aW9uIGlzXG4gICAqICAgICBjbG9zaW5nXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNvZGUsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdXZWJTb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgdGhlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkJztcbiAgICAgIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0lORykge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCAmJlxuICAgICAgICAodGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkIHx8IHRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZClcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5fc2VuZGVyLmNsb3NlKGNvZGUsIGRhdGEsICF0aGlzLl9pc1NlcnZlciwgKGVycikgPT4ge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgaGFuZGxlZCBieSB0aGUgYCdlcnJvcidgIGxpc3RlbmVyIG9uIHRoZSBzb2NrZXQuIFdlIG9ubHlcbiAgICAgIC8vIHdhbnQgdG8ga25vdyBpZiB0aGUgY2xvc2UgZnJhbWUgaGFzIGJlZW4gc2VudCBoZXJlLlxuICAgICAgLy9cbiAgICAgIGlmIChlcnIpIHJldHVybjtcblxuICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSB0cnVlO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCB8fFxuICAgICAgICB0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWRcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzZXRDbG9zZVRpbWVyKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSBzb2NrZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBhdXNlKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5fc29ja2V0LnBhdXNlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFza10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcGluZyBpcyBzZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZGF0YTtcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gbWFzaztcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcbiAgICB0aGlzLl9zZW5kZXIucGluZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwb25nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBvbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG1hc2s7XG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBvbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWUgdGhlIHNvY2tldC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVzdW1lKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSB0aGlzLl9zb2NrZXQucmVzdW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmFyeV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeSBvclxuICAgKiAgICAgdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbXByZXNzXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj10cnVlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlXG4gICAqICAgICBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2tdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gZGF0YSBpcyB3cml0dGVuIG91dFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIGJpbmFyeTogdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnLFxuICAgICAgbWFzazogIXRoaXMuX2lzU2VydmVyLFxuICAgICAgY29tcHJlc3M6IHRydWUsXG4gICAgICBmaW46IHRydWUsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIGlmICghdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3NlbmRlci5zZW5kKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBvcHRzLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2libHkgY2xvc2UgdGhlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRlcm1pbmF0ZSgpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdXZWJTb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgdGhlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkJztcbiAgICAgIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgICB0aGlzLl9zb2NrZXQuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDT05ORUNUSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDT05ORUNUSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ09OTkVDVElORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ09OTkVDVElOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDT05ORUNUSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ09OTkVDVElORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gT1BFTlxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnT1BFTicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IE9QRU5cbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnT1BFTicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TRURcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NFRCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NFRCcpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0VEXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NFRCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NFRCcpXG59KTtcblxuW1xuICAnYmluYXJ5VHlwZScsXG4gICdidWZmZXJlZEFtb3VudCcsXG4gICdleHRlbnNpb25zJyxcbiAgJ2lzUGF1c2VkJyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3JlYWR5U3RhdGUnLFxuICAndXJsJ1xuXS5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgcHJvcGVydHksIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn0pO1xuXG4vL1xuLy8gQWRkIHRoZSBgb25vcGVuYCwgYG9uZXJyb3JgLCBgb25jbG9zZWAsIGFuZCBgb25tZXNzYWdlYCBhdHRyaWJ1dGVzLlxuLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NvbW1zLmh0bWwjdGhlLXdlYnNvY2tldC1pbnRlcmZhY2Vcbi8vXG5bJ29wZW4nLCAnZXJyb3InLCAnY2xvc2UnLCAnbWVzc2FnZSddLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgYG9uJHttZXRob2R9YCwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyhtZXRob2QpKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHJldHVybiBsaXN0ZW5lcltrTGlzdGVuZXJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHNldChoYW5kbGVyKSB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKG1ldGhvZCkpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihtZXRob2QsIGhhbmRsZXIsIHtcbiAgICAgICAgW2tGb3JPbkV2ZW50QXR0cmlidXRlXTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5XZWJTb2NrZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xuV2ViU29ja2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIFdlYlNvY2tldCBjbGllbnQuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgY2xpZW50IHRvIGluaXRpYWxpemVcbiAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICogQHBhcmFtIHtBcnJheX0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgYW55XG4gKiAgICAgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZCBtdWx0aXBsZVxuICogICAgIHRpbWVzIGluIHRoZSBzYW1lIHRpY2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b1Bvbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gKiAgICAgYXV0b21hdGljYWxseSBzZW5kIGEgcG9uZyBpbiByZXNwb25zZSB0byBhIHBpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmZpbmlzaFJlcXVlc3RdIEEgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIHVzZWQgdG9cbiAqICAgICBjdXN0b21pemUgdGhlIGhlYWRlcnMgb2YgZWFjaCBodHRwIHJlcXVlc3QgYmVmb3JlIGl0IGlzIHNlbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZm9sbG93UmVkaXJlY3RzPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byBmb2xsb3dcbiAqICAgICByZWRpcmVjdHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gKiAgICAgbWFza2luZyBrZXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oYW5kc2hha2VUaW1lb3V0XSBUaW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlXG4gKiAgICAgaGFuZHNoYWtlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTEwNDg1NzYwMF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlXG4gKiAgICAgc2l6ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFJlZGlyZWN0cz0xMF0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlZGlyZWN0c1xuICogICAgIGFsbG93ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5vcmlnaW5dIFZhbHVlIG9mIHRoZSBgT3JpZ2luYCBvclxuICogICAgIGBTZWMtV2ViU29ja2V0LU9yaWdpbmAgaGVhZGVyXG4gKiBAcGFyYW0geyhCb29sZWFufE9iamVjdCl9IFtvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlPXRydWVdIEVuYWJsZS9kaXNhYmxlXG4gKiAgICAgcGVybWVzc2FnZS1kZWZsYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJvdG9jb2xWZXJzaW9uPTEzXSBWYWx1ZSBvZiB0aGVcbiAqICAgICBgU2VjLVdlYlNvY2tldC1WZXJzaW9uYCBoZWFkZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0cnVlLFxuICAgIGF1dG9Qb25nOiB0cnVlLFxuICAgIHByb3RvY29sVmVyc2lvbjogcHJvdG9jb2xWZXJzaW9uc1sxXSxcbiAgICBtYXhQYXlsb2FkOiAxMDAgKiAxMDI0ICogMTAyNCxcbiAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0cnVlLFxuICAgIGZvbGxvd1JlZGlyZWN0czogZmFsc2UsXG4gICAgbWF4UmVkaXJlY3RzOiAxMCxcbiAgICAuLi5vcHRpb25zLFxuICAgIHNvY2tldFBhdGg6IHVuZGVmaW5lZCxcbiAgICBob3N0bmFtZTogdW5kZWZpbmVkLFxuICAgIHByb3RvY29sOiB1bmRlZmluZWQsXG4gICAgdGltZW91dDogdW5kZWZpbmVkLFxuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgaG9zdDogdW5kZWZpbmVkLFxuICAgIHBhdGg6IHVuZGVmaW5lZCxcbiAgICBwb3J0OiB1bmRlZmluZWRcbiAgfTtcblxuICB3ZWJzb2NrZXQuX2F1dG9Qb25nID0gb3B0cy5hdXRvUG9uZztcblxuICBpZiAoIXByb3RvY29sVmVyc2lvbnMuaW5jbHVkZXMob3B0cy5wcm90b2NvbFZlcnNpb24pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICBgVW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvbjogJHtvcHRzLnByb3RvY29sVmVyc2lvbn0gYCArXG4gICAgICAgIGAoc3VwcG9ydGVkIHZlcnNpb25zOiAke3Byb3RvY29sVmVyc2lvbnMuam9pbignLCAnKX0pYFxuICAgICk7XG4gIH1cblxuICBsZXQgcGFyc2VkVXJsO1xuXG4gIGlmIChhZGRyZXNzIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgcGFyc2VkVXJsID0gYWRkcmVzcztcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkVXJsID0gbmV3IFVSTChhZGRyZXNzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgVVJMOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgIHBhcnNlZFVybC5wcm90b2NvbCA9ICd3czonO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICBwYXJzZWRVcmwucHJvdG9jb2wgPSAnd3NzOic7XG4gIH1cblxuICB3ZWJzb2NrZXQuX3VybCA9IHBhcnNlZFVybC5ocmVmO1xuXG4gIGNvbnN0IGlzU2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3NzOic7XG4gIGNvbnN0IGlzSXBjVXJsID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3MrdW5peDonO1xuICBsZXQgaW52YWxpZFVybE1lc3NhZ2U7XG5cbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ3dzOicgJiYgIWlzU2VjdXJlICYmICFpc0lwY1VybCkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID1cbiAgICAgICdUaGUgVVJMXFwncyBwcm90b2NvbCBtdXN0IGJlIG9uZSBvZiBcIndzOlwiLCBcIndzczpcIiwgJyArXG4gICAgICAnXCJodHRwOlwiLCBcImh0dHBzXCIsIG9yIFwid3MrdW5peDpcIic7XG4gIH0gZWxzZSBpZiAoaXNJcGNVcmwgJiYgIXBhcnNlZFVybC5wYXRobmFtZSkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID0gXCJUaGUgVVJMJ3MgcGF0aG5hbWUgaXMgZW1wdHlcIjtcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwuaGFzaCkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID0gJ1RoZSBVUkwgY29udGFpbnMgYSBmcmFnbWVudCBpZGVudGlmaWVyJztcbiAgfVxuXG4gIGlmIChpbnZhbGlkVXJsTWVzc2FnZSkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihpbnZhbGlkVXJsTWVzc2FnZSk7XG5cbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRQb3J0ID0gaXNTZWN1cmUgPyA0NDMgOiA4MDtcbiAgY29uc3Qga2V5ID0gcmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgY29uc3QgcmVxdWVzdCA9IGlzU2VjdXJlID8gaHR0cHMucmVxdWVzdCA6IGh0dHAucmVxdWVzdDtcbiAgY29uc3QgcHJvdG9jb2xTZXQgPSBuZXcgU2V0KCk7XG4gIGxldCBwZXJNZXNzYWdlRGVmbGF0ZTtcblxuICBvcHRzLmNyZWF0ZUNvbm5lY3Rpb24gPVxuICAgIG9wdHMuY3JlYXRlQ29ubmVjdGlvbiB8fCAoaXNTZWN1cmUgPyB0bHNDb25uZWN0IDogbmV0Q29ubmVjdCk7XG4gIG9wdHMuZGVmYXVsdFBvcnQgPSBvcHRzLmRlZmF1bHRQb3J0IHx8IGRlZmF1bHRQb3J0O1xuICBvcHRzLnBvcnQgPSBwYXJzZWRVcmwucG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0cy5ob3N0ID0gcGFyc2VkVXJsLmhvc3RuYW1lLnN0YXJ0c1dpdGgoJ1snKVxuICAgID8gcGFyc2VkVXJsLmhvc3RuYW1lLnNsaWNlKDEsIC0xKVxuICAgIDogcGFyc2VkVXJsLmhvc3RuYW1lO1xuICBvcHRzLmhlYWRlcnMgPSB7XG4gICAgLi4ub3B0cy5oZWFkZXJzLFxuICAgICdTZWMtV2ViU29ja2V0LVZlcnNpb24nOiBvcHRzLnByb3RvY29sVmVyc2lvbixcbiAgICAnU2VjLVdlYlNvY2tldC1LZXknOiBrZXksXG4gICAgQ29ubmVjdGlvbjogJ1VwZ3JhZGUnLFxuICAgIFVwZ3JhZGU6ICd3ZWJzb2NrZXQnXG4gIH07XG4gIG9wdHMucGF0aCA9IHBhcnNlZFVybC5wYXRobmFtZSArIHBhcnNlZFVybC5zZWFyY2g7XG4gIG9wdHMudGltZW91dCA9IG9wdHMuaGFuZHNoYWtlVGltZW91dDtcblxuICBpZiAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgIHBlck1lc3NhZ2VEZWZsYXRlID0gbmV3IFBlck1lc3NhZ2VEZWZsYXRlKFxuICAgICAgb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSAhPT0gdHJ1ZSA/IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgOiB7fSxcbiAgICAgIGZhbHNlLFxuICAgICAgb3B0cy5tYXhQYXlsb2FkXG4gICAgKTtcbiAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyddID0gZm9ybWF0KHtcbiAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogcGVyTWVzc2FnZURlZmxhdGUub2ZmZXIoKVxuICAgIH0pO1xuICB9XG4gIGlmIChwcm90b2NvbHMubGVuZ3RoKSB7XG4gICAgZm9yIChjb25zdCBwcm90b2NvbCBvZiBwcm90b2NvbHMpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIHByb3RvY29sICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAhc3VicHJvdG9jb2xSZWdleC50ZXN0KHByb3RvY29sKSB8fFxuICAgICAgICBwcm90b2NvbFNldC5oYXMocHJvdG9jb2wpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgICdBbiBpbnZhbGlkIG9yIGR1cGxpY2F0ZWQgc3VicHJvdG9jb2wgd2FzIHNwZWNpZmllZCdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcHJvdG9jb2xTZXQuYWRkKHByb3RvY29sKTtcbiAgICB9XG5cbiAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnXSA9IHByb3RvY29scy5qb2luKCcsJyk7XG4gIH1cbiAgaWYgKG9wdHMub3JpZ2luKSB7XG4gICAgaWYgKG9wdHMucHJvdG9jb2xWZXJzaW9uIDwgMTMpIHtcbiAgICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1PcmlnaW4nXSA9IG9wdHMub3JpZ2luO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzLmhlYWRlcnMuT3JpZ2luID0gb3B0cy5vcmlnaW47XG4gICAgfVxuICB9XG4gIGlmIChwYXJzZWRVcmwudXNlcm5hbWUgfHwgcGFyc2VkVXJsLnBhc3N3b3JkKSB7XG4gICAgb3B0cy5hdXRoID0gYCR7cGFyc2VkVXJsLnVzZXJuYW1lfToke3BhcnNlZFVybC5wYXNzd29yZH1gO1xuICB9XG5cbiAgaWYgKGlzSXBjVXJsKSB7XG4gICAgY29uc3QgcGFydHMgPSBvcHRzLnBhdGguc3BsaXQoJzonKTtcblxuICAgIG9wdHMuc29ja2V0UGF0aCA9IHBhcnRzWzBdO1xuICAgIG9wdHMucGF0aCA9IHBhcnRzWzFdO1xuICB9XG5cbiAgbGV0IHJlcTtcblxuICBpZiAob3B0cy5mb2xsb3dSZWRpcmVjdHMpIHtcbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxJcGMgPSBpc0lwY1VybDtcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxTZWN1cmUgPSBpc1NlY3VyZTtcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoID0gaXNJcGNVcmxcbiAgICAgICAgPyBvcHRzLnNvY2tldFBhdGhcbiAgICAgICAgOiBwYXJzZWRVcmwuaG9zdDtcblxuICAgICAgY29uc3QgaGVhZGVycyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5oZWFkZXJzO1xuXG4gICAgICAvL1xuICAgICAgLy8gU2hhbGxvdyBjb3B5IHRoZSB1c2VyIHByb3ZpZGVkIG9wdGlvbnMgc28gdGhhdCBoZWFkZXJzIGNhbiBiZSBjaGFuZ2VkXG4gICAgICAvLyB3aXRob3V0IG11dGF0aW5nIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICAvL1xuICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgaGVhZGVyczoge30gfTtcblxuICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAgICAgICBvcHRpb25zLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHdlYnNvY2tldC5saXN0ZW5lckNvdW50KCdyZWRpcmVjdCcpID09PSAwKSB7XG4gICAgICBjb25zdCBpc1NhbWVIb3N0ID0gaXNJcGNVcmxcbiAgICAgICAgPyB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjXG4gICAgICAgICAgPyBvcHRzLnNvY2tldFBhdGggPT09IHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoXG4gICAgICAgICAgOiBmYWxzZVxuICAgICAgICA6IHdlYnNvY2tldC5fb3JpZ2luYWxJcGNcbiAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgOiBwYXJzZWRVcmwuaG9zdCA9PT0gd2Vic29ja2V0Ll9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGg7XG5cbiAgICAgIGlmICghaXNTYW1lSG9zdCB8fCAod2Vic29ja2V0Ll9vcmlnaW5hbFNlY3VyZSAmJiAhaXNTZWN1cmUpKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIE1hdGNoIGN1cmwgNy43Ny4wIGJlaGF2aW9yIGFuZCBkcm9wIHRoZSBmb2xsb3dpbmcgaGVhZGVycy4gVGhlc2VcbiAgICAgICAgLy8gaGVhZGVycyBhcmUgYWxzbyBkcm9wcGVkIHdoZW4gZm9sbG93aW5nIGEgcmVkaXJlY3QgdG8gYSBzdWJkb21haW4uXG4gICAgICAgIC8vXG4gICAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuYXV0aG9yaXphdGlvbjtcbiAgICAgICAgZGVsZXRlIG9wdHMuaGVhZGVycy5jb29raWU7XG5cbiAgICAgICAgaWYgKCFpc1NhbWVIb3N0KSBkZWxldGUgb3B0cy5oZWFkZXJzLmhvc3Q7XG5cbiAgICAgICAgb3B0cy5hdXRoID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gTWF0Y2ggY3VybCA3Ljc3LjAgYmVoYXZpb3IgYW5kIG1ha2UgdGhlIGZpcnN0IGBBdXRob3JpemF0aW9uYCBoZWFkZXIgd2luLlxuICAgIC8vIElmIHRoZSBgQXV0aG9yaXphdGlvbmAgaGVhZGVyIGlzIHNldCwgdGhlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGRvIGFzIGl0XG4gICAgLy8gd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gICAgLy9cbiAgICBpZiAob3B0cy5hdXRoICYmICFvcHRpb25zLmhlYWRlcnMuYXV0aG9yaXphdGlvbikge1xuICAgICAgb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24gPVxuICAgICAgICAnQmFzaWMgJyArIEJ1ZmZlci5mcm9tKG9wdHMuYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH1cblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gcmVxdWVzdChvcHRzKTtcblxuICAgIGlmICh3ZWJzb2NrZXQuX3JlZGlyZWN0cykge1xuICAgICAgLy9cbiAgICAgIC8vIFVubGlrZSB3aGF0IGlzIGRvbmUgZm9yIHRoZSBgJ3VwZ3JhZGUnYCBldmVudCwgbm8gZWFybHkgZXhpdCBpc1xuICAgICAgLy8gdHJpZ2dlcmVkIGhlcmUgaWYgdGhlIHVzZXIgY2FsbHMgYHdlYnNvY2tldC5jbG9zZSgpYCBvclxuICAgICAgLy8gYHdlYnNvY2tldC50ZXJtaW5hdGUoKWAgZnJvbSBhIGxpc3RlbmVyIG9mIHRoZSBgJ3JlZGlyZWN0J2AgZXZlbnQuIFRoaXNcbiAgICAgIC8vIGlzIGJlY2F1c2UgdGhlIHVzZXIgY2FuIGFsc28gY2FsbCBgcmVxdWVzdC5kZXN0cm95KClgIHdpdGggYW4gZXJyb3JcbiAgICAgIC8vIGJlZm9yZSBjYWxsaW5nIGB3ZWJzb2NrZXQuY2xvc2UoKWAgb3IgYHdlYnNvY2tldC50ZXJtaW5hdGUoKWAgYW5kIHRoaXNcbiAgICAgIC8vIHdvdWxkIHJlc3VsdCBpbiBhbiBlcnJvciBiZWluZyBlbWl0dGVkIG9uIHRoZSBgcmVxdWVzdGAgb2JqZWN0IHdpdGggbm9cbiAgICAgIC8vIGAnZXJyb3InYCBldmVudCBsaXN0ZW5lcnMgYXR0YWNoZWQuXG4gICAgICAvL1xuICAgICAgd2Vic29ja2V0LmVtaXQoJ3JlZGlyZWN0Jywgd2Vic29ja2V0LnVybCwgcmVxKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSByZXF1ZXN0KG9wdHMpO1xuICB9XG5cbiAgaWYgKG9wdHMudGltZW91dCkge1xuICAgIHJlcS5vbigndGltZW91dCcsICgpID0+IHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnT3BlbmluZyBoYW5kc2hha2UgaGFzIHRpbWVkIG91dCcpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVxLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICBpZiAocmVxID09PSBudWxsIHx8IHJlcVtrQWJvcnRlZF0pIHJldHVybjtcblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gbnVsbDtcbiAgICBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycik7XG4gIH0pO1xuXG4gIHJlcS5vbigncmVzcG9uc2UnLCAocmVzKSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSByZXMuaGVhZGVycy5sb2NhdGlvbjtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XG5cbiAgICBpZiAoXG4gICAgICBsb2NhdGlvbiAmJlxuICAgICAgb3B0cy5mb2xsb3dSZWRpcmVjdHMgJiZcbiAgICAgIHN0YXR1c0NvZGUgPj0gMzAwICYmXG4gICAgICBzdGF0dXNDb2RlIDwgNDAwXG4gICAgKSB7XG4gICAgICBpZiAoKyt3ZWJzb2NrZXQuX3JlZGlyZWN0cyA+IG9wdHMubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnTWF4aW11bSByZWRpcmVjdHMgZXhjZWVkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXEuYWJvcnQoKTtcblxuICAgICAgbGV0IGFkZHI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGFkZHIgPSBuZXcgVVJMKGxvY2F0aW9uLCBhZGRyZXNzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIFVSTDogJHtsb2NhdGlvbn1gKTtcbiAgICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQsIGFkZHIsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICghd2Vic29ja2V0LmVtaXQoJ3VuZXhwZWN0ZWQtcmVzcG9uc2UnLCByZXEsIHJlcykpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKFxuICAgICAgICB3ZWJzb2NrZXQsXG4gICAgICAgIHJlcSxcbiAgICAgICAgYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlOiAke3Jlcy5zdGF0dXNDb2RlfWBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICByZXEub24oJ3VwZ3JhZGUnLCAocmVzLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICB3ZWJzb2NrZXQuZW1pdCgndXBncmFkZScsIHJlcyk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSB1c2VyIG1heSBoYXZlIGNsb3NlZCB0aGUgY29ubmVjdGlvbiBmcm9tIGEgbGlzdGVuZXIgb2YgdGhlXG4gICAgLy8gYCd1cGdyYWRlJ2AgZXZlbnQuXG4gICAgLy9cbiAgICBpZiAod2Vic29ja2V0LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSByZXR1cm47XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XG5cbiAgICBjb25zdCB1cGdyYWRlID0gcmVzLmhlYWRlcnMudXBncmFkZTtcblxuICAgIGlmICh1cGdyYWRlID09PSB1bmRlZmluZWQgfHwgdXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0Jykge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsICdJbnZhbGlkIFVwZ3JhZGUgaGVhZGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGlmIChyZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1hY2NlcHQnXSAhPT0gZGlnZXN0KSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyUHJvdCA9IHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ107XG4gICAgbGV0IHByb3RFcnJvcjtcblxuICAgIGlmIChzZXJ2ZXJQcm90ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghcHJvdG9jb2xTZXQuc2l6ZSkge1xuICAgICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYSBzdWJwcm90b2NvbCBidXQgbm9uZSB3YXMgcmVxdWVzdGVkJztcbiAgICAgIH0gZWxzZSBpZiAoIXByb3RvY29sU2V0LmhhcyhzZXJ2ZXJQcm90KSkge1xuICAgICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYW4gaW52YWxpZCBzdWJwcm90b2NvbCc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm90b2NvbFNldC5zaXplKSB7XG4gICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgbm8gc3VicHJvdG9jb2wnO1xuICAgIH1cblxuICAgIGlmIChwcm90RXJyb3IpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBwcm90RXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzZXJ2ZXJQcm90KSB3ZWJzb2NrZXQuX3Byb3RvY29sID0gc2VydmVyUHJvdDtcblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XG5cbiAgICBpZiAoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgICdTZXJ2ZXIgc2VudCBhIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXIgYnV0IG5vIGV4dGVuc2lvbiAnICtcbiAgICAgICAgICAnd2FzIHJlcXVlc3RlZCc7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZXh0ZW5zaW9ucztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZXh0ZW5zaW9ucyA9IHBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4dGVuc2lvbk5hbWVzID0gT2JqZWN0LmtleXMoZXh0ZW5zaW9ucyk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgZXh0ZW5zaW9uTmFtZXMubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgIGV4dGVuc2lvbk5hbWVzWzBdICE9PSBQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdTZXJ2ZXIgaW5kaWNhdGVkIGFuIGV4dGVuc2lvbiB0aGF0IHdhcyBub3QgcmVxdWVzdGVkJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3ZWJzb2NrZXQuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPVxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICB9XG5cbiAgICB3ZWJzb2NrZXQuc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogb3B0cy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzLFxuICAgICAgZ2VuZXJhdGVNYXNrOiBvcHRzLmdlbmVyYXRlTWFzayxcbiAgICAgIG1heFBheWxvYWQ6IG9wdHMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogb3B0cy5za2lwVVRGOFZhbGlkYXRpb25cbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKG9wdHMuZmluaXNoUmVxdWVzdCkge1xuICAgIG9wdHMuZmluaXNoUmVxdWVzdChyZXEsIHdlYnNvY2tldCk7XG4gIH0gZWxzZSB7XG4gICAgcmVxLmVuZCgpO1xuICB9XG59XG5cbi8qKlxuICogRW1pdCB0aGUgYCdlcnJvcidgIGFuZCBgJ2Nsb3NlJ2AgZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHtFcnJvcn0gVGhlIGVycm9yIHRvIGVtaXRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKSB7XG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGFzc2lnbm1lbnQgaXMgcHJhY3RpY2FsbHkgdXNlbGVzcyBhbmQgaXMgZG9uZSBvbmx5IGZvclxuICAvLyBjb25zaXN0ZW5jeS5cbiAgLy9cbiAgd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYG5ldC5Tb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtuZXQuU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbmV0Q29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IG9wdGlvbnMuc29ja2V0UGF0aDtcbiAgcmV0dXJuIG5ldC5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGB0bHMuVExTU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHJldHVybiB7dGxzLlRMU1NvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRsc0Nvbm5lY3Qob3B0aW9ucykge1xuICBvcHRpb25zLnBhdGggPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCFvcHRpb25zLnNlcnZlcm5hbWUgJiYgb3B0aW9ucy5zZXJ2ZXJuYW1lICE9PSAnJykge1xuICAgIG9wdGlvbnMuc2VydmVybmFtZSA9IG5ldC5pc0lQKG9wdGlvbnMuaG9zdCkgPyAnJyA6IG9wdGlvbnMuaG9zdDtcbiAgfVxuXG4gIHJldHVybiB0bHMuY29ubmVjdChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBBYm9ydCB0aGUgaGFuZHNoYWtlIGFuZCBlbWl0IGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHsoaHR0cC5DbGllbnRSZXF1ZXN0fG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHN0cmVhbSBUaGUgcmVxdWVzdCB0b1xuICogICAgIGFib3J0IG9yIHRoZSBzb2NrZXQgdG8gZGVzdHJveVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc3RyZWFtLCBtZXNzYWdlKSB7XG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZSk7XG5cbiAgaWYgKHN0cmVhbS5zZXRIZWFkZXIpIHtcbiAgICBzdHJlYW1ba0Fib3J0ZWRdID0gdHJ1ZTtcbiAgICBzdHJlYW0uYWJvcnQoKTtcblxuICAgIGlmIChzdHJlYW0uc29ja2V0ICYmICFzdHJlYW0uc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgLy9cbiAgICAgIC8vIE9uIE5vZGUuanMgPj0gMTQuMy4wIGByZXF1ZXN0LmFib3J0KClgIGRvZXMgbm90IGRlc3Ryb3kgdGhlIHNvY2tldCBpZlxuICAgICAgLy8gY2FsbGVkIGFmdGVyIHRoZSByZXF1ZXN0IGNvbXBsZXRlZC4gU2VlXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTg2OS5cbiAgICAgIC8vXG4gICAgICBzdHJlYW0uc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlLCB3ZWJzb2NrZXQsIGVycik7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKTtcbiAgICBzdHJlYW0ub25jZSgnZXJyb3InLCB3ZWJzb2NrZXQuZW1pdC5iaW5kKHdlYnNvY2tldCwgJ2Vycm9yJykpO1xuICAgIHN0cmVhbS5vbmNlKCdjbG9zZScsIHdlYnNvY2tldC5lbWl0Q2xvc2UuYmluZCh3ZWJzb2NrZXQpKTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBjYXNlcyB3aGVyZSB0aGUgYHBpbmcoKWAsIGBwb25nKClgLCBvciBgc2VuZCgpYCBtZXRob2RzIGFyZSBjYWxsZWRcbiAqIHdoZW4gdGhlIGByZWFkeVN0YXRlYCBhdHRyaWJ1dGUgaXMgYENMT1NJTkdgIG9yIGBDTE9TRURgLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2VuZEFmdGVyQ2xvc2Uod2Vic29ja2V0LCBkYXRhLCBjYikge1xuICBpZiAoZGF0YSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGlzQmxvYihkYXRhKSA/IGRhdGEuc2l6ZSA6IHRvQnVmZmVyKGRhdGEpLmxlbmd0aDtcblxuICAgIC8vXG4gICAgLy8gVGhlIGBfYnVmZmVyZWRBbW91bnRgIHByb3BlcnR5IGlzIHVzZWQgb25seSB3aGVuIHRoZSBwZWVyIGlzIGEgY2xpZW50IGFuZFxuICAgIC8vIHRoZSBvcGVuaW5nIGhhbmRzaGFrZSBmYWlscy4gVW5kZXIgdGhlc2UgY2lyY3Vtc3RhbmNlcywgaW4gZmFjdCwgdGhlXG4gICAgLy8gYHNldFNvY2tldCgpYCBtZXRob2QgaXMgbm90IGNhbGxlZCwgc28gdGhlIGBfc29ja2V0YCBhbmQgYF9zZW5kZXJgXG4gICAgLy8gcHJvcGVydGllcyBhcmUgc2V0IHRvIGBudWxsYC5cbiAgICAvL1xuICAgIGlmICh3ZWJzb2NrZXQuX3NvY2tldCkgd2Vic29ja2V0Ll9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXMgKz0gbGVuZ3RoO1xuICAgIGVsc2Ugd2Vic29ja2V0Ll9idWZmZXJlZEFtb3VudCArPSBsZW5ndGg7XG4gIH1cblxuICBpZiAoY2IpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICBgV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlICR7d2Vic29ja2V0LnJlYWR5U3RhdGV9IGAgK1xuICAgICAgICBgKCR7cmVhZHlTdGF0ZXNbd2Vic29ja2V0LnJlYWR5U3RhdGVdfSlgXG4gICAgKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnY29uY2x1ZGUnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7QnVmZmVyfSByZWFzb24gVGhlIHJlYXNvbiBmb3IgY2xvc2luZ1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkNvbmNsdWRlKGNvZGUsIHJlYXNvbikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkID0gdHJ1ZTtcbiAgd2Vic29ja2V0Ll9jbG9zZU1lc3NhZ2UgPSByZWFzb247XG4gIHdlYnNvY2tldC5fY2xvc2VDb2RlID0gY29kZTtcblxuICBpZiAod2Vic29ja2V0Ll9zb2NrZXRba1dlYlNvY2tldF0gPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gIHdlYnNvY2tldC5fc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWUsIHdlYnNvY2tldC5fc29ja2V0KTtcblxuICBpZiAoY29kZSA9PT0gMTAwNSkgd2Vic29ja2V0LmNsb3NlKCk7XG4gIGVsc2Ugd2Vic29ja2V0LmNsb3NlKGNvZGUsIHJlYXNvbik7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZHJhaW4nYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRHJhaW4oKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgaWYgKCF3ZWJzb2NrZXQuaXNQYXVzZWQpIHdlYnNvY2tldC5fc29ja2V0LnJlc3VtZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoUmFuZ2VFcnJvcnxFcnJvcil9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkVycm9yKGVycikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICh3ZWJzb2NrZXQuX3NvY2tldFtrV2ViU29ja2V0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd2Vic29ja2V0Ll9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuXG4gICAgLy9cbiAgICAvLyBPbiBOb2RlLmpzIDwgMTQuMC4wIHRoZSBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCBzeW5jaHJvbm91c2x5LiBTZWVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTk0MC5cbiAgICAvL1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XG5cbiAgICB3ZWJzb2NrZXQuY2xvc2UoZXJyW2tTdGF0dXNDb2RlXSk7XG4gIH1cblxuICBpZiAoIXdlYnNvY2tldC5fZXJyb3JFbWl0dGVkKSB7XG4gICAgd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdmaW5pc2gnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRmluaXNoKCkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXRDbG9zZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ21lc3NhZ2UnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheUJ1ZmZlcnxCdWZmZXJbXSl9IGRhdGEgVGhlIG1lc3NhZ2VcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCaW5hcnkgU3BlY2lmaWVzIHdoZXRoZXIgdGhlIG1lc3NhZ2UgaXMgYmluYXJ5IG9yIG5vdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdtZXNzYWdlJywgZGF0YSwgaXNCaW5hcnkpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BpbmcnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGUgcGluZyBmcmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPblBpbmcoZGF0YSkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICh3ZWJzb2NrZXQuX2F1dG9Qb25nKSB3ZWJzb2NrZXQucG9uZyhkYXRhLCAhdGhpcy5faXNTZXJ2ZXIsIE5PT1ApO1xuICB3ZWJzb2NrZXQuZW1pdCgncGluZycsIGRhdGEpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BvbmcnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGUgcG9uZyBmcmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPblBvbmcoZGF0YSkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ3BvbmcnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBSZXN1bWUgYSByZWFkYWJsZSBzdHJlYW1cbiAqXG4gKiBAcGFyYW0ge1JlYWRhYmxlfSBzdHJlYW0gVGhlIHJlYWRhYmxlIHN0cmVhbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSkge1xuICBzdHJlYW0ucmVzdW1lKCk7XG59XG5cbi8qKlxuICogVGhlIGBTZW5kZXJgIGVycm9yIGV2ZW50IGhhbmRsZXIuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gVGhlIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZW5kZXJPbkVycm9yKGVycikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICh3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICBpZiAod2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgc2V0Q2xvc2VUaW1lcih3ZWJzb2NrZXQpO1xuICB9XG5cbiAgLy9cbiAgLy8gYHNvY2tldC5lbmQoKWAgaXMgdXNlZCBpbnN0ZWFkIG9mIGBzb2NrZXQuZGVzdHJveSgpYCB0byBhbGxvdyB0aGUgb3RoZXJcbiAgLy8gcGVlciB0byBmaW5pc2ggc2VuZGluZyBxdWV1ZWQgZGF0YS4gVGhlcmUgaXMgbm8gbmVlZCB0byBzZXQgYSB0aW1lciBoZXJlXG4gIC8vIGJlY2F1c2UgYENMT1NJTkdgIG1lYW5zIHRoYXQgaXQgaXMgYWxyZWFkeSBzZXQgb3Igbm90IG5lZWRlZC5cbiAgLy9cbiAgdGhpcy5fc29ja2V0LmVuZCgpO1xuXG4gIGlmICghd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQpIHtcbiAgICB3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldCBhIHRpbWVyIHRvIGRlc3Ryb3kgdGhlIHVuZGVybHlpbmcgcmF3IHNvY2tldCBvZiBhIFdlYlNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldENsb3NlVGltZXIod2Vic29ja2V0KSB7XG4gIHdlYnNvY2tldC5fY2xvc2VUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgd2Vic29ja2V0Ll9zb2NrZXQuZGVzdHJveS5iaW5kKHdlYnNvY2tldC5fc29ja2V0KSxcbiAgICBjbG9zZVRpbWVvdXRcbiAgKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2Nsb3NlJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25DbG9zZSgpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHNvY2tldE9uQ2xvc2UpO1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZW5kJywgc29ja2V0T25FbmQpO1xuXG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIGxldCBjaHVuaztcblxuICAvL1xuICAvLyBUaGUgY2xvc2UgZnJhbWUgbWlnaHQgbm90IGhhdmUgYmVlbiByZWNlaXZlZCBvciB0aGUgYCdlbmQnYCBldmVudCBlbWl0dGVkLFxuICAvLyBmb3IgZXhhbXBsZSwgaWYgdGhlIHNvY2tldCB3YXMgZGVzdHJveWVkIGR1ZSB0byBhbiBlcnJvci4gRW5zdXJlIHRoYXQgdGhlXG4gIC8vIGByZWNlaXZlcmAgc3RyZWFtIGlzIGNsb3NlZCBhZnRlciB3cml0aW5nIGFueSByZW1haW5pbmcgYnVmZmVyZWQgZGF0YSB0b1xuICAvLyBpdC4gSWYgdGhlIHJlYWRhYmxlIHNpZGUgb2YgdGhlIHNvY2tldCBpcyBpbiBmbG93aW5nIG1vZGUgdGhlbiB0aGVyZSBpcyBub1xuICAvLyBidWZmZXJlZCBkYXRhIGFzIGV2ZXJ5dGhpbmcgaGFzIGJlZW4gYWxyZWFkeSB3cml0dGVuIGFuZCBgcmVhZGFibGUucmVhZCgpYFxuICAvLyB3aWxsIHJldHVybiBgbnVsbGAuIElmIGluc3RlYWQsIHRoZSBzb2NrZXQgaXMgcGF1c2VkLCBhbnkgcG9zc2libGUgYnVmZmVyZWRcbiAgLy8gZGF0YSB3aWxsIGJlIHJlYWQgYXMgYSBzaW5nbGUgY2h1bmsuXG4gIC8vXG4gIGlmIChcbiAgICAhdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkICYmXG4gICAgIXdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkICYmXG4gICAgIXdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkICYmXG4gICAgKGNodW5rID0gd2Vic29ja2V0Ll9zb2NrZXQucmVhZCgpKSAhPT0gbnVsbFxuICApIHtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLndyaXRlKGNodW5rKTtcbiAgfVxuXG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG5cbiAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcblxuICBjbGVhclRpbWVvdXQod2Vic29ja2V0Ll9jbG9zZVRpbWVyKTtcblxuICBpZiAoXG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCB8fFxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkXG4gICkge1xuICAgIHdlYnNvY2tldC5lbWl0Q2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdlcnJvcicsIHJlY2VpdmVyT25GaW5pc2gpO1xuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIub24oJ2ZpbmlzaCcsIHJlY2VpdmVyT25GaW5pc2gpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25EYXRhKGNodW5rKSB7XG4gIGlmICghdGhpc1trV2ViU29ja2V0XS5fcmVjZWl2ZXIud3JpdGUoY2h1bmspKSB7XG4gICAgdGhpcy5wYXVzZSgpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdlbmQnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVuZCgpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgd2Vic29ja2V0Ll9yZWNlaXZlci5lbmQoKTtcbiAgdGhpcy5lbmQoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FcnJvcigpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuICB0aGlzLm9uKCdlcnJvcicsIE5PT1ApO1xuXG4gIGlmICh3ZWJzb2NrZXQpIHtcbiAgICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfVxufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vKipcbiAqIEVtaXRzIHRoZSBgJ2Nsb3NlJ2AgZXZlbnQgb24gYSBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtEdXBsZXh9IHN0cmVhbSBUaGUgc3RyZWFtLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdENsb3NlKHN0cmVhbSkge1xuICBzdHJlYW0uZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZHVwbGV4T25FbmQoKSB7XG4gIGlmICghdGhpcy5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkge1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZHVwbGV4T25FcnJvcihlcnIpIHtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBkdXBsZXhPbkVycm9yKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ2Vycm9yJykgPT09IDApIHtcbiAgICAvLyBEbyBub3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yLlxuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogV3JhcHMgYSBgV2ViU29ja2V0YCBpbiBhIGR1cGxleCBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdzIFRoZSBgV2ViU29ja2V0YCB0byB3cmFwXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGZvciB0aGUgYER1cGxleGAgY29uc3RydWN0b3JcbiAqIEByZXR1cm4ge0R1cGxleH0gVGhlIGR1cGxleCBzdHJlYW1cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlV2ViU29ja2V0U3RyZWFtKHdzLCBvcHRpb25zKSB7XG4gIGxldCB0ZXJtaW5hdGVPbkRlc3Ryb3kgPSB0cnVlO1xuXG4gIGNvbnN0IGR1cGxleCA9IG5ldyBEdXBsZXgoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgYXV0b0Rlc3Ryb3k6IGZhbHNlLFxuICAgIGVtaXRDbG9zZTogZmFsc2UsXG4gICAgb2JqZWN0TW9kZTogZmFsc2UsXG4gICAgd3JpdGFibGVPYmplY3RNb2RlOiBmYWxzZVxuICB9KTtcblxuICB3cy5vbignbWVzc2FnZScsIGZ1bmN0aW9uIG1lc3NhZ2UobXNnLCBpc0JpbmFyeSkge1xuICAgIGNvbnN0IGRhdGEgPVxuICAgICAgIWlzQmluYXJ5ICYmIGR1cGxleC5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlID8gbXNnLnRvU3RyaW5nKCkgOiBtc2c7XG5cbiAgICBpZiAoIWR1cGxleC5wdXNoKGRhdGEpKSB3cy5wYXVzZSgpO1xuICB9KTtcblxuICB3cy5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgIGlmIChkdXBsZXguZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICAvLyBQcmV2ZW50IGB3cy50ZXJtaW5hdGUoKWAgZnJvbSBiZWluZyBjYWxsZWQgYnkgYGR1cGxleC5fZGVzdHJveSgpYC5cbiAgICAvL1xuICAgIC8vIC0gSWYgdGhlIGAnZXJyb3InYCBldmVudCBpcyBlbWl0dGVkIGJlZm9yZSB0aGUgYCdvcGVuJ2AgZXZlbnQsIHRoZW5cbiAgICAvLyAgIGB3cy50ZXJtaW5hdGUoKWAgaXMgYSBub29wIGFzIG5vIHNvY2tldCBpcyBhc3NpZ25lZC5cbiAgICAvLyAtIE90aGVyd2lzZSwgdGhlIGVycm9yIGlzIHJlLWVtaXR0ZWQgYnkgdGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2Vycm9yJ2BcbiAgICAvLyAgIGV2ZW50IG9mIHRoZSBgUmVjZWl2ZXJgIG9iamVjdC4gVGhlIGxpc3RlbmVyIGFscmVhZHkgY2xvc2VzIHRoZVxuICAgIC8vICAgY29ubmVjdGlvbiBieSBjYWxsaW5nIGB3cy5jbG9zZSgpYC4gVGhpcyBhbGxvd3MgYSBjbG9zZSBmcmFtZSB0byBiZVxuICAgIC8vICAgc2VudCB0byB0aGUgb3RoZXIgcGVlci4gSWYgYHdzLnRlcm1pbmF0ZSgpYCBpcyBjYWxsZWQgcmlnaHQgYWZ0ZXIgdGhpcyxcbiAgICAvLyAgIHRoZW4gdGhlIGNsb3NlIGZyYW1lIG1pZ2h0IG5vdCBiZSBzZW50LlxuICAgIHRlcm1pbmF0ZU9uRGVzdHJveSA9IGZhbHNlO1xuICAgIGR1cGxleC5kZXN0cm95KGVycik7XG4gIH0pO1xuXG4gIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgaWYgKGR1cGxleC5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgIGR1cGxleC5wdXNoKG51bGwpO1xuICB9KTtcblxuICBkdXBsZXguX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DTE9TRUQpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgZHVwbGV4KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG5cbiAgICB3cy5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG5cbiAgICB3cy5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgaWYgKCFjYWxsZWQpIGNhbGxiYWNrKGVycik7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgZHVwbGV4KTtcbiAgICB9KTtcblxuICAgIGlmICh0ZXJtaW5hdGVPbkRlc3Ryb3kpIHdzLnRlcm1pbmF0ZSgpO1xuICB9O1xuXG4gIGR1cGxleC5fZmluYWwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ09OTkVDVElORykge1xuICAgICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIGR1cGxleC5fZmluYWwoY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBgX3NvY2tldGAgcHJvcGVydHkgaXMgYG51bGxgIGl0IG1lYW5zIHRoYXQgYHdzYCBpcyBhXG4gICAgLy8gY2xpZW50IHdlYnNvY2tldCBhbmQgdGhlIGhhbmRzaGFrZSBmYWlsZWQuIEluIGZhY3QsIHdoZW4gdGhpcyBoYXBwZW5zLCBhXG4gICAgLy8gc29ja2V0IGlzIG5ldmVyIGFzc2lnbmVkIHRvIHRoZSB3ZWJzb2NrZXQuIFdhaXQgZm9yIHRoZSBgJ2Vycm9yJ2AgZXZlbnRcbiAgICAvLyB0aGF0IHdpbGwgYmUgZW1pdHRlZCBieSB0aGUgd2Vic29ja2V0LlxuICAgIGlmICh3cy5fc29ja2V0ID09PSBudWxsKSByZXR1cm47XG5cbiAgICBpZiAod3MuX3NvY2tldC5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIGlmIChkdXBsZXguX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkgZHVwbGV4LmRlc3Ryb3koKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3MuX3NvY2tldC5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICAgIC8vIGBkdXBsZXhgIGlzIG5vdCBkZXN0cm95ZWQgaGVyZSBiZWNhdXNlIHRoZSBgJ2VuZCdgIGV2ZW50IHdpbGwgYmVcbiAgICAgICAgLy8gZW1pdHRlZCBvbiBgZHVwbGV4YCBhZnRlciB0aGlzIGAnZmluaXNoJ2AgZXZlbnQuIFRoZSBFT0Ygc2lnbmFsaW5nXG4gICAgICAgIC8vIGBudWxsYCBjaHVuayBpcywgaW4gZmFjdCwgcHVzaGVkIHdoZW4gdGhlIHdlYnNvY2tldCBlbWl0cyBgJ2Nsb3NlJ2AuXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICAgIHdzLmNsb3NlKCk7XG4gICAgfVxuICB9O1xuXG4gIGR1cGxleC5fcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAod3MuaXNQYXVzZWQpIHdzLnJlc3VtZSgpO1xuICB9O1xuXG4gIGR1cGxleC5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgICB3cy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZHVwbGV4Ll93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdzLnNlbmQoY2h1bmssIGNhbGxiYWNrKTtcbiAgfTtcblxuICBkdXBsZXgub24oJ2VuZCcsIGR1cGxleE9uRW5kKTtcbiAgZHVwbGV4Lm9uKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xuICByZXR1cm4gZHVwbGV4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVdlYlNvY2tldFN0cmVhbTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgdG9rZW5DaGFycyB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbi8qKlxuICogUGFyc2VzIHRoZSBgU2VjLVdlYlNvY2tldC1Qcm90b2NvbGAgaGVhZGVyIGludG8gYSBzZXQgb2Ygc3VicHJvdG9jb2wgbmFtZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxuICogQHJldHVybiB7U2V0fSBUaGUgc3VicHJvdG9jb2wgbmFtZXNcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcGFyc2UoaGVhZGVyKSB7XG4gIGNvbnN0IHByb3RvY29scyA9IG5ldyBTZXQoKTtcbiAgbGV0IHN0YXJ0ID0gLTE7XG4gIGxldCBlbmQgPSAtMTtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAoaTsgaSA8IGhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBoZWFkZXIuY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgaSAhPT0gMCAmJlxuICAgICAgKGNvZGUgPT09IDB4MjAgLyogJyAnICovIHx8IGNvZGUgPT09IDB4MDkpIC8qICdcXHQnICovXG4gICAgKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiBzdGFydCAhPT0gLTEpIGVuZCA9IGk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDJjIC8qICcsJyAqLykge1xuICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG5cbiAgICAgIGNvbnN0IHByb3RvY29sID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgICBpZiAocHJvdG9jb2xzLmhhcyhwcm90b2NvbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBUaGUgXCIke3Byb3RvY29sfVwiIHN1YnByb3RvY29sIGlzIGR1cGxpY2F0ZWRgKTtcbiAgICAgIH1cblxuICAgICAgcHJvdG9jb2xzLmFkZChwcm90b2NvbCk7XG4gICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCAhPT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gIH1cblxuICBjb25zdCBwcm90b2NvbCA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XG5cbiAgaWYgKHByb3RvY29scy5oYXMocHJvdG9jb2wpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBUaGUgXCIke3Byb3RvY29sfVwiIHN1YnByb3RvY29sIGlzIGR1cGxpY2F0ZWRgKTtcbiAgfVxuXG4gIHByb3RvY29scy5hZGQocHJvdG9jb2wpO1xuICByZXR1cm4gcHJvdG9jb2xzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgcGFyc2UgfTtcbiIsICIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5EdXBsZXgkXCIsIFwiY2F1Z2h0RXJyb3JzXCI6IFwibm9uZVwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBjcmVhdGVIYXNoIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgZXh0ZW5zaW9uID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHN1YnByb3RvY29sID0gcmVxdWlyZSgnLi9zdWJwcm90b2NvbCcpO1xuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcbmNvbnN0IHsgR1VJRCwga1dlYlNvY2tldCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3Qga2V5UmVnZXggPSAvXlsrLzAtOUEtWmEtel17MjJ9PT0kLztcblxuY29uc3QgUlVOTklORyA9IDA7XG5jb25zdCBDTE9TSU5HID0gMTtcbmNvbnN0IENMT1NFRCA9IDI7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViU29ja2V0IHNlcnZlci5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuY2xhc3MgV2ViU29ja2V0U2VydmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGBXZWJTb2NrZXRTZXJ2ZXJgIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyXG4gICAqICAgICBhbnkgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZFxuICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9Qb25nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgYXV0b21hdGljYWxseSBzZW5kIGEgcG9uZyBpbiByZXNwb25zZSB0byBhIHBpbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJhY2tsb2c9NTExXSBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIHF1ZXVlIG9mXG4gICAqICAgICBwZW5kaW5nIGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xpZW50VHJhY2tpbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gICAqICAgICB0cmFjayBjbGllbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmhhbmRsZVByb3RvY29sc10gQSBob29rIHRvIGhhbmRsZSBwcm90b2NvbHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhvc3RdIFRoZSBob3N0bmFtZSB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2VcbiAgICogICAgIHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub1NlcnZlcj1mYWxzZV0gRW5hYmxlIG5vIHNlcnZlciBtb2RlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXRoXSBBY2NlcHQgb25seSBjb25uZWN0aW9ucyBtYXRjaGluZyB0aGlzIHBhdGhcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBbb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZT1mYWxzZV0gRW5hYmxlL2Rpc2FibGVcbiAgICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9ydF0gVGhlIHBvcnQgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7KGh0dHAuU2VydmVyfGh0dHBzLlNlcnZlcil9IFtvcHRpb25zLnNlcnZlcl0gQSBwcmUtY3JlYXRlZCBIVFRQL1NcbiAgICogICAgIHNlcnZlciB0byB1c2VcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy52ZXJpZnlDbGllbnRdIEEgaG9vayB0byByZWplY3QgY29ubmVjdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuV2ViU29ja2V0PVdlYlNvY2tldF0gU3BlY2lmaWVzIHRoZSBgV2ViU29ja2V0YFxuICAgKiAgICAgY2xhc3MgdG8gdXNlLiBJdCBtdXN0IGJlIHRoZSBgV2ViU29ja2V0YCBjbGFzcyBvciBjbGFzcyB0aGF0IGV4dGVuZHMgaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBBIGxpc3RlbmVyIGZvciB0aGUgYGxpc3RlbmluZ2AgZXZlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIG9wdGlvbnMgPSB7XG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0cnVlLFxuICAgICAgYXV0b1Bvbmc6IHRydWUsXG4gICAgICBtYXhQYXlsb2FkOiAxMDAgKiAxMDI0ICogMTAyNCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogZmFsc2UsXG4gICAgICBwZXJNZXNzYWdlRGVmbGF0ZTogZmFsc2UsXG4gICAgICBoYW5kbGVQcm90b2NvbHM6IG51bGwsXG4gICAgICBjbGllbnRUcmFja2luZzogdHJ1ZSxcbiAgICAgIHZlcmlmeUNsaWVudDogbnVsbCxcbiAgICAgIG5vU2VydmVyOiBmYWxzZSxcbiAgICAgIGJhY2tsb2c6IG51bGwsIC8vIHVzZSBkZWZhdWx0ICg1MTEgYXMgaW1wbGVtZW50ZWQgaW4gbmV0LmpzKVxuICAgICAgc2VydmVyOiBudWxsLFxuICAgICAgaG9zdDogbnVsbCxcbiAgICAgIHBhdGg6IG51bGwsXG4gICAgICBwb3J0OiBudWxsLFxuICAgICAgV2ViU29ja2V0LFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAoXG4gICAgICAob3B0aW9ucy5wb3J0ID09IG51bGwgJiYgIW9wdGlvbnMuc2VydmVyICYmICFvcHRpb25zLm5vU2VydmVyKSB8fFxuICAgICAgKG9wdGlvbnMucG9ydCAhPSBudWxsICYmIChvcHRpb25zLnNlcnZlciB8fCBvcHRpb25zLm5vU2VydmVyKSkgfHxcbiAgICAgIChvcHRpb25zLnNlcnZlciAmJiBvcHRpb25zLm5vU2VydmVyKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ09uZSBhbmQgb25seSBvbmUgb2YgdGhlIFwicG9ydFwiLCBcInNlcnZlclwiLCBvciBcIm5vU2VydmVyXCIgb3B0aW9ucyAnICtcbiAgICAgICAgICAnbXVzdCBiZSBzcGVjaWZpZWQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBvcnQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fc2VydmVyID0gaHR0cC5jcmVhdGVTZXJ2ZXIoKHJlcSwgcmVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBodHRwLlNUQVRVU19DT0RFU1s0MjZdO1xuXG4gICAgICAgIHJlcy53cml0ZUhlYWQoNDI2LCB7XG4gICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogYm9keS5sZW5ndGgsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3BsYWluJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzLmVuZChib2R5KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2VydmVyLmxpc3RlbihcbiAgICAgICAgb3B0aW9ucy5wb3J0LFxuICAgICAgICBvcHRpb25zLmhvc3QsXG4gICAgICAgIG9wdGlvbnMuYmFja2xvZyxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNlcnZlcikge1xuICAgICAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgY29uc3QgZW1pdENvbm5lY3Rpb24gPSB0aGlzLmVtaXQuYmluZCh0aGlzLCAnY29ubmVjdGlvbicpO1xuXG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSBhZGRMaXN0ZW5lcnModGhpcy5fc2VydmVyLCB7XG4gICAgICAgIGxpc3RlbmluZzogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2xpc3RlbmluZycpLFxuICAgICAgICBlcnJvcjogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Vycm9yJyksXG4gICAgICAgIHVwZ3JhZGU6IChyZXEsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgZW1pdENvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9PT0gdHJ1ZSkgb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNsaWVudFRyYWNraW5nKSB7XG4gICAgICB0aGlzLmNsaWVudHMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLl9zaG91bGRFbWl0Q2xvc2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX3N0YXRlID0gUlVOTklORztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBib3VuZCBhZGRyZXNzLCB0aGUgYWRkcmVzcyBmYW1pbHkgbmFtZSwgYW5kIHBvcnQgb2YgdGhlIHNlcnZlclxuICAgKiBhcyByZXBvcnRlZCBieSB0aGUgb3BlcmF0aW5nIHN5c3RlbSBpZiBsaXN0ZW5pbmcgb24gYW4gSVAgc29ja2V0LlxuICAgKiBJZiB0aGUgc2VydmVyIGlzIGxpc3RlbmluZyBvbiBhIHBpcGUgb3IgVU5JWCBkb21haW4gc29ja2V0LCB0aGUgbmFtZSBpc1xuICAgKiByZXR1cm5lZCBhcyBhIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7KE9iamVjdHxTdHJpbmd8bnVsbCl9IFRoZSBhZGRyZXNzIG9mIHRoZSBzZXJ2ZXJcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkcmVzcygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgaXMgb3BlcmF0aW5nIGluIFwibm9TZXJ2ZXJcIiBtb2RlJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9zZXJ2ZXIpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLl9zZXJ2ZXIuYWRkcmVzcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIHNlcnZlciBmcm9tIGFjY2VwdGluZyBuZXcgY29ubmVjdGlvbnMgYW5kIGVtaXQgdGhlIGAnY2xvc2UnYCBldmVudFxuICAgKiB3aGVuIGFsbCBleGlzdGluZyBjb25uZWN0aW9ucyBhcmUgY2xvc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIEEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY2IpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NFRCkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgY2IobmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG5vdCBydW5uaW5nJykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjYikgdGhpcy5vbmNlKCdjbG9zZScsIGNiKTtcblxuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQ0xPU0lORykgcmV0dXJuO1xuICAgIHRoaXMuX3N0YXRlID0gQ0xPU0lORztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMubm9TZXJ2ZXIgfHwgdGhpcy5vcHRpb25zLnNlcnZlcikge1xuICAgICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gdGhpcy5fc2VydmVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgICBpZiAoIXRoaXMuY2xpZW50cy5zaXplKSB7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3Nob3VsZEVtaXRDbG9zZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2VydmVyID0gdGhpcy5fc2VydmVyO1xuXG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgSFRUUC9TIHNlcnZlciB3YXMgY3JlYXRlZCBpbnRlcm5hbGx5LiBDbG9zZSBpdCwgYW5kIHJlbHkgb24gaXRzXG4gICAgICAvLyBgJ2Nsb3NlJ2AgZXZlbnQuXG4gICAgICAvL1xuICAgICAgc2VydmVyLmNsb3NlKCgpID0+IHtcbiAgICAgICAgZW1pdENsb3NlKHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlZSBpZiBhIGdpdmVuIHJlcXVlc3Qgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhpcyBzZXJ2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBSZXF1ZXN0IG9iamVjdCB0byBpbnNwZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcmVxdWVzdCBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNob3VsZEhhbmRsZShyZXEpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnBhdGgpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcmVxLnVybC5pbmRleE9mKCc/Jyk7XG4gICAgICBjb25zdCBwYXRobmFtZSA9IGluZGV4ICE9PSAtMSA/IHJlcS51cmwuc2xpY2UoMCwgaW5kZXgpIDogcmVxLnVybDtcblxuICAgICAgaWYgKHBhdGhuYW1lICE9PSB0aGlzLm9wdGlvbnMucGF0aCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIEhUVFAgVXBncmFkZSByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBoYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIGNvbnN0IGtleSA9IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleSddO1xuICAgIGNvbnN0IHVwZ3JhZGUgPSByZXEuaGVhZGVycy51cGdyYWRlO1xuICAgIGNvbnN0IHZlcnNpb24gPSArcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtdmVyc2lvbiddO1xuXG4gICAgaWYgKHJlcS5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgSFRUUCBtZXRob2QnO1xuICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDUsIG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh1cGdyYWRlID09PSB1bmRlZmluZWQgfHwgdXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0Jykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFVwZ3JhZGUgaGVhZGVyJztcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwgIWtleVJlZ2V4LnRlc3Qoa2V5KSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdNaXNzaW5nIG9yIGludmFsaWQgU2VjLVdlYlNvY2tldC1LZXkgaGVhZGVyJztcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiAhPT0gOCAmJiB2ZXJzaW9uICE9PSAxMykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdNaXNzaW5nIG9yIGludmFsaWQgU2VjLVdlYlNvY2tldC1WZXJzaW9uIGhlYWRlcic7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNob3VsZEhhbmRsZShyZXEpKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VjV2ViU29ja2V0UHJvdG9jb2wgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIGxldCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAoc2VjV2ViU29ja2V0UHJvdG9jb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvdG9jb2xzID0gc3VicHJvdG9jb2wucGFyc2Uoc2VjV2ViU29ja2V0UHJvdG9jb2wpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LVByb3RvY29sIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlICYmXG4gICAgICBzZWNXZWJTb2NrZXRFeHRlbnNpb25zICE9PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gbmV3IFBlck1lc3NhZ2VEZWZsYXRlKFxuICAgICAgICB0aGlzLm9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgICAgIHRydWUsXG4gICAgICAgIHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkXG4gICAgICApO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvZmZlcnMgPSBleHRlbnNpb24ucGFyc2Uoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyk7XG5cbiAgICAgICAgaWYgKG9mZmVyc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgICAgIGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPSBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgICdJbnZhbGlkIG9yIHVuYWNjZXB0YWJsZSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgY2xpZW50IHZlcmlmaWNhdGlvbiBoYW5kbGVyLlxuICAgIC8vXG4gICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQpIHtcbiAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgIG9yaWdpbjpcbiAgICAgICAgICByZXEuaGVhZGVyc1tgJHt2ZXJzaW9uID09PSA4ID8gJ3NlYy13ZWJzb2NrZXQtb3JpZ2luJyA6ICdvcmlnaW4nfWBdLFxuICAgICAgICBzZWN1cmU6ICEhKHJlcS5zb2NrZXQuYXV0aG9yaXplZCB8fCByZXEuc29ja2V0LmVuY3J5cHRlZCksXG4gICAgICAgIHJlcVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbywgKHZlcmlmaWVkLCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSA9PiB7XG4gICAgICAgICAgaWYgKCF2ZXJpZmllZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSB8fCA0MDEsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY29tcGxldGVVcGdyYWRlKFxuICAgICAgICAgICAgZXh0ZW5zaW9ucyxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHByb3RvY29scyxcbiAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgICBjYlxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudChpbmZvKSkgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAxKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShleHRlbnNpb25zLCBrZXksIHByb3RvY29scywgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGdyYWRlIHRoZSBjb25uZWN0aW9uIHRvIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgVGhlIGFjY2VwdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgdmFsdWUgb2YgdGhlIGBTZWMtV2ViU29ja2V0LUtleWAgaGVhZGVyXG4gICAqIEBwYXJhbSB7U2V0fSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHdpdGggdGhlIHNhbWUgc29ja2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIC8vXG4gICAgLy8gRGVzdHJveSB0aGUgc29ja2V0IGlmIHRoZSBjbGllbnQgaGFzIGFscmVhZHkgc2VudCBhIEZJTiBwYWNrZXQuXG4gICAgLy9cbiAgICBpZiAoIXNvY2tldC5yZWFkYWJsZSB8fCAhc29ja2V0LndyaXRhYmxlKSByZXR1cm4gc29ja2V0LmRlc3Ryb3koKTtcblxuICAgIGlmIChzb2NrZXRba1dlYlNvY2tldF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3NlcnZlci5oYW5kbGVVcGdyYWRlKCkgd2FzIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lICcgK1xuICAgICAgICAgICdzb2NrZXQsIHBvc3NpYmx5IGR1ZSB0byBhIG1pc2NvbmZpZ3VyYXRpb24nXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGF0ZSA+IFJVTk5JTkcpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDUwMyk7XG5cbiAgICBjb25zdCBkaWdlc3QgPSBjcmVhdGVIYXNoKCdzaGExJylcbiAgICAgIC51cGRhdGUoa2V5ICsgR1VJRClcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgY29uc3QgaGVhZGVycyA9IFtcbiAgICAgICdIVFRQLzEuMSAxMDEgU3dpdGNoaW5nIFByb3RvY29scycsXG4gICAgICAnVXBncmFkZTogd2Vic29ja2V0JyxcbiAgICAgICdDb25uZWN0aW9uOiBVcGdyYWRlJyxcbiAgICAgIGBTZWMtV2ViU29ja2V0LUFjY2VwdDogJHtkaWdlc3R9YFxuICAgIF07XG5cbiAgICBjb25zdCB3cyA9IG5ldyB0aGlzLm9wdGlvbnMuV2ViU29ja2V0KG51bGwsIHVuZGVmaW5lZCwgdGhpcy5vcHRpb25zKTtcblxuICAgIGlmIChwcm90b2NvbHMuc2l6ZSkge1xuICAgICAgLy9cbiAgICAgIC8vIE9wdGlvbmFsbHkgY2FsbCBleHRlcm5hbCBwcm90b2NvbCBzZWxlY3Rpb24gaGFuZGxlci5cbiAgICAgIC8vXG4gICAgICBjb25zdCBwcm90b2NvbCA9IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHNcbiAgICAgICAgPyB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzKHByb3RvY29scywgcmVxKVxuICAgICAgICA6IHByb3RvY29scy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG5cbiAgICAgIGlmIChwcm90b2NvbCkge1xuICAgICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2w6ICR7cHJvdG9jb2x9YCk7XG4gICAgICAgIHdzLl9wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLnBhcmFtcztcbiAgICAgIGNvbnN0IHZhbHVlID0gZXh0ZW5zaW9uLmZvcm1hdCh7XG4gICAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogW3BhcmFtc11cbiAgICAgIH0pO1xuICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnM6ICR7dmFsdWV9YCk7XG4gICAgICB3cy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBBbGxvdyBleHRlcm5hbCBtb2RpZmljYXRpb24vaW5zcGVjdGlvbiBvZiBoYW5kc2hha2UgaGVhZGVycy5cbiAgICAvL1xuICAgIHRoaXMuZW1pdCgnaGVhZGVycycsIGhlYWRlcnMsIHJlcSk7XG5cbiAgICBzb2NrZXQud3JpdGUoaGVhZGVycy5jb25jYXQoJ1xcclxcbicpLmpvaW4oJ1xcclxcbicpKTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICB3cy5zZXRTb2NrZXQoc29ja2V0LCBoZWFkLCB7XG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0aGlzLm9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyxcbiAgICAgIG1heFBheWxvYWQ6IHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiB0aGlzLm9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5jbGllbnRzKSB7XG4gICAgICB0aGlzLmNsaWVudHMuYWRkKHdzKTtcbiAgICAgIHdzLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnRzLmRlbGV0ZSh3cyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZEVtaXRDbG9zZSAmJiAhdGhpcy5jbGllbnRzLnNpemUpIHtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNiKHdzLCByZXEpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0U2VydmVyO1xuXG4vKipcbiAqIEFkZCBldmVudCBsaXN0ZW5lcnMgb24gYW4gYEV2ZW50RW1pdHRlcmAgdXNpbmcgYSBtYXAgb2YgPGV2ZW50LCBsaXN0ZW5lcj5cbiAqIHBhaXJzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBzZXJ2ZXIgVGhlIGV2ZW50IGVtaXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIEZ1bmN0aW9uPn0gbWFwIFRoZSBsaXN0ZW5lcnMgdG8gYWRkXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBhZGRlZCBsaXN0ZW5lcnMgd2hlblxuICogICAgIGNhbGxlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXJzKHNlcnZlciwgbWFwKSB7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkgc2VydmVyLm9uKGV2ZW50LCBtYXBbZXZlbnRdKTtcblxuICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkge1xuICAgICAgc2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBtYXBbZXZlbnRdKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRW1pdCBhIGAnY2xvc2UnYCBldmVudCBvbiBhbiBgRXZlbnRFbWl0dGVyYC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc2VydmVyKSB7XG4gIHNlcnZlci5fc3RhdGUgPSBDTE9TRUQ7XG4gIHNlcnZlci5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIEhhbmRsZSBzb2NrZXQgZXJyb3JzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIHRoaXMuZGVzdHJveSgpO1xufVxuXG4vKipcbiAqIENsb3NlIHRoZSBjb25uZWN0aW9uIHdoZW4gcHJlY29uZGl0aW9ucyBhcmUgbm90IGZ1bGZpbGxlZC5cbiAqXG4gKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBzb2NrZXQgb2YgdGhlIHVwZ3JhZGUgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtoZWFkZXJzXSBBZGRpdGlvbmFsIEhUVFAgcmVzcG9uc2UgaGVhZGVyc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSB7XG4gIC8vXG4gIC8vIFRoZSBzb2NrZXQgaXMgd3JpdGFibGUgdW5sZXNzIHRoZSB1c2VyIGRlc3Ryb3llZCBvciBlbmRlZCBpdCBiZWZvcmUgY2FsbGluZ1xuICAvLyBgc2VydmVyLmhhbmRsZVVwZ3JhZGUoKWAgb3IgaW4gdGhlIGB2ZXJpZnlDbGllbnRgIGZ1bmN0aW9uLCB3aGljaCBpcyBhIHVzZXJcbiAgLy8gZXJyb3IuIEhhbmRsaW5nIHRoaXMgZG9lcyBub3QgbWFrZSBtdWNoIHNlbnNlIGFzIHRoZSB3b3JzdCB0aGF0IGNhbiBoYXBwZW5cbiAgLy8gaXMgdGhhdCBzb21lIG9mIHRoZSBkYXRhIHdyaXR0ZW4gYnkgdGhlIHVzZXIgbWlnaHQgYmUgZGlzY2FyZGVkIGR1ZSB0byB0aGVcbiAgLy8gY2FsbCB0byBgc29ja2V0LmVuZCgpYCBiZWxvdywgd2hpY2ggdHJpZ2dlcnMgYW4gYCdlcnJvcidgIGV2ZW50IHRoYXQgaW5cbiAgLy8gdHVybiBjYXVzZXMgdGhlIHNvY2tldCB0byBiZSBkZXN0cm95ZWQuXG4gIC8vXG4gIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IGh0dHAuU1RBVFVTX0NPREVTW2NvZGVdO1xuICBoZWFkZXJzID0ge1xuICAgIENvbm5lY3Rpb246ICdjbG9zZScsXG4gICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L2h0bWwnLFxuICAgICdDb250ZW50LUxlbmd0aCc6IEJ1ZmZlci5ieXRlTGVuZ3RoKG1lc3NhZ2UpLFxuICAgIC4uLmhlYWRlcnNcbiAgfTtcblxuICBzb2NrZXQub25jZSgnZmluaXNoJywgc29ja2V0LmRlc3Ryb3kpO1xuXG4gIHNvY2tldC5lbmQoXG4gICAgYEhUVFAvMS4xICR7Y29kZX0gJHtodHRwLlNUQVRVU19DT0RFU1tjb2RlXX1cXHJcXG5gICtcbiAgICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgICAgIC5tYXAoKGgpID0+IGAke2h9OiAke2hlYWRlcnNbaF19YClcbiAgICAgICAgLmpvaW4oJ1xcclxcbicpICtcbiAgICAgICdcXHJcXG5cXHJcXG4nICtcbiAgICAgIG1lc3NhZ2VcbiAgKTtcbn1cblxuLyoqXG4gKiBFbWl0IGEgYCd3c0NsaWVudEVycm9yJ2AgZXZlbnQgb24gYSBgV2ViU29ja2V0U2VydmVyYCBpZiB0aGVyZSBpcyBhdCBsZWFzdFxuICogb25lIGxpc3RlbmVyIGZvciBpdCwgb3RoZXJ3aXNlIGNhbGwgYGFib3J0SGFuZHNoYWtlKClgLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0U2VydmVyfSBzZXJ2ZXIgVGhlIFdlYlNvY2tldCBzZXJ2ZXJcbiAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcbiAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIHNvY2tldCBvZiB0aGUgdXBncmFkZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHNlcnZlciwgcmVxLCBzb2NrZXQsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgaWYgKHNlcnZlci5saXN0ZW5lckNvdW50KCd3c0NsaWVudEVycm9yJykpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IpO1xuXG4gICAgc2VydmVyLmVtaXQoJ3dzQ2xpZW50RXJyb3InLCBlcnIsIHNvY2tldCwgcmVxKTtcbiAgfSBlbHNlIHtcbiAgICBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUsIG1lc3NhZ2UpO1xuICB9XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL2xpYi93ZWJzb2NrZXQnKTtcblxuV2ViU29ja2V0LmNyZWF0ZVdlYlNvY2tldFN0cmVhbSA9IHJlcXVpcmUoJy4vbGliL3N0cmVhbScpO1xuV2ViU29ja2V0LlNlcnZlciA9IHJlcXVpcmUoJy4vbGliL3dlYnNvY2tldC1zZXJ2ZXInKTtcbldlYlNvY2tldC5SZWNlaXZlciA9IHJlcXVpcmUoJy4vbGliL3JlY2VpdmVyJyk7XG5XZWJTb2NrZXQuU2VuZGVyID0gcmVxdWlyZSgnLi9saWIvc2VuZGVyJyk7XG5cbldlYlNvY2tldC5XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG5XZWJTb2NrZXQuV2ViU29ja2V0U2VydmVyID0gV2ViU29ja2V0LlNlcnZlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnd3MnKTsiLCAiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdHJvb3QuQ3J5cHRvSlMgPSBmYWN0b3J5KCk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG5cdC8qZ2xvYmFscyB3aW5kb3csIGdsb2JhbCwgcmVxdWlyZSovXG5cblx0LyoqXG5cdCAqIENyeXB0b0pTIGNvcmUgY29tcG9uZW50cy5cblx0ICovXG5cdHZhciBDcnlwdG9KUyA9IENyeXB0b0pTIHx8IChmdW5jdGlvbiAoTWF0aCwgdW5kZWZpbmVkKSB7XG5cblx0ICAgIHZhciBjcnlwdG87XG5cblx0ICAgIC8vIE5hdGl2ZSBjcnlwdG8gZnJvbSB3aW5kb3cgKEJyb3dzZXIpXG5cdCAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNyeXB0bykge1xuXHQgICAgICAgIGNyeXB0byA9IHdpbmRvdy5jcnlwdG87XG5cdCAgICB9XG5cblx0ICAgIC8vIE5hdGl2ZSBjcnlwdG8gaW4gd2ViIHdvcmtlciAoQnJvd3Nlcilcblx0ICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5jcnlwdG8pIHtcblx0ICAgICAgICBjcnlwdG8gPSBzZWxmLmNyeXB0bztcblx0ICAgIH1cblxuXHQgICAgLy8gTmF0aXZlIGNyeXB0byBmcm9tIHdvcmtlclxuXHQgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzLmNyeXB0bykge1xuXHQgICAgICAgIGNyeXB0byA9IGdsb2JhbFRoaXMuY3J5cHRvO1xuXHQgICAgfVxuXG5cdCAgICAvLyBOYXRpdmUgKGV4cGVyaW1lbnRhbCBJRSAxMSkgY3J5cHRvIGZyb20gd2luZG93IChCcm93c2VyKVxuXHQgICAgaWYgKCFjcnlwdG8gJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm1zQ3J5cHRvKSB7XG5cdCAgICAgICAgY3J5cHRvID0gd2luZG93Lm1zQ3J5cHRvO1xuXHQgICAgfVxuXG5cdCAgICAvLyBOYXRpdmUgY3J5cHRvIGZyb20gZ2xvYmFsIChOb2RlSlMpXG5cdCAgICBpZiAoIWNyeXB0byAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuY3J5cHRvKSB7XG5cdCAgICAgICAgY3J5cHRvID0gZ2xvYmFsLmNyeXB0bztcblx0ICAgIH1cblxuXHQgICAgLy8gTmF0aXZlIGNyeXB0byBpbXBvcnQgdmlhIHJlcXVpcmUgKE5vZGVKUylcblx0ICAgIGlmICghY3J5cHRvICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cdCAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgfVxuXG5cdCAgICAvKlxuXHQgICAgICogQ3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHBzZXVkb3JhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG5cdCAgICAgKlxuXHQgICAgICogQXMgTWF0aC5yYW5kb20oKSBpcyBjcnlwdG9ncmFwaGljYWxseSBub3Qgc2FmZSB0byB1c2Vcblx0ICAgICAqL1xuXHQgICAgdmFyIGNyeXB0b1NlY3VyZVJhbmRvbUludCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoY3J5cHRvKSB7XG5cdCAgICAgICAgICAgIC8vIFVzZSBnZXRSYW5kb21WYWx1ZXMgbWV0aG9kIChCcm93c2VyKVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDEpKVswXTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFVzZSByYW5kb21CeXRlcyBtZXRob2QgKE5vZGVKUylcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8ucmFuZG9tQnl0ZXMgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcyg0KS5yZWFkSW50MzJMRSgpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYXRpdmUgY3J5cHRvIG1vZHVsZSBjb3VsZCBub3QgYmUgdXNlZCB0byBnZXQgc2VjdXJlIHJhbmRvbSBudW1iZXIuJyk7XG5cdCAgICB9O1xuXG5cdCAgICAvKlxuXHQgICAgICogTG9jYWwgcG9seWZpbGwgb2YgT2JqZWN0LmNyZWF0ZVxuXG5cdCAgICAgKi9cblx0ICAgIHZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gRigpIHt9XG5cblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgICB2YXIgc3VidHlwZTtcblxuXHQgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG9iajtcblxuXHQgICAgICAgICAgICBzdWJ0eXBlID0gbmV3IEYoKTtcblxuXHQgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG51bGw7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG5cdCAgICAgICAgfTtcblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQ3J5cHRvSlMgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQyA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIExpYnJhcnkgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYiA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEJhc2Ugb2JqZWN0IGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2UgPSAoZnVuY3Rpb24gKCkge1xuXG5cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3ZlcnJpZGVzIFByb3BlcnRpZXMgdG8gY29weSBpbnRvIHRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJyxcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICogICAgICAgICB9XG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGV4dGVuZDogZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuXHQgICAgICAgICAgICAgICAgLy8gU3Bhd25cblx0ICAgICAgICAgICAgICAgIHZhciBzdWJ0eXBlID0gY3JlYXRlKHRoaXMpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBBdWdtZW50XG5cdCAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5taXhJbihvdmVycmlkZXMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZGVmYXVsdCBpbml0aWFsaXplclxuXHQgICAgICAgICAgICAgICAgaWYgKCFzdWJ0eXBlLmhhc093blByb3BlcnR5KCdpbml0JykgfHwgdGhpcy5pbml0ID09PSBzdWJ0eXBlLmluaXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplcidzIHByb3RvdHlwZSBpcyB0aGUgc3VidHlwZSBvYmplY3Rcblx0ICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdC5wcm90b3R5cGUgPSBzdWJ0eXBlO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2Ugc3VwZXJ0eXBlXG5cdCAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlciA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBFeHRlbmRzIHRoaXMgb2JqZWN0IGFuZCBydW5zIHRoZSBpbml0IG1ldGhvZC5cblx0ICAgICAgICAgICAgICogQXJndW1lbnRzIHRvIGNyZWF0ZSgpIHdpbGwgYmUgcGFzc2VkIHRvIGluaXQoKS5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIGluc3RhbmNlID0gTXlUeXBlLmNyZWF0ZSgpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmV4dGVuZCgpO1xuXHQgICAgICAgICAgICAgICAgaW5zdGFuY2UuaW5pdC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhZGQgc29tZSBsb2dpYyB3aGVuIHlvdXIgb2JqZWN0cyBhcmUgY3JlYXRlZC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBNeVR5cGUgPSBDcnlwdG9KUy5saWIuQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICogICAgICAgICAgICAgLy8gLi4uXG5cdCAgICAgICAgICAgICAqICAgICAgICAgfVxuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIGludG8gdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIFRoZSBwcm9wZXJ0aWVzIHRvIG1peCBpbi5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIE15VHlwZS5taXhJbih7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZSdcblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgbWl4SW46IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gcHJvcGVydGllcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWVdID0gcHJvcGVydGllc1twcm9wZXJ0eU5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gSUUgd29uJ3QgY29weSB0b1N0cmluZyB1c2luZyB0aGUgbG9vcCBhYm92ZVxuXHQgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoJ3RvU3RyaW5nJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvU3RyaW5nID0gcHJvcGVydGllcy50b1N0cmluZztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gaW5zdGFuY2UuY2xvbmUoKTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0LnByb3RvdHlwZS5leHRlbmQodGhpcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtBcnJheX0gd29yZHMgVGhlIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaWdCeXRlcyBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIChPcHRpb25hbCkgQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaWdCeXRlcyAoT3B0aW9uYWwpIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhlIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSk7XG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10sIDYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uICh3b3Jkcywgc2lnQnl0ZXMpIHtcblx0ICAgICAgICAgICAgd29yZHMgPSB0aGlzLndvcmRzID0gd29yZHMgfHwgW107XG5cblx0ICAgICAgICAgICAgaWYgKHNpZ0J5dGVzICE9IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHdvcmRzLmxlbmd0aCAqIDQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhpcyB3b3JkIGFycmF5IHRvIGEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyIChPcHRpb25hbCkgVGhlIGVuY29kaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogQ3J5cHRvSlMuZW5jLkhleFxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5naWZpZWQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheSArICcnO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKCk7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLlV0ZjgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoZW5jb2Rlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gKGVuY29kZXIgfHwgSGV4KS5zdHJpbmdpZnkodGhpcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmNhdGVuYXRlcyBhIHdvcmQgYXJyYXkgdG8gdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgd29yZEFycmF5MS5jb25jYXQod29yZEFycmF5Mik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY29uY2F0OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgdGhpc1dvcmRzID0gdGhpcy53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHRoYXRXb3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHRoaXNTaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciB0aGF0U2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblx0ICAgICAgICAgICAgdGhpcy5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbmNhdFxuXHQgICAgICAgICAgICBpZiAodGhpc1NpZ0J5dGVzICUgNCkge1xuXHQgICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgYnl0ZSBhdCBhIHRpbWVcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdEJ5dGUgPSAodGhhdFdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSB8PSB0aGF0Qnl0ZSA8PCAoMjQgLSAoKHRoaXNTaWdCeXRlcyArIGkpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIHdvcmQgYXQgYSB0aW1lXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoYXRTaWdCeXRlczsgaiArPSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBqKSA+Pj4gMl0gPSB0aGF0V29yZHNbaiA+Pj4gMl07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyArPSB0aGF0U2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZW1vdmVzIGluc2lnbmlmaWNhbnQgYml0cy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgd29yZEFycmF5LmNsYW1wKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xhbXA6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHRoaXMud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXBcblx0ICAgICAgICAgICAgd29yZHNbc2lnQnl0ZXMgPj4+IDJdICY9IDB4ZmZmZmZmZmYgPDwgKDMyIC0gKHNpZ0J5dGVzICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgd29yZHMubGVuZ3RoID0gTWF0aC5jZWlsKHNpZ0J5dGVzIC8gNCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGNsb25lLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSB3b3JkQXJyYXkuY2xvbmUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLndvcmRzID0gdGhpcy53b3Jkcy5zbGljZSgwKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSB3b3JkIGFycmF5IGZpbGxlZCB3aXRoIHJhbmRvbSBieXRlcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuQnl0ZXMgVGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2VuZXJhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSByYW5kb20gd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKDE2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByYW5kb206IGZ1bmN0aW9uIChuQnl0ZXMpIHtcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgd29yZHMucHVzaChjcnlwdG9TZWN1cmVSYW5kb21JbnQoKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBuQnl0ZXMpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEVuY29kZXIgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYyA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEhleCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEhleCA9IENfZW5jLkhleCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuSGV4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgaGV4Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICBoZXhDaGFycy5wdXNoKChiaXRlID4+PiA0KS50b1N0cmluZygxNikpO1xuXHQgICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSAmIDB4MGYpLnRvU3RyaW5nKDE2KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gaGV4Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4U3RyIFRoZSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoaGV4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGhleFN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaGV4U3RyTGVuZ3RoID0gaGV4U3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhleFN0ckxlbmd0aDsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAzXSB8PSBwYXJzZUludChoZXhTdHIuc3Vic3RyKGksIDIpLCAxNikgPDwgKDI0IC0gKGkgJSA4KSAqIDQpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgaGV4U3RyTGVuZ3RoIC8gMik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBMYXRpbjEgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBMYXRpbjEgPSBDX2VuYy5MYXRpbjEgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbGF0aW4xU3RyaW5nID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGxhdGluMUNoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgbGF0aW4xQ2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJpdGUpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBsYXRpbjFDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBMYXRpbjEgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXRpbjFTdHIgVGhlIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5wYXJzZShsYXRpbjFTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAobGF0aW4xU3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBsYXRpbjFTdHJMZW5ndGggPSBsYXRpbjFTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0aW4xU3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDJdIHw9IChsYXRpbjFTdHIuY2hhckNvZGVBdChpKSAmIDB4ZmYpIDw8ICgyNCAtIChpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGxhdGluMVN0ckxlbmd0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVVEYtOCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB1dGY4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLlV0Zjguc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShMYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSkpKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgVVRGLTggZGF0YScpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgVVRGLTggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1dGY4U3RyIFRoZSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UodXRmOFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1dGY4U3RyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBMYXRpbjEucGFyc2UodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHV0ZjhTdHIpKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBidWZmZXJlZCBibG9jayBhbGdvcml0aG0gdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogVGhlIHByb3BlcnR5IGJsb2NrU2l6ZSBtdXN0IGJlIGltcGxlbWVudGVkIGluIGEgY29uY3JldGUgc3VidHlwZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX21pbkJ1ZmZlclNpemUgVGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBzaG91bGQgYmUga2VwdCB1bnByb2Nlc3NlZCBpbiB0aGUgYnVmZmVyLiBEZWZhdWx0OiAwXG5cdCAgICAgKi9cblx0ICAgIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBibG9jayBhbGdvcml0aG0ncyBkYXRhIGJ1ZmZlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgV29yZEFycmF5LmluaXQoKTtcblx0ICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyA9IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgbmV3IGRhdGEgdG8gdGhpcyBibG9jayBhbGdvcml0aG0ncyBidWZmZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYXBwZW5kLiBTdHJpbmdzIGFyZSBjb252ZXJ0ZWQgdG8gYSBXb3JkQXJyYXkgdXNpbmcgVVRGLTguXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCgnZGF0YScpO1xuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfYXBwZW5kOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBXb3JkQXJyYXksIGVsc2UgYXNzdW1lIFdvcmRBcnJheSBhbHJlYWR5XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgZGF0YSA9IFV0ZjgucGFyc2UoZGF0YSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fZGF0YS5jb25jYXQoZGF0YSk7XG5cdCAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgKz0gZGF0YS5zaWdCeXRlcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUHJvY2Vzc2VzIGF2YWlsYWJsZSBkYXRhIGJsb2Nrcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgX2RvUHJvY2Vzc0Jsb2NrKG9mZnNldCksIHdoaWNoIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgYSBjb25jcmV0ZSBzdWJ0eXBlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBkb0ZsdXNoIFdoZXRoZXIgYWxsIGJsb2NrcyBhbmQgcGFydGlhbCBibG9ja3Mgc2hvdWxkIGJlIHByb2Nlc3NlZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHByb2Nlc3NlZCBkYXRhLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX3Byb2Nlc3M6IGZ1bmN0aW9uIChkb0ZsdXNoKSB7XG5cdCAgICAgICAgICAgIHZhciBwcm9jZXNzZWRXb3JkcztcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGRhdGFTaWdCeXRlcyA9IGRhdGEuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSB0aGlzLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBibG9ja3MgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5CbG9ja3NSZWFkeSA9IGRhdGFTaWdCeXRlcyAvIGJsb2NrU2l6ZUJ5dGVzO1xuXHQgICAgICAgICAgICBpZiAoZG9GbHVzaCkge1xuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgdXAgdG8gaW5jbHVkZSBwYXJ0aWFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5jZWlsKG5CbG9ja3NSZWFkeSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBSb3VuZCBkb3duIHRvIGluY2x1ZGUgb25seSBmdWxsIGJsb2Nrcyxcblx0ICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBtdXN0IHJlbWFpbiBpbiB0aGUgYnVmZmVyXG5cdCAgICAgICAgICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLm1heCgobkJsb2Nrc1JlYWR5IHwgMCkgLSB0aGlzLl9taW5CdWZmZXJTaXplLCAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvdW50IHdvcmRzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuV29yZHNSZWFkeSA9IG5CbG9ja3NSZWFkeSAqIGJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBieXRlcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbkJ5dGVzUmVhZHkgPSBNYXRoLm1pbihuV29yZHNSZWFkeSAqIDQsIGRhdGFTaWdCeXRlcyk7XG5cblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBibG9ja3Ncblx0ICAgICAgICAgICAgaWYgKG5Xb3Jkc1JlYWR5KSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBuV29yZHNSZWFkeTsgb2Zmc2V0ICs9IGJsb2NrU2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtYWxnb3JpdGhtIGxvZ2ljXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9Qcm9jZXNzQmxvY2soZGF0YVdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgcHJvY2Vzc2VkIHdvcmRzXG5cdCAgICAgICAgICAgICAgICBwcm9jZXNzZWRXb3JkcyA9IGRhdGFXb3Jkcy5zcGxpY2UoMCwgbldvcmRzUmVhZHkpO1xuXHQgICAgICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuQnl0ZXNSZWFkeTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBwcm9jZXNzZWQgd29yZHNcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdChwcm9jZXNzZWRXb3JkcywgbkJ5dGVzUmVhZHkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLmNsb25lKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5fZGF0YSA9IHRoaXMuX2RhdGEuY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9taW5CdWZmZXJTaXplOiAwXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBoYXNoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGhhc2hlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMTYgKDUxMiBiaXRzKVxuXHQgICAgICovXG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyID0gQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKCksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgaGFzaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGhhc2ggY29tcHV0YXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoYXNoZXIgPSBDcnlwdG9KUy5hbGdvLlNIQTI1Ni5jcmVhdGUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGhhc2hlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSBidWZmZXJcblx0ICAgICAgICAgICAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHRoaXMuX2RvUmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVXBkYXRlcyB0aGlzIGhhc2hlciB3aXRoIGEgbWVzc2FnZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtIYXNoZXJ9IFRoaXMgaGFzaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBoYXNoXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgaGFzaCBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCk7XG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEZpbmFsIG1lc3NhZ2UgdXBkYXRlXG5cdCAgICAgICAgICAgIGlmIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2RvRmluYWxpemUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiA1MTIvMzIsXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gYSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGhhc2hlci5pbml0KGNmZykuZmluYWxpemUobWVzc2FnZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gdXNlIGluIHRoaXMgSE1BQyBoZWxwZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgSG1hY1NIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIbWFjSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwga2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENfYWxnby5ITUFDLmluaXQoaGFzaGVyLCBrZXkpLmZpbmFsaXplKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFsZ29yaXRobSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ28gPSB7fTtcblxuXHQgICAgcmV0dXJuIEM7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTO1xuXG59KSk7IiwgIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uIChNYXRoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gSW5pdGlhbGl6YXRpb24gYW5kIHJvdW5kIGNvbnN0YW50cyB0YWJsZXNcblx0ICAgIHZhciBIID0gW107XG5cdCAgICB2YXIgSyA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIGNvbnN0YW50c1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBpc1ByaW1lKG4pIHtcblx0ICAgICAgICAgICAgdmFyIHNxcnROID0gTWF0aC5zcXJ0KG4pO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBmYWN0b3IgPSAyOyBmYWN0b3IgPD0gc3FydE47IGZhY3RvcisrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIShuICUgZmFjdG9yKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEZyYWN0aW9uYWxCaXRzKG4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuICgobiAtIChuIHwgMCkpICogMHgxMDAwMDAwMDApIHwgMDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgbiA9IDI7XG5cdCAgICAgICAgdmFyIG5QcmltZSA9IDA7XG5cdCAgICAgICAgd2hpbGUgKG5QcmltZSA8IDY0KSB7XG5cdCAgICAgICAgICAgIGlmIChpc1ByaW1lKG4pKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoblByaW1lIDwgOCkge1xuXHQgICAgICAgICAgICAgICAgICAgIEhbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKE1hdGgucG93KG4sIDEgLyAyKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBLW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhNYXRoLnBvdyhuLCAxIC8gMykpO1xuXG5cdCAgICAgICAgICAgICAgICBuUHJpbWUrKztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIG4rKztcblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3Rcblx0ICAgIHZhciBXID0gW107XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTI1NiBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTI1NiA9IENfYWxnby5TSEEyNTYgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KEguc2xpY2UoMCkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblx0ICAgICAgICAgICAgdmFyIGUgPSBIWzRdO1xuXHQgICAgICAgICAgICB2YXIgZiA9IEhbNV07XG5cdCAgICAgICAgICAgIHZhciBnID0gSFs2XTtcblx0ICAgICAgICAgICAgdmFyIGggPSBIWzddO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBNW29mZnNldCArIGldIHwgMDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMHggPSBXW2kgLSAxNV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMCAgPSAoKGdhbW1hMHggPDwgMjUpIHwgKGdhbW1hMHggPj4+IDcpKSAgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChnYW1tYTB4IDw8IDE0KSB8IChnYW1tYTB4ID4+PiAxOCkpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZ2FtbWEweCA+Pj4gMyk7XG5cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExeCA9IFdbaSAtIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTEgID0gKChnYW1tYTF4IDw8IDE1KSB8IChnYW1tYTF4ID4+PiAxNykpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoZ2FtbWExeCA8PCAxMykgfCAoZ2FtbWExeCA+Pj4gMTkpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdhbW1hMXggPj4+IDEwKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdmFyIGNoICA9IChlICYgZikgXiAofmUgJiBnKTtcblx0ICAgICAgICAgICAgICAgIHZhciBtYWogPSAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG5cblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTAgPSAoKGEgPDwgMzApIHwgKGEgPj4+IDIpKSBeICgoYSA8PCAxOSkgfCAoYSA+Pj4gMTMpKSBeICgoYSA8PCAxMCkgfCAoYSA+Pj4gMjIpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTEgPSAoKGUgPDwgMjYpIHwgKGUgPj4+IDYpKSBeICgoZSA8PCAyMSkgfCAoZSA+Pj4gMTEpKSBeICgoZSA8PCA3KSAgfCAoZSA+Pj4gMjUpKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tpXSArIFdbaV07XG5cdCAgICAgICAgICAgICAgICB2YXIgdDIgPSBzaWdtYTAgKyBtYWo7XG5cblx0ICAgICAgICAgICAgICAgIGggPSBnO1xuXHQgICAgICAgICAgICAgICAgZyA9IGY7XG5cdCAgICAgICAgICAgICAgICBmID0gZTtcblx0ICAgICAgICAgICAgICAgIGUgPSAoZCArIHQxKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBkID0gYztcblx0ICAgICAgICAgICAgICAgIGMgPSBiO1xuXHQgICAgICAgICAgICAgICAgYiA9IGE7XG5cdCAgICAgICAgICAgICAgICBhID0gKHQxICsgdDIpIHwgMDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICAgICAgSFs0XSA9IChIWzRdICsgZSkgfCAwO1xuXHQgICAgICAgICAgICBIWzVdID0gKEhbNV0gKyBmKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNl0gPSAoSFs2XSArIGcpIHwgMDtcblx0ICAgICAgICAgICAgSFs3XSA9IChIWzddICsgaCkgfCAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTI1Nih3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTI1NiA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTI1Nik7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMjU2KG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTI1NiA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEEyNTYpO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEEyNTY7XG5cbn0pKTsiLCAiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQmFzZTY0IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgQmFzZTY0ID0gQ19lbmMuQmFzZTY0ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGJhc2U2NFN0cmluZyA9IENyeXB0b0pTLmVuYy5CYXNlNjQuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBiYXNlNjRDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMSA9ICh3b3Jkc1tpID4+PiAyXSAgICAgICA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAgICAgICAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTIgPSAod29yZHNbKGkgKyAxKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDEpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUzID0gKHdvcmRzWyhpICsgMikgPj4+IDJdID4+PiAoMjQgLSAoKGkgKyAyKSAlIDQpICogOCkpICYgMHhmZjtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHRyaXBsZXQgPSAoYnl0ZTEgPDwgMTYpIHwgKGJ5dGUyIDw8IDgpIHwgYnl0ZTM7XG5cblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyAoaiA8IDQpICYmIChpICsgaiAqIDAuNzUgPCBzaWdCeXRlcyk7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGJhc2U2NENoYXJzLnB1c2gobWFwLmNoYXJBdCgodHJpcGxldCA+Pj4gKDYgKiAoMyAtIGopKSkgJiAweDNmKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcblx0ICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoYmFzZTY0Q2hhcnMubGVuZ3RoICUgNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJhc2U2NENoYXJzLnB1c2gocGFkZGluZ0NoYXIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGJhc2U2NENoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIEJhc2U2NCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFN0ciBUaGUgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnBhcnNlKGJhc2U2NFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChiYXNlNjRTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBiYXNlNjRTdHJMZW5ndGggPSBiYXNlNjRTdHIubGVuZ3RoO1xuXHQgICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHQgICAgICAgICAgICB2YXIgcmV2ZXJzZU1hcCA9IHRoaXMuX3JldmVyc2VNYXA7XG5cblx0ICAgICAgICAgICAgaWYgKCFyZXZlcnNlTWFwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU1hcCA9IHRoaXMuX3JldmVyc2VNYXAgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hcC5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwW21hcC5jaGFyQ29kZUF0KGopXSA9IGo7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSWdub3JlIHBhZGRpbmdcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdDaGFyID0gbWFwLmNoYXJBdCg2NCk7XG5cdCAgICAgICAgICAgIGlmIChwYWRkaW5nQ2hhcikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdJbmRleCA9IGJhc2U2NFN0ci5pbmRleE9mKHBhZGRpbmdDaGFyKTtcblx0ICAgICAgICAgICAgICAgIGlmIChwYWRkaW5nSW5kZXggIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0U3RyTGVuZ3RoID0gcGFkZGluZ0luZGV4O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICByZXR1cm4gcGFyc2VMb29wKGJhc2U2NFN0ciwgYmFzZTY0U3RyTGVuZ3RoLCByZXZlcnNlTWFwKTtcblxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfbWFwOiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nXG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBwYXJzZUxvb3AoYmFzZTY0U3RyLCBiYXNlNjRTdHJMZW5ndGgsIHJldmVyc2VNYXApIHtcblx0ICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgIHZhciBuQnl0ZXMgPSAwO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2U2NFN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBpZiAoaSAlIDQpIHtcblx0ICAgICAgICAgICAgICB2YXIgYml0czEgPSByZXZlcnNlTWFwW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkgLSAxKV0gPDwgKChpICUgNCkgKiAyKTtcblx0ICAgICAgICAgICAgICB2YXIgYml0czIgPSByZXZlcnNlTWFwW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkpXSA+Pj4gKDYgLSAoaSAlIDQpICogMik7XG5cdCAgICAgICAgICAgICAgdmFyIGJpdHNDb21iaW5lZCA9IGJpdHMxIHwgYml0czI7XG5cdCAgICAgICAgICAgICAgd29yZHNbbkJ5dGVzID4+PiAyXSB8PSBiaXRzQ29tYmluZWQgPDwgKDI0IC0gKG5CeXRlcyAlIDQpICogOCk7XG5cdCAgICAgICAgICAgICAgbkJ5dGVzKys7XG5cdCAgICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIG5CeXRlcyk7XG5cdCAgICB9XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuZW5jLkJhc2U2NDtcblxufSkpOyIsIG51bGwsICIvLyBJbnRlZ2VyIFV0aWxpdHlcblxuZXhwb3J0IGNvbnN0IFVJTlQzMl9NQVggPSAweGZmZmZfZmZmZjtcblxuLy8gRGF0YVZpZXcgZXh0ZW5zaW9uIHRvIGhhbmRsZSBpbnQ2NCAvIHVpbnQ2NCxcbi8vIHdoZXJlIHRoZSBhY3R1YWwgcmFuZ2UgaXMgNTMtYml0cyBpbnRlZ2VyIChhLmsuYS4gc2FmZSBpbnRlZ2VyKVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0VWludDY0KHZpZXc6IERhdGFWaWV3LCBvZmZzZXQ6IG51bWJlciwgdmFsdWU6IG51bWJlcik6IHZvaWQge1xuICBjb25zdCBoaWdoID0gdmFsdWUgLyAweDFfMDAwMF8wMDAwO1xuICBjb25zdCBsb3cgPSB2YWx1ZTsgLy8gaGlnaCBiaXRzIGFyZSB0cnVuY2F0ZWQgYnkgRGF0YVZpZXdcbiAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCBoaWdoKTtcbiAgdmlldy5zZXRVaW50MzIob2Zmc2V0ICsgNCwgbG93KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEludDY0KHZpZXc6IERhdGFWaWV3LCBvZmZzZXQ6IG51bWJlciwgdmFsdWU6IG51bWJlcik6IHZvaWQge1xuICBjb25zdCBoaWdoID0gTWF0aC5mbG9vcih2YWx1ZSAvIDB4MV8wMDAwXzAwMDApO1xuICBjb25zdCBsb3cgPSB2YWx1ZTsgLy8gaGlnaCBiaXRzIGFyZSB0cnVuY2F0ZWQgYnkgRGF0YVZpZXdcbiAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCBoaWdoKTtcbiAgdmlldy5zZXRVaW50MzIob2Zmc2V0ICsgNCwgbG93KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEludDY0KHZpZXc6IERhdGFWaWV3LCBvZmZzZXQ6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IGhpZ2ggPSB2aWV3LmdldEludDMyKG9mZnNldCk7XG4gIGNvbnN0IGxvdyA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCArIDQpO1xuICByZXR1cm4gaGlnaCAqIDB4MV8wMDAwXzAwMDAgKyBsb3c7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVaW50NjQodmlldzogRGF0YVZpZXcsIG9mZnNldDogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgaGlnaCA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gIGNvbnN0IGxvdyA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCArIDQpO1xuICByZXR1cm4gaGlnaCAqIDB4MV8wMDAwXzAwMDAgKyBsb3c7XG59XG4iLCAiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiAqL1xuaW1wb3J0IHsgVUlOVDMyX01BWCB9IGZyb20gXCIuL2ludFwiO1xuXG5jb25zdCBURVhUX0VOQ09ESU5HX0FWQUlMQUJMRSA9XG4gICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBwcm9jZXNzPy5lbnY/LltcIlRFWFRfRU5DT0RJTkdcIl0gIT09IFwibmV2ZXJcIikgJiZcbiAgdHlwZW9mIFRleHRFbmNvZGVyICE9PSBcInVuZGVmaW5lZFwiICYmXG4gIHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gXCJ1bmRlZmluZWRcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhDb3VudChzdHI6IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG5cbiAgbGV0IGJ5dGVMZW5ndGggPSAwO1xuICBsZXQgcG9zID0gMDtcbiAgd2hpbGUgKHBvcyA8IHN0ckxlbmd0aCkge1xuICAgIGxldCB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcysrKTtcblxuICAgIGlmICgodmFsdWUgJiAweGZmZmZmZjgwKSA9PT0gMCkge1xuICAgICAgLy8gMS1ieXRlXG4gICAgICBieXRlTGVuZ3RoKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKCh2YWx1ZSAmIDB4ZmZmZmY4MDApID09PSAwKSB7XG4gICAgICAvLyAyLWJ5dGVzXG4gICAgICBieXRlTGVuZ3RoICs9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhhbmRsZSBzdXJyb2dhdGUgcGFpclxuICAgICAgaWYgKHZhbHVlID49IDB4ZDgwMCAmJiB2YWx1ZSA8PSAweGRiZmYpIHtcbiAgICAgICAgLy8gaGlnaCBzdXJyb2dhdGVcbiAgICAgICAgaWYgKHBvcyA8IHN0ckxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGV4dHJhID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICBpZiAoKGV4dHJhICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgICAgICArK3BvcztcbiAgICAgICAgICAgIHZhbHVlID0gKCh2YWx1ZSAmIDB4M2ZmKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNmZikgKyAweDEwMDAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKHZhbHVlICYgMHhmZmZmMDAwMCkgPT09IDApIHtcbiAgICAgICAgLy8gMy1ieXRlXG4gICAgICAgIGJ5dGVMZW5ndGggKz0gMztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDQtYnl0ZVxuICAgICAgICBieXRlTGVuZ3RoICs9IDQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlTGVuZ3RoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXRmOEVuY29kZUpzKHN0cjogc3RyaW5nLCBvdXRwdXQ6IFVpbnQ4QXJyYXksIG91dHB1dE9mZnNldDogbnVtYmVyKTogdm9pZCB7XG4gIGNvbnN0IHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gIGxldCBvZmZzZXQgPSBvdXRwdXRPZmZzZXQ7XG4gIGxldCBwb3MgPSAwO1xuICB3aGlsZSAocG9zIDwgc3RyTGVuZ3RoKSB7XG4gICAgbGV0IHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKyspO1xuXG4gICAgaWYgKCh2YWx1ZSAmIDB4ZmZmZmZmODApID09PSAwKSB7XG4gICAgICAvLyAxLWJ5dGVcbiAgICAgIG91dHB1dFtvZmZzZXQrK10gPSB2YWx1ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoKHZhbHVlICYgMHhmZmZmZjgwMCkgPT09IDApIHtcbiAgICAgIC8vIDItYnl0ZXNcbiAgICAgIG91dHB1dFtvZmZzZXQrK10gPSAoKHZhbHVlID4+IDYpICYgMHgxZikgfCAweGMwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYW5kbGUgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGlmICh2YWx1ZSA+PSAweGQ4MDAgJiYgdmFsdWUgPD0gMHhkYmZmKSB7XG4gICAgICAgIC8vIGhpZ2ggc3Vycm9nYXRlXG4gICAgICAgIGlmIChwb3MgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBleHRyYSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgaWYgKChleHRyYSAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICAgICAgKytwb3M7XG4gICAgICAgICAgICB2YWx1ZSA9ICgodmFsdWUgJiAweDNmZikgPDwgMTApICsgKGV4dHJhICYgMHgzZmYpICsgMHgxMDAwMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCh2YWx1ZSAmIDB4ZmZmZjAwMDApID09PSAwKSB7XG4gICAgICAgIC8vIDMtYnl0ZVxuICAgICAgICBvdXRwdXRbb2Zmc2V0KytdID0gKCh2YWx1ZSA+PiAxMikgJiAweDBmKSB8IDB4ZTA7XG4gICAgICAgIG91dHB1dFtvZmZzZXQrK10gPSAoKHZhbHVlID4+IDYpICYgMHgzZikgfCAweDgwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gNC1ieXRlXG4gICAgICAgIG91dHB1dFtvZmZzZXQrK10gPSAoKHZhbHVlID4+IDE4KSAmIDB4MDcpIHwgMHhmMDtcbiAgICAgICAgb3V0cHV0W29mZnNldCsrXSA9ICgodmFsdWUgPj4gMTIpICYgMHgzZikgfCAweDgwO1xuICAgICAgICBvdXRwdXRbb2Zmc2V0KytdID0gKCh2YWx1ZSA+PiA2KSAmIDB4M2YpIHwgMHg4MDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvdXRwdXRbb2Zmc2V0KytdID0gKHZhbHVlICYgMHgzZikgfCAweDgwO1xuICB9XG59XG5cbmNvbnN0IHNoYXJlZFRleHRFbmNvZGVyID0gVEVYVF9FTkNPRElOR19BVkFJTEFCTEUgPyBuZXcgVGV4dEVuY29kZXIoKSA6IHVuZGVmaW5lZDtcbmV4cG9ydCBjb25zdCBURVhUX0VOQ09ERVJfVEhSRVNIT0xEID0gIVRFWFRfRU5DT0RJTkdfQVZBSUxBQkxFXG4gID8gVUlOVDMyX01BWFxuICA6IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3M/LmVudj8uW1wiVEVYVF9FTkNPRElOR1wiXSAhPT0gXCJmb3JjZVwiXG4gID8gMjAwXG4gIDogMDtcblxuZnVuY3Rpb24gdXRmOEVuY29kZVRFZW5jb2RlKHN0cjogc3RyaW5nLCBvdXRwdXQ6IFVpbnQ4QXJyYXksIG91dHB1dE9mZnNldDogbnVtYmVyKTogdm9pZCB7XG4gIG91dHB1dC5zZXQoc2hhcmVkVGV4dEVuY29kZXIhLmVuY29kZShzdHIpLCBvdXRwdXRPZmZzZXQpO1xufVxuXG5mdW5jdGlvbiB1dGY4RW5jb2RlVEVlbmNvZGVJbnRvKHN0cjogc3RyaW5nLCBvdXRwdXQ6IFVpbnQ4QXJyYXksIG91dHB1dE9mZnNldDogbnVtYmVyKTogdm9pZCB7XG4gIHNoYXJlZFRleHRFbmNvZGVyIS5lbmNvZGVJbnRvKHN0ciwgb3V0cHV0LnN1YmFycmF5KG91dHB1dE9mZnNldCkpO1xufVxuXG5leHBvcnQgY29uc3QgdXRmOEVuY29kZVRFID0gc2hhcmVkVGV4dEVuY29kZXI/LmVuY29kZUludG8gPyB1dGY4RW5jb2RlVEVlbmNvZGVJbnRvIDogdXRmOEVuY29kZVRFZW5jb2RlO1xuXG5jb25zdCBDSFVOS19TSVpFID0gMHgxXzAwMDtcblxuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhEZWNvZGVKcyhieXRlczogVWludDhBcnJheSwgaW5wdXRPZmZzZXQ6IG51bWJlciwgYnl0ZUxlbmd0aDogbnVtYmVyKTogc3RyaW5nIHtcbiAgbGV0IG9mZnNldCA9IGlucHV0T2Zmc2V0O1xuICBjb25zdCBlbmQgPSBvZmZzZXQgKyBieXRlTGVuZ3RoO1xuXG4gIGNvbnN0IHVuaXRzOiBBcnJheTxudW1iZXI+ID0gW107XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICB3aGlsZSAob2Zmc2V0IDwgZW5kKSB7XG4gICAgY29uc3QgYnl0ZTEgPSBieXRlc1tvZmZzZXQrK10hO1xuICAgIGlmICgoYnl0ZTEgJiAweDgwKSA9PT0gMCkge1xuICAgICAgLy8gMSBieXRlXG4gICAgICB1bml0cy5wdXNoKGJ5dGUxKTtcbiAgICB9IGVsc2UgaWYgKChieXRlMSAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAvLyAyIGJ5dGVzXG4gICAgICBjb25zdCBieXRlMiA9IGJ5dGVzW29mZnNldCsrXSEgJiAweDNmO1xuICAgICAgdW5pdHMucHVzaCgoKGJ5dGUxICYgMHgxZikgPDwgNikgfCBieXRlMik7XG4gICAgfSBlbHNlIGlmICgoYnl0ZTEgJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgLy8gMyBieXRlc1xuICAgICAgY29uc3QgYnl0ZTIgPSBieXRlc1tvZmZzZXQrK10hICYgMHgzZjtcbiAgICAgIGNvbnN0IGJ5dGUzID0gYnl0ZXNbb2Zmc2V0KytdISAmIDB4M2Y7XG4gICAgICB1bml0cy5wdXNoKCgoYnl0ZTEgJiAweDFmKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMyk7XG4gICAgfSBlbHNlIGlmICgoYnl0ZTEgJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgLy8gNCBieXRlc1xuICAgICAgY29uc3QgYnl0ZTIgPSBieXRlc1tvZmZzZXQrK10hICYgMHgzZjtcbiAgICAgIGNvbnN0IGJ5dGUzID0gYnl0ZXNbb2Zmc2V0KytdISAmIDB4M2Y7XG4gICAgICBjb25zdCBieXRlNCA9IGJ5dGVzW29mZnNldCsrXSEgJiAweDNmO1xuICAgICAgbGV0IHVuaXQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwYykgfCAoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcbiAgICAgIGlmICh1bml0ID4gMHhmZmZmKSB7XG4gICAgICAgIHVuaXQgLT0gMHgxMDAwMDtcbiAgICAgICAgdW5pdHMucHVzaCgoKHVuaXQgPj4+IDEwKSAmIDB4M2ZmKSB8IDB4ZDgwMCk7XG4gICAgICAgIHVuaXQgPSAweGRjMDAgfCAodW5pdCAmIDB4M2ZmKTtcbiAgICAgIH1cbiAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXRzLnB1c2goYnl0ZTEpO1xuICAgIH1cblxuICAgIGlmICh1bml0cy5sZW5ndGggPj0gQ0hVTktfU0laRSkge1xuICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoLi4udW5pdHMpO1xuICAgICAgdW5pdHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cblxuICBpZiAodW5pdHMubGVuZ3RoID4gMCkge1xuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLnVuaXRzKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IHNoYXJlZFRleHREZWNvZGVyID0gVEVYVF9FTkNPRElOR19BVkFJTEFCTEUgPyBuZXcgVGV4dERlY29kZXIoKSA6IG51bGw7XG5leHBvcnQgY29uc3QgVEVYVF9ERUNPREVSX1RIUkVTSE9MRCA9ICFURVhUX0VOQ09ESU5HX0FWQUlMQUJMRVxuICA/IFVJTlQzMl9NQVhcbiAgOiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzPy5lbnY/LltcIlRFWFRfREVDT0RFUlwiXSAhPT0gXCJmb3JjZVwiXG4gID8gMjAwXG4gIDogMDtcblxuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhEZWNvZGVURChieXRlczogVWludDhBcnJheSwgaW5wdXRPZmZzZXQ6IG51bWJlciwgYnl0ZUxlbmd0aDogbnVtYmVyKTogc3RyaW5nIHtcbiAgY29uc3Qgc3RyaW5nQnl0ZXMgPSBieXRlcy5zdWJhcnJheShpbnB1dE9mZnNldCwgaW5wdXRPZmZzZXQgKyBieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHNoYXJlZFRleHREZWNvZGVyIS5kZWNvZGUoc3RyaW5nQnl0ZXMpO1xufVxuIiwgIi8qKlxuICogRXh0RGF0YSBpcyB1c2VkIHRvIGhhbmRsZSBFeHRlbnNpb24gVHlwZXMgdGhhdCBhcmUgbm90IHJlZ2lzdGVyZWQgdG8gRXh0ZW5zaW9uQ29kZWMuXG4gKi9cbmV4cG9ydCBjbGFzcyBFeHREYXRhIHtcbiAgY29uc3RydWN0b3IocmVhZG9ubHkgdHlwZTogbnVtYmVyLCByZWFkb25seSBkYXRhOiBVaW50OEFycmF5KSB7fVxufVxuIiwgImV4cG9ydCBjbGFzcyBEZWNvZGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG5cbiAgICAvLyBmaXggdGhlIHByb3RvdHlwZSBjaGFpbiBpbiBhIGNyb3NzLXBsYXRmb3JtIHdheVxuICAgIGNvbnN0IHByb3RvOiB0eXBlb2YgRGVjb2RlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShEZWNvZGVFcnJvci5wcm90b3R5cGUpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBwcm90byk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IERlY29kZUVycm9yLm5hbWUsXG4gICAgfSk7XG4gIH1cbn1cbiIsICIvLyBodHRwczovL2dpdGh1Yi5jb20vbXNncGFjay9tc2dwYWNrL2Jsb2IvbWFzdGVyL3NwZWMubWQjdGltZXN0YW1wLWV4dGVuc2lvbi10eXBlXG5pbXBvcnQgeyBEZWNvZGVFcnJvciB9IGZyb20gXCIuL0RlY29kZUVycm9yXCI7XG5pbXBvcnQgeyBnZXRJbnQ2NCwgc2V0SW50NjQgfSBmcm9tIFwiLi91dGlscy9pbnRcIjtcblxuZXhwb3J0IGNvbnN0IEVYVF9USU1FU1RBTVAgPSAtMTtcblxuZXhwb3J0IHR5cGUgVGltZVNwZWMgPSB7XG4gIHNlYzogbnVtYmVyO1xuICBuc2VjOiBudW1iZXI7XG59O1xuXG5jb25zdCBUSU1FU1RBTVAzMl9NQVhfU0VDID0gMHgxMDAwMDAwMDAgLSAxOyAvLyAzMi1iaXQgdW5zaWduZWQgaW50XG5jb25zdCBUSU1FU1RBTVA2NF9NQVhfU0VDID0gMHg0MDAwMDAwMDAgLSAxOyAvLyAzNC1iaXQgdW5zaWduZWQgaW50XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVUaW1lU3BlY1RvVGltZXN0YW1wKHsgc2VjLCBuc2VjIH06IFRpbWVTcGVjKTogVWludDhBcnJheSB7XG4gIGlmIChzZWMgPj0gMCAmJiBuc2VjID49IDAgJiYgc2VjIDw9IFRJTUVTVEFNUDY0X01BWF9TRUMpIHtcbiAgICAvLyBIZXJlIHNlYyA+PSAwICYmIG5zZWMgPj0gMFxuICAgIGlmIChuc2VjID09PSAwICYmIHNlYyA8PSBUSU1FU1RBTVAzMl9NQVhfU0VDKSB7XG4gICAgICAvLyB0aW1lc3RhbXAgMzIgPSB7IHNlYzMyICh1bnNpZ25lZCkgfVxuICAgICAgY29uc3QgcnYgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcocnYuYnVmZmVyKTtcbiAgICAgIHZpZXcuc2V0VWludDMyKDAsIHNlYyk7XG4gICAgICByZXR1cm4gcnY7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRpbWVzdGFtcCA2NCA9IHsgbnNlYzMwICh1bnNpZ25lZCksIHNlYzM0ICh1bnNpZ25lZCkgfVxuICAgICAgY29uc3Qgc2VjSGlnaCA9IHNlYyAvIDB4MTAwMDAwMDAwO1xuICAgICAgY29uc3Qgc2VjTG93ID0gc2VjICYgMHhmZmZmZmZmZjtcbiAgICAgIGNvbnN0IHJ2ID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KHJ2LmJ1ZmZlcik7XG4gICAgICAvLyBuc2VjMzAgfCBzZWNIaWdoMlxuICAgICAgdmlldy5zZXRVaW50MzIoMCwgKG5zZWMgPDwgMikgfCAoc2VjSGlnaCAmIDB4MykpO1xuICAgICAgLy8gc2VjTG93MzJcbiAgICAgIHZpZXcuc2V0VWludDMyKDQsIHNlY0xvdyk7XG4gICAgICByZXR1cm4gcnY7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHRpbWVzdGFtcCA5NiA9IHsgbnNlYzMyICh1bnNpZ25lZCksIHNlYzY0IChzaWduZWQpIH1cbiAgICBjb25zdCBydiA9IG5ldyBVaW50OEFycmF5KDEyKTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KHJ2LmJ1ZmZlcik7XG4gICAgdmlldy5zZXRVaW50MzIoMCwgbnNlYyk7XG4gICAgc2V0SW50NjQodmlldywgNCwgc2VjKTtcbiAgICByZXR1cm4gcnY7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZURhdGVUb1RpbWVTcGVjKGRhdGU6IERhdGUpOiBUaW1lU3BlYyB7XG4gIGNvbnN0IG1zZWMgPSBkYXRlLmdldFRpbWUoKTtcbiAgY29uc3Qgc2VjID0gTWF0aC5mbG9vcihtc2VjIC8gMWUzKTtcbiAgY29uc3QgbnNlYyA9IChtc2VjIC0gc2VjICogMWUzKSAqIDFlNjtcblxuICAvLyBOb3JtYWxpemVzIHsgc2VjLCBuc2VjIH0gdG8gZW5zdXJlIG5zZWMgaXMgdW5zaWduZWQuXG4gIGNvbnN0IG5zZWNJblNlYyA9IE1hdGguZmxvb3IobnNlYyAvIDFlOSk7XG4gIHJldHVybiB7XG4gICAgc2VjOiBzZWMgKyBuc2VjSW5TZWMsXG4gICAgbnNlYzogbnNlYyAtIG5zZWNJblNlYyAqIDFlOSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVRpbWVzdGFtcEV4dGVuc2lvbihvYmplY3Q6IHVua25vd24pOiBVaW50OEFycmF5IHwgbnVsbCB7XG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgY29uc3QgdGltZVNwZWMgPSBlbmNvZGVEYXRlVG9UaW1lU3BlYyhvYmplY3QpO1xuICAgIHJldHVybiBlbmNvZGVUaW1lU3BlY1RvVGltZXN0YW1wKHRpbWVTcGVjKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVGltZXN0YW1wVG9UaW1lU3BlYyhkYXRhOiBVaW50OEFycmF5KTogVGltZVNwZWMge1xuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG5cbiAgLy8gZGF0YSBtYXkgYmUgMzIsIDY0LCBvciA5NiBiaXRzXG4gIHN3aXRjaCAoZGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgY2FzZSA0OiB7XG4gICAgICAvLyB0aW1lc3RhbXAgMzIgPSB7IHNlYzMyIH1cbiAgICAgIGNvbnN0IHNlYyA9IHZpZXcuZ2V0VWludDMyKDApO1xuICAgICAgY29uc3QgbnNlYyA9IDA7XG4gICAgICByZXR1cm4geyBzZWMsIG5zZWMgfTtcbiAgICB9XG4gICAgY2FzZSA4OiB7XG4gICAgICAvLyB0aW1lc3RhbXAgNjQgPSB7IG5zZWMzMCwgc2VjMzQgfVxuICAgICAgY29uc3QgbnNlYzMwQW5kU2VjSGlnaDIgPSB2aWV3LmdldFVpbnQzMigwKTtcbiAgICAgIGNvbnN0IHNlY0xvdzMyID0gdmlldy5nZXRVaW50MzIoNCk7XG4gICAgICBjb25zdCBzZWMgPSAobnNlYzMwQW5kU2VjSGlnaDIgJiAweDMpICogMHgxMDAwMDAwMDAgKyBzZWNMb3czMjtcbiAgICAgIGNvbnN0IG5zZWMgPSBuc2VjMzBBbmRTZWNIaWdoMiA+Pj4gMjtcbiAgICAgIHJldHVybiB7IHNlYywgbnNlYyB9O1xuICAgIH1cbiAgICBjYXNlIDEyOiB7XG4gICAgICAvLyB0aW1lc3RhbXAgOTYgPSB7IG5zZWMzMiAodW5zaWduZWQpLCBzZWM2NCAoc2lnbmVkKSB9XG5cbiAgICAgIGNvbnN0IHNlYyA9IGdldEludDY0KHZpZXcsIDQpO1xuICAgICAgY29uc3QgbnNlYyA9IHZpZXcuZ2V0VWludDMyKDApO1xuICAgICAgcmV0dXJuIHsgc2VjLCBuc2VjIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRGVjb2RlRXJyb3IoYFVucmVjb2duaXplZCBkYXRhIHNpemUgZm9yIHRpbWVzdGFtcCAoZXhwZWN0ZWQgNCwgOCwgb3IgMTIpOiAke2RhdGEubGVuZ3RofWApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUaW1lc3RhbXBFeHRlbnNpb24oZGF0YTogVWludDhBcnJheSk6IERhdGUge1xuICBjb25zdCB0aW1lU3BlYyA9IGRlY29kZVRpbWVzdGFtcFRvVGltZVNwZWMoZGF0YSk7XG4gIHJldHVybiBuZXcgRGF0ZSh0aW1lU3BlYy5zZWMgKiAxZTMgKyB0aW1lU3BlYy5uc2VjIC8gMWU2KTtcbn1cblxuZXhwb3J0IGNvbnN0IHRpbWVzdGFtcEV4dGVuc2lvbiA9IHtcbiAgdHlwZTogRVhUX1RJTUVTVEFNUCxcbiAgZW5jb2RlOiBlbmNvZGVUaW1lc3RhbXBFeHRlbnNpb24sXG4gIGRlY29kZTogZGVjb2RlVGltZXN0YW1wRXh0ZW5zaW9uLFxufTtcbiIsICIvLyBFeHRlbnNpb25Db2RlYyB0byBoYW5kbGUgTWVzc2FnZVBhY2sgZXh0ZW5zaW9uc1xuXG5pbXBvcnQgeyBFeHREYXRhIH0gZnJvbSBcIi4vRXh0RGF0YVwiO1xuaW1wb3J0IHsgdGltZXN0YW1wRXh0ZW5zaW9uIH0gZnJvbSBcIi4vdGltZXN0YW1wXCI7XG5cbmV4cG9ydCB0eXBlIEV4dGVuc2lvbkRlY29kZXJUeXBlPENvbnRleHRUeXBlPiA9IChcbiAgZGF0YTogVWludDhBcnJheSxcbiAgZXh0ZW5zaW9uVHlwZTogbnVtYmVyLFxuICBjb250ZXh0OiBDb250ZXh0VHlwZSxcbikgPT4gdW5rbm93bjtcblxuZXhwb3J0IHR5cGUgRXh0ZW5zaW9uRW5jb2RlclR5cGU8Q29udGV4dFR5cGU+ID0gKGlucHV0OiB1bmtub3duLCBjb250ZXh0OiBDb250ZXh0VHlwZSkgPT4gVWludDhBcnJheSB8IG51bGw7XG5cbi8vIGltbXV0YWJsZSBpbnRlcmZhY2UgdG8gRXh0ZW5zaW9uQ29kZWNcbmV4cG9ydCB0eXBlIEV4dGVuc2lvbkNvZGVjVHlwZTxDb250ZXh0VHlwZT4gPSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgX19icmFuZD86IENvbnRleHRUeXBlO1xuICB0cnlUb0VuY29kZShvYmplY3Q6IHVua25vd24sIGNvbnRleHQ6IENvbnRleHRUeXBlKTogRXh0RGF0YSB8IG51bGw7XG4gIGRlY29kZShkYXRhOiBVaW50OEFycmF5LCBleHRUeXBlOiBudW1iZXIsIGNvbnRleHQ6IENvbnRleHRUeXBlKTogdW5rbm93bjtcbn07XG5cbmV4cG9ydCBjbGFzcyBFeHRlbnNpb25Db2RlYzxDb250ZXh0VHlwZSA9IHVuZGVmaW5lZD4gaW1wbGVtZW50cyBFeHRlbnNpb25Db2RlY1R5cGU8Q29udGV4dFR5cGU+IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBkZWZhdWx0Q29kZWM6IEV4dGVuc2lvbkNvZGVjVHlwZTx1bmRlZmluZWQ+ID0gbmV3IEV4dGVuc2lvbkNvZGVjKCk7XG5cbiAgLy8gZW5zdXJlcyBFeHRlbnNpb25Db2RlY1R5cGU8WD4gbWF0Y2hlcyBFeHRlbnNpb25Db2RlYzxYPlxuICAvLyB0aGlzIHdpbGwgbWFrZSB0eXBlIGVycm9ycyBhIGxvdCBtb3JlIGNsZWFyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgX19icmFuZD86IENvbnRleHRUeXBlO1xuXG4gIC8vIGJ1aWx0LWluIGV4dGVuc2lvbnNcbiAgcHJpdmF0ZSByZWFkb25seSBidWlsdEluRW5jb2RlcnM6IEFycmF5PEV4dGVuc2lvbkVuY29kZXJUeXBlPENvbnRleHRUeXBlPiB8IHVuZGVmaW5lZCB8IG51bGw+ID0gW107XG4gIHByaXZhdGUgcmVhZG9ubHkgYnVpbHRJbkRlY29kZXJzOiBBcnJheTxFeHRlbnNpb25EZWNvZGVyVHlwZTxDb250ZXh0VHlwZT4gfCB1bmRlZmluZWQgfCBudWxsPiA9IFtdO1xuXG4gIC8vIGN1c3RvbSBleHRlbnNpb25zXG4gIHByaXZhdGUgcmVhZG9ubHkgZW5jb2RlcnM6IEFycmF5PEV4dGVuc2lvbkVuY29kZXJUeXBlPENvbnRleHRUeXBlPiB8IHVuZGVmaW5lZCB8IG51bGw+ID0gW107XG4gIHByaXZhdGUgcmVhZG9ubHkgZGVjb2RlcnM6IEFycmF5PEV4dGVuc2lvbkRlY29kZXJUeXBlPENvbnRleHRUeXBlPiB8IHVuZGVmaW5lZCB8IG51bGw+ID0gW107XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucmVnaXN0ZXIodGltZXN0YW1wRXh0ZW5zaW9uKTtcbiAgfVxuXG4gIHB1YmxpYyByZWdpc3Rlcih7XG4gICAgdHlwZSxcbiAgICBlbmNvZGUsXG4gICAgZGVjb2RlLFxuICB9OiB7XG4gICAgdHlwZTogbnVtYmVyO1xuICAgIGVuY29kZTogRXh0ZW5zaW9uRW5jb2RlclR5cGU8Q29udGV4dFR5cGU+O1xuICAgIGRlY29kZTogRXh0ZW5zaW9uRGVjb2RlclR5cGU8Q29udGV4dFR5cGU+O1xuICB9KTogdm9pZCB7XG4gICAgaWYgKHR5cGUgPj0gMCkge1xuICAgICAgLy8gY3VzdG9tIGV4dGVuc2lvbnNcbiAgICAgIHRoaXMuZW5jb2RlcnNbdHlwZV0gPSBlbmNvZGU7XG4gICAgICB0aGlzLmRlY29kZXJzW3R5cGVdID0gZGVjb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBidWlsdC1pbiBleHRlbnNpb25zXG4gICAgICBjb25zdCBpbmRleCA9IDEgKyB0eXBlO1xuICAgICAgdGhpcy5idWlsdEluRW5jb2RlcnNbaW5kZXhdID0gZW5jb2RlO1xuICAgICAgdGhpcy5idWlsdEluRGVjb2RlcnNbaW5kZXhdID0gZGVjb2RlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB0cnlUb0VuY29kZShvYmplY3Q6IHVua25vd24sIGNvbnRleHQ6IENvbnRleHRUeXBlKTogRXh0RGF0YSB8IG51bGwge1xuICAgIC8vIGJ1aWx0LWluIGV4dGVuc2lvbnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnVpbHRJbkVuY29kZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbmNvZGVFeHQgPSB0aGlzLmJ1aWx0SW5FbmNvZGVyc1tpXTtcbiAgICAgIGlmIChlbmNvZGVFeHQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkYXRhID0gZW5jb2RlRXh0KG9iamVjdCwgY29udGV4dCk7XG4gICAgICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCB0eXBlID0gLTEgLSBpO1xuICAgICAgICAgIHJldHVybiBuZXcgRXh0RGF0YSh0eXBlLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGN1c3RvbSBleHRlbnNpb25zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmVuY29kZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbmNvZGVFeHQgPSB0aGlzLmVuY29kZXJzW2ldO1xuICAgICAgaWYgKGVuY29kZUV4dCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVFeHQob2JqZWN0LCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSBpO1xuICAgICAgICAgIHJldHVybiBuZXcgRXh0RGF0YSh0eXBlLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBFeHREYXRhKSB7XG4gICAgICAvLyB0byBrZWVwIEV4dERhdGEgYXMgaXNcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcHVibGljIGRlY29kZShkYXRhOiBVaW50OEFycmF5LCB0eXBlOiBudW1iZXIsIGNvbnRleHQ6IENvbnRleHRUeXBlKTogdW5rbm93biB7XG4gICAgY29uc3QgZGVjb2RlRXh0ID0gdHlwZSA8IDAgPyB0aGlzLmJ1aWx0SW5EZWNvZGVyc1stMSAtIHR5cGVdIDogdGhpcy5kZWNvZGVyc1t0eXBlXTtcbiAgICBpZiAoZGVjb2RlRXh0KSB7XG4gICAgICByZXR1cm4gZGVjb2RlRXh0KGRhdGEsIHR5cGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkZWNvZGUoKSBkb2VzIG5vdCBmYWlsLCByZXR1cm5zIEV4dERhdGEgaW5zdGVhZC5cbiAgICAgIHJldHVybiBuZXcgRXh0RGF0YSh0eXBlLCBkYXRhKTtcbiAgICB9XG4gIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZW5zdXJlVWludDhBcnJheShidWZmZXI6IEFycmF5TGlrZTxudW1iZXI+IHwgVWludDhBcnJheSB8IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKTogVWludDhBcnJheSB7XG4gIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIuYnVmZmVyLCBidWZmZXIuYnl0ZU9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICB9IGVsc2UgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXJyYXlMaWtlPG51bWJlcj5cbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGJ1ZmZlcik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURhdGFWaWV3KGJ1ZmZlcjogQXJyYXlMaWtlPG51bWJlcj4gfCBBcnJheUJ1ZmZlclZpZXcgfCBBcnJheUJ1ZmZlcik6IERhdGFWaWV3IHtcbiAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICB9XG5cbiAgY29uc3QgYnVmZmVyVmlldyA9IGVuc3VyZVVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgcmV0dXJuIG5ldyBEYXRhVmlldyhidWZmZXJWaWV3LmJ1ZmZlciwgYnVmZmVyVmlldy5ieXRlT2Zmc2V0LCBidWZmZXJWaWV3LmJ5dGVMZW5ndGgpO1xufVxuIiwgImltcG9ydCB7IHV0ZjhFbmNvZGVKcywgdXRmOENvdW50LCBURVhUX0VOQ09ERVJfVEhSRVNIT0xELCB1dGY4RW5jb2RlVEUgfSBmcm9tIFwiLi91dGlscy91dGY4XCI7XG5pbXBvcnQgeyBFeHRlbnNpb25Db2RlYywgRXh0ZW5zaW9uQ29kZWNUeXBlIH0gZnJvbSBcIi4vRXh0ZW5zaW9uQ29kZWNcIjtcbmltcG9ydCB7IHNldEludDY0LCBzZXRVaW50NjQgfSBmcm9tIFwiLi91dGlscy9pbnRcIjtcbmltcG9ydCB7IGVuc3VyZVVpbnQ4QXJyYXkgfSBmcm9tIFwiLi91dGlscy90eXBlZEFycmF5c1wiO1xuaW1wb3J0IHR5cGUgeyBFeHREYXRhIH0gZnJvbSBcIi4vRXh0RGF0YVwiO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9NQVhfREVQVEggPSAxMDA7XG5leHBvcnQgY29uc3QgREVGQVVMVF9JTklUSUFMX0JVRkZFUl9TSVpFID0gMjA0ODtcblxuZXhwb3J0IGNsYXNzIEVuY29kZXI8Q29udGV4dFR5cGUgPSB1bmRlZmluZWQ+IHtcbiAgcHJpdmF0ZSBwb3MgPSAwO1xuICBwcml2YXRlIHZpZXcgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKHRoaXMuaW5pdGlhbEJ1ZmZlclNpemUpKTtcbiAgcHJpdmF0ZSBieXRlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMudmlldy5idWZmZXIpO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGV4dGVuc2lvbkNvZGVjOiBFeHRlbnNpb25Db2RlY1R5cGU8Q29udGV4dFR5cGU+ID0gRXh0ZW5zaW9uQ29kZWMuZGVmYXVsdENvZGVjIGFzIGFueSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbnRleHQ6IENvbnRleHRUeXBlID0gdW5kZWZpbmVkIGFzIGFueSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1heERlcHRoID0gREVGQVVMVF9NQVhfREVQVEgsXG4gICAgcHJpdmF0ZSByZWFkb25seSBpbml0aWFsQnVmZmVyU2l6ZSA9IERFRkFVTFRfSU5JVElBTF9CVUZGRVJfU0laRSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNvcnRLZXlzID0gZmFsc2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBmb3JjZUZsb2F0MzIgPSBmYWxzZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGlnbm9yZVVuZGVmaW5lZCA9IGZhbHNlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZm9yY2VJbnRlZ2VyVG9GbG9hdCA9IGZhbHNlLFxuICApIHt9XG5cbiAgcHJpdmF0ZSByZWluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICB0aGlzLnBvcyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhbG1vc3QgZXF1aXZhbGVudCB0byB7QGxpbmsgRW5jb2RlciNlbmNvZGV9LCBidXQgaXQgcmV0dXJucyBhbiByZWZlcmVuY2Ugb2YgdGhlIGVuY29kZXIncyBpbnRlcm5hbCBidWZmZXIgYW5kIHRodXMgbXVjaCBmYXN0ZXIgdGhhbiB7QGxpbmsgRW5jb2RlciNlbmNvZGV9LlxuICAgKlxuICAgKiBAcmV0dXJucyBFbmNvZGVzIHRoZSBvYmplY3QgYW5kIHJldHVybnMgYSBzaGFyZWQgcmVmZXJlbmNlIHRoZSBlbmNvZGVyJ3MgaW50ZXJuYWwgYnVmZmVyLlxuICAgKi9cbiAgcHVibGljIGVuY29kZVNoYXJlZFJlZihvYmplY3Q6IHVua25vd24pOiBVaW50OEFycmF5IHtcbiAgICB0aGlzLnJlaW5pdGlhbGl6ZVN0YXRlKCk7XG4gICAgdGhpcy5kb0VuY29kZShvYmplY3QsIDEpO1xuICAgIHJldHVybiB0aGlzLmJ5dGVzLnN1YmFycmF5KDAsIHRoaXMucG9zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBFbmNvZGVzIHRoZSBvYmplY3QgYW5kIHJldHVybnMgYSBjb3B5IG9mIHRoZSBlbmNvZGVyJ3MgaW50ZXJuYWwgYnVmZmVyLlxuICAgKi9cbiAgcHVibGljIGVuY29kZShvYmplY3Q6IHVua25vd24pOiBVaW50OEFycmF5IHtcbiAgICB0aGlzLnJlaW5pdGlhbGl6ZVN0YXRlKCk7XG4gICAgdGhpcy5kb0VuY29kZShvYmplY3QsIDEpO1xuICAgIHJldHVybiB0aGlzLmJ5dGVzLnNsaWNlKDAsIHRoaXMucG9zKTtcbiAgfVxuXG4gIHByaXZhdGUgZG9FbmNvZGUob2JqZWN0OiB1bmtub3duLCBkZXB0aDogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKGRlcHRoID4gdGhpcy5tYXhEZXB0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb28gZGVlcCBvYmplY3RzIGluIGRlcHRoICR7ZGVwdGh9YCk7XG4gICAgfVxuXG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICB0aGlzLmVuY29kZU5pbCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHRoaXMuZW5jb2RlQm9vbGVhbihvYmplY3QpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdGhpcy5lbmNvZGVOdW1iZXIob2JqZWN0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuZW5jb2RlU3RyaW5nKG9iamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5jb2RlT2JqZWN0KG9iamVjdCwgZGVwdGgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoc2l6ZVRvV3JpdGU6IG51bWJlcikge1xuICAgIGNvbnN0IHJlcXVpcmVkU2l6ZSA9IHRoaXMucG9zICsgc2l6ZVRvV3JpdGU7XG5cbiAgICBpZiAodGhpcy52aWV3LmJ5dGVMZW5ndGggPCByZXF1aXJlZFNpemUpIHtcbiAgICAgIHRoaXMucmVzaXplQnVmZmVyKHJlcXVpcmVkU2l6ZSAqIDIpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVzaXplQnVmZmVyKG5ld1NpemU6IG51bWJlcikge1xuICAgIGNvbnN0IG5ld0J1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihuZXdTaXplKTtcbiAgICBjb25zdCBuZXdCeXRlcyA9IG5ldyBVaW50OEFycmF5KG5ld0J1ZmZlcik7XG4gICAgY29uc3QgbmV3VmlldyA9IG5ldyBEYXRhVmlldyhuZXdCdWZmZXIpO1xuXG4gICAgbmV3Qnl0ZXMuc2V0KHRoaXMuYnl0ZXMpO1xuXG4gICAgdGhpcy52aWV3ID0gbmV3VmlldztcbiAgICB0aGlzLmJ5dGVzID0gbmV3Qnl0ZXM7XG4gIH1cblxuICBwcml2YXRlIGVuY29kZU5pbCgpIHtcbiAgICB0aGlzLndyaXRlVTgoMHhjMCk7XG4gIH1cblxuICBwcml2YXRlIGVuY29kZUJvb2xlYW4ob2JqZWN0OiBib29sZWFuKSB7XG4gICAgaWYgKG9iamVjdCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMud3JpdGVVOCgweGMyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53cml0ZVU4KDB4YzMpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIGVuY29kZU51bWJlcihvYmplY3Q6IG51bWJlcikge1xuICAgIGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcihvYmplY3QpICYmICF0aGlzLmZvcmNlSW50ZWdlclRvRmxvYXQpIHtcbiAgICAgIGlmIChvYmplY3QgPj0gMCkge1xuICAgICAgICBpZiAob2JqZWN0IDwgMHg4MCkge1xuICAgICAgICAgIC8vIHBvc2l0aXZlIGZpeGludFxuICAgICAgICAgIHRoaXMud3JpdGVVOChvYmplY3QpO1xuICAgICAgICB9IGVsc2UgaWYgKG9iamVjdCA8IDB4MTAwKSB7XG4gICAgICAgICAgLy8gdWludCA4XG4gICAgICAgICAgdGhpcy53cml0ZVU4KDB4Y2MpO1xuICAgICAgICAgIHRoaXMud3JpdGVVOChvYmplY3QpO1xuICAgICAgICB9IGVsc2UgaWYgKG9iamVjdCA8IDB4MTAwMDApIHtcbiAgICAgICAgICAvLyB1aW50IDE2XG4gICAgICAgICAgdGhpcy53cml0ZVU4KDB4Y2QpO1xuICAgICAgICAgIHRoaXMud3JpdGVVMTYob2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3QgPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgIC8vIHVpbnQgMzJcbiAgICAgICAgICB0aGlzLndyaXRlVTgoMHhjZSk7XG4gICAgICAgICAgdGhpcy53cml0ZVUzMihvYmplY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVpbnQgNjRcbiAgICAgICAgICB0aGlzLndyaXRlVTgoMHhjZik7XG4gICAgICAgICAgdGhpcy53cml0ZVU2NChvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob2JqZWN0ID49IC0weDIwKSB7XG4gICAgICAgICAgLy8gbmVnYXRpdmUgZml4aW50XG4gICAgICAgICAgdGhpcy53cml0ZVU4KDB4ZTAgfCAob2JqZWN0ICsgMHgyMCkpO1xuICAgICAgICB9IGVsc2UgaWYgKG9iamVjdCA+PSAtMHg4MCkge1xuICAgICAgICAgIC8vIGludCA4XG4gICAgICAgICAgdGhpcy53cml0ZVU4KDB4ZDApO1xuICAgICAgICAgIHRoaXMud3JpdGVJOChvYmplY3QpO1xuICAgICAgICB9IGVsc2UgaWYgKG9iamVjdCA+PSAtMHg4MDAwKSB7XG4gICAgICAgICAgLy8gaW50IDE2XG4gICAgICAgICAgdGhpcy53cml0ZVU4KDB4ZDEpO1xuICAgICAgICAgIHRoaXMud3JpdGVJMTYob2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3QgPj0gLTB4ODAwMDAwMDApIHtcbiAgICAgICAgICAvLyBpbnQgMzJcbiAgICAgICAgICB0aGlzLndyaXRlVTgoMHhkMik7XG4gICAgICAgICAgdGhpcy53cml0ZUkzMihvYmplY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGludCA2NFxuICAgICAgICAgIHRoaXMud3JpdGVVOCgweGQzKTtcbiAgICAgICAgICB0aGlzLndyaXRlSTY0KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm9uLWludGVnZXIgbnVtYmVyc1xuICAgICAgaWYgKHRoaXMuZm9yY2VGbG9hdDMyKSB7XG4gICAgICAgIC8vIGZsb2F0IDMyXG4gICAgICAgIHRoaXMud3JpdGVVOCgweGNhKTtcbiAgICAgICAgdGhpcy53cml0ZUYzMihvYmplY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmxvYXQgNjRcbiAgICAgICAgdGhpcy53cml0ZVU4KDB4Y2IpO1xuICAgICAgICB0aGlzLndyaXRlRjY0KG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB3cml0ZVN0cmluZ0hlYWRlcihieXRlTGVuZ3RoOiBudW1iZXIpIHtcbiAgICBpZiAoYnl0ZUxlbmd0aCA8IDMyKSB7XG4gICAgICAvLyBmaXhzdHJcbiAgICAgIHRoaXMud3JpdGVVOCgweGEwICsgYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChieXRlTGVuZ3RoIDwgMHgxMDApIHtcbiAgICAgIC8vIHN0ciA4XG4gICAgICB0aGlzLndyaXRlVTgoMHhkOSk7XG4gICAgICB0aGlzLndyaXRlVTgoYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChieXRlTGVuZ3RoIDwgMHgxMDAwMCkge1xuICAgICAgLy8gc3RyIDE2XG4gICAgICB0aGlzLndyaXRlVTgoMHhkYSk7XG4gICAgICB0aGlzLndyaXRlVTE2KGJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoYnl0ZUxlbmd0aCA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAvLyBzdHIgMzJcbiAgICAgIHRoaXMud3JpdGVVOCgweGRiKTtcbiAgICAgIHRoaXMud3JpdGVVMzIoYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vIGxvbmcgc3RyaW5nOiAke2J5dGVMZW5ndGh9IGJ5dGVzIGluIFVURi04YCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBlbmNvZGVTdHJpbmcob2JqZWN0OiBzdHJpbmcpIHtcbiAgICBjb25zdCBtYXhIZWFkZXJTaXplID0gMSArIDQ7XG4gICAgY29uc3Qgc3RyTGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDtcblxuICAgIGlmIChzdHJMZW5ndGggPiBURVhUX0VOQ09ERVJfVEhSRVNIT0xEKSB7XG4gICAgICBjb25zdCBieXRlTGVuZ3RoID0gdXRmOENvdW50KG9iamVjdCk7XG4gICAgICB0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKG1heEhlYWRlclNpemUgKyBieXRlTGVuZ3RoKTtcbiAgICAgIHRoaXMud3JpdGVTdHJpbmdIZWFkZXIoYnl0ZUxlbmd0aCk7XG4gICAgICB1dGY4RW5jb2RlVEUob2JqZWN0LCB0aGlzLmJ5dGVzLCB0aGlzLnBvcyk7XG4gICAgICB0aGlzLnBvcyArPSBieXRlTGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBieXRlTGVuZ3RoID0gdXRmOENvdW50KG9iamVjdCk7XG4gICAgICB0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKG1heEhlYWRlclNpemUgKyBieXRlTGVuZ3RoKTtcbiAgICAgIHRoaXMud3JpdGVTdHJpbmdIZWFkZXIoYnl0ZUxlbmd0aCk7XG4gICAgICB1dGY4RW5jb2RlSnMob2JqZWN0LCB0aGlzLmJ5dGVzLCB0aGlzLnBvcyk7XG4gICAgICB0aGlzLnBvcyArPSBieXRlTGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZW5jb2RlT2JqZWN0KG9iamVjdDogdW5rbm93biwgZGVwdGg6IG51bWJlcikge1xuICAgIC8vIHRyeSB0byBlbmNvZGUgb2JqZWN0cyB3aXRoIGN1c3RvbSBjb2RlYyBmaXJzdCBvZiBub24tcHJpbWl0aXZlc1xuICAgIGNvbnN0IGV4dCA9IHRoaXMuZXh0ZW5zaW9uQ29kZWMudHJ5VG9FbmNvZGUob2JqZWN0LCB0aGlzLmNvbnRleHQpO1xuICAgIGlmIChleHQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5lbmNvZGVFeHRlbnNpb24oZXh0KTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgdGhpcy5lbmNvZGVBcnJheShvYmplY3QsIGRlcHRoKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhvYmplY3QpKSB7XG4gICAgICB0aGlzLmVuY29kZUJpbmFyeShvYmplY3QpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgdGhpcy5lbmNvZGVNYXAob2JqZWN0IGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LCBkZXB0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN5bWJvbCwgZnVuY3Rpb24gYW5kIG90aGVyIHNwZWNpYWwgb2JqZWN0IGNvbWUgaGVyZSB1bmxlc3MgZXh0ZW5zaW9uQ29kZWMgaGFuZGxlcyB0aGVtLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgb2JqZWN0OiAke09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkob2JqZWN0KX1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGVuY29kZUJpbmFyeShvYmplY3Q6IEFycmF5QnVmZmVyVmlldykge1xuICAgIGNvbnN0IHNpemUgPSBvYmplY3QuYnl0ZUxlbmd0aDtcbiAgICBpZiAoc2l6ZSA8IDB4MTAwKSB7XG4gICAgICAvLyBiaW4gOFxuICAgICAgdGhpcy53cml0ZVU4KDB4YzQpO1xuICAgICAgdGhpcy53cml0ZVU4KHNpemUpO1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDB4MTAwMDApIHtcbiAgICAgIC8vIGJpbiAxNlxuICAgICAgdGhpcy53cml0ZVU4KDB4YzUpO1xuICAgICAgdGhpcy53cml0ZVUxNihzaXplKTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMDAwMDAwMCkge1xuICAgICAgLy8gYmluIDMyXG4gICAgICB0aGlzLndyaXRlVTgoMHhjNik7XG4gICAgICB0aGlzLndyaXRlVTMyKHNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvbyBsYXJnZSBiaW5hcnk6ICR7c2l6ZX1gKTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSBlbnN1cmVVaW50OEFycmF5KG9iamVjdCk7XG4gICAgdGhpcy53cml0ZVU4YShieXRlcyk7XG4gIH1cblxuICBwcml2YXRlIGVuY29kZUFycmF5KG9iamVjdDogQXJyYXk8dW5rbm93bj4sIGRlcHRoOiBudW1iZXIpIHtcbiAgICBjb25zdCBzaXplID0gb2JqZWN0Lmxlbmd0aDtcbiAgICBpZiAoc2l6ZSA8IDE2KSB7XG4gICAgICAvLyBmaXhhcnJheVxuICAgICAgdGhpcy53cml0ZVU4KDB4OTAgKyBzaXplKTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMDAwKSB7XG4gICAgICAvLyBhcnJheSAxNlxuICAgICAgdGhpcy53cml0ZVU4KDB4ZGMpO1xuICAgICAgdGhpcy53cml0ZVUxNihzaXplKTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMDAwMDAwMCkge1xuICAgICAgLy8gYXJyYXkgMzJcbiAgICAgIHRoaXMud3JpdGVVOCgweGRkKTtcbiAgICAgIHRoaXMud3JpdGVVMzIoc2l6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vIGxhcmdlIGFycmF5OiAke3NpemV9YCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBvYmplY3QpIHtcbiAgICAgIHRoaXMuZG9FbmNvZGUoaXRlbSwgZGVwdGggKyAxKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNvdW50V2l0aG91dFVuZGVmaW5lZChvYmplY3Q6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LCBrZXlzOiBSZWFkb25seUFycmF5PHN0cmluZz4pOiBudW1iZXIge1xuICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAob2JqZWN0W2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb3VudDtcbiAgfVxuXG4gIHByaXZhdGUgZW5jb2RlTWFwKG9iamVjdDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIGRlcHRoOiBudW1iZXIpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICBpZiAodGhpcy5zb3J0S2V5cykge1xuICAgICAga2V5cy5zb3J0KCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuaWdub3JlVW5kZWZpbmVkID8gdGhpcy5jb3VudFdpdGhvdXRVbmRlZmluZWQob2JqZWN0LCBrZXlzKSA6IGtleXMubGVuZ3RoO1xuXG4gICAgaWYgKHNpemUgPCAxNikge1xuICAgICAgLy8gZml4bWFwXG4gICAgICB0aGlzLndyaXRlVTgoMHg4MCArIHNpemUpO1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDB4MTAwMDApIHtcbiAgICAgIC8vIG1hcCAxNlxuICAgICAgdGhpcy53cml0ZVU4KDB4ZGUpO1xuICAgICAgdGhpcy53cml0ZVUxNihzaXplKTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMDAwMDAwMCkge1xuICAgICAgLy8gbWFwIDMyXG4gICAgICB0aGlzLndyaXRlVTgoMHhkZik7XG4gICAgICB0aGlzLndyaXRlVTMyKHNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvbyBsYXJnZSBtYXAgb2JqZWN0OiAke3NpemV9YCk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgaWYgKCEodGhpcy5pZ25vcmVVbmRlZmluZWQgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdGhpcy5lbmNvZGVTdHJpbmcoa2V5KTtcbiAgICAgICAgdGhpcy5kb0VuY29kZSh2YWx1ZSwgZGVwdGggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGVuY29kZUV4dGVuc2lvbihleHQ6IEV4dERhdGEpIHtcbiAgICBjb25zdCBzaXplID0gZXh0LmRhdGEubGVuZ3RoO1xuICAgIGlmIChzaXplID09PSAxKSB7XG4gICAgICAvLyBmaXhleHQgMVxuICAgICAgdGhpcy53cml0ZVU4KDB4ZDQpO1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gMikge1xuICAgICAgLy8gZml4ZXh0IDJcbiAgICAgIHRoaXMud3JpdGVVOCgweGQ1KTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPT09IDQpIHtcbiAgICAgIC8vIGZpeGV4dCA0XG4gICAgICB0aGlzLndyaXRlVTgoMHhkNik7XG4gICAgfSBlbHNlIGlmIChzaXplID09PSA4KSB7XG4gICAgICAvLyBmaXhleHQgOFxuICAgICAgdGhpcy53cml0ZVU4KDB4ZDcpO1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gMTYpIHtcbiAgICAgIC8vIGZpeGV4dCAxNlxuICAgICAgdGhpcy53cml0ZVU4KDB4ZDgpO1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDB4MTAwKSB7XG4gICAgICAvLyBleHQgOFxuICAgICAgdGhpcy53cml0ZVU4KDB4YzcpO1xuICAgICAgdGhpcy53cml0ZVU4KHNpemUpO1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDB4MTAwMDApIHtcbiAgICAgIC8vIGV4dCAxNlxuICAgICAgdGhpcy53cml0ZVU4KDB4YzgpO1xuICAgICAgdGhpcy53cml0ZVUxNihzaXplKTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMDAwMDAwMCkge1xuICAgICAgLy8gZXh0IDMyXG4gICAgICB0aGlzLndyaXRlVTgoMHhjOSk7XG4gICAgICB0aGlzLndyaXRlVTMyKHNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvbyBsYXJnZSBleHRlbnNpb24gb2JqZWN0OiAke3NpemV9YCk7XG4gICAgfVxuICAgIHRoaXMud3JpdGVJOChleHQudHlwZSk7XG4gICAgdGhpcy53cml0ZVU4YShleHQuZGF0YSk7XG4gIH1cblxuICBwcml2YXRlIHdyaXRlVTgodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoMSk7XG5cbiAgICB0aGlzLnZpZXcuc2V0VWludDgodGhpcy5wb3MsIHZhbHVlKTtcbiAgICB0aGlzLnBvcysrO1xuICB9XG5cbiAgcHJpdmF0ZSB3cml0ZVU4YSh2YWx1ZXM6IEFycmF5TGlrZTxudW1iZXI+KSB7XG4gICAgY29uc3Qgc2l6ZSA9IHZhbHVlcy5sZW5ndGg7XG4gICAgdGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZShzaXplKTtcblxuICAgIHRoaXMuYnl0ZXMuc2V0KHZhbHVlcywgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IHNpemU7XG4gIH1cblxuICBwcml2YXRlIHdyaXRlSTgodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoMSk7XG5cbiAgICB0aGlzLnZpZXcuc2V0SW50OCh0aGlzLnBvcywgdmFsdWUpO1xuICAgIHRoaXMucG9zKys7XG4gIH1cblxuICBwcml2YXRlIHdyaXRlVTE2KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDIpO1xuXG4gICAgdGhpcy52aWV3LnNldFVpbnQxNih0aGlzLnBvcywgdmFsdWUpO1xuICAgIHRoaXMucG9zICs9IDI7XG4gIH1cblxuICBwcml2YXRlIHdyaXRlSTE2KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDIpO1xuXG4gICAgdGhpcy52aWV3LnNldEludDE2KHRoaXMucG9zLCB2YWx1ZSk7XG4gICAgdGhpcy5wb3MgKz0gMjtcbiAgfVxuXG4gIHByaXZhdGUgd3JpdGVVMzIodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoNCk7XG5cbiAgICB0aGlzLnZpZXcuc2V0VWludDMyKHRoaXMucG9zLCB2YWx1ZSk7XG4gICAgdGhpcy5wb3MgKz0gNDtcbiAgfVxuXG4gIHByaXZhdGUgd3JpdGVJMzIodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoNCk7XG5cbiAgICB0aGlzLnZpZXcuc2V0SW50MzIodGhpcy5wb3MsIHZhbHVlKTtcbiAgICB0aGlzLnBvcyArPSA0O1xuICB9XG5cbiAgcHJpdmF0ZSB3cml0ZUYzMih2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSg0KTtcbiAgICB0aGlzLnZpZXcuc2V0RmxvYXQzMih0aGlzLnBvcywgdmFsdWUpO1xuICAgIHRoaXMucG9zICs9IDQ7XG4gIH1cblxuICBwcml2YXRlIHdyaXRlRjY0KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDgpO1xuICAgIHRoaXMudmlldy5zZXRGbG9hdDY0KHRoaXMucG9zLCB2YWx1ZSk7XG4gICAgdGhpcy5wb3MgKz0gODtcbiAgfVxuXG4gIHByaXZhdGUgd3JpdGVVNjQodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoOCk7XG5cbiAgICBzZXRVaW50NjQodGhpcy52aWV3LCB0aGlzLnBvcywgdmFsdWUpO1xuICAgIHRoaXMucG9zICs9IDg7XG4gIH1cblxuICBwcml2YXRlIHdyaXRlSTY0KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDgpO1xuXG4gICAgc2V0SW50NjQodGhpcy52aWV3LCB0aGlzLnBvcywgdmFsdWUpO1xuICAgIHRoaXMucG9zICs9IDg7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBFbmNvZGVyIH0gZnJvbSBcIi4vRW5jb2RlclwiO1xuaW1wb3J0IHR5cGUgeyBFeHRlbnNpb25Db2RlY1R5cGUgfSBmcm9tIFwiLi9FeHRlbnNpb25Db2RlY1wiO1xuaW1wb3J0IHR5cGUgeyBDb250ZXh0T2YsIFNwbGl0VW5kZWZpbmVkIH0gZnJvbSBcIi4vY29udGV4dFwiO1xuXG5leHBvcnQgdHlwZSBFbmNvZGVPcHRpb25zPENvbnRleHRUeXBlID0gdW5kZWZpbmVkPiA9IFBhcnRpYWw8XG4gIFJlYWRvbmx5PHtcbiAgICBleHRlbnNpb25Db2RlYzogRXh0ZW5zaW9uQ29kZWNUeXBlPENvbnRleHRUeXBlPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIGRlcHRoIGluIG5lc3RlZCBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0byAxMDAuXG4gICAgICovXG4gICAgbWF4RGVwdGg6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbml0aWFsIHNpemUgb2YgdGhlIGludGVybmFsIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRvIDIwNDguXG4gICAgICovXG4gICAgaW5pdGlhbEJ1ZmZlclNpemU6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgdGhlIGtleXMgb2YgYW4gb2JqZWN0IGlzIHNvcnRlZC4gSW4gb3RoZXIgd29yZHMsIHRoZSBlbmNvZGVkXG4gICAgICogYmluYXJ5IGlzIGNhbm9uaWNhbCBhbmQgdGh1cyBjb21wYXJhYmxlIHRvIGFub3RoZXIgZW5jb2RlZCBiaW5hcnkuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLiBJZiBlbmFibGVkLCBpdCBzcGVuZHMgbW9yZSB0aW1lIGluIGVuY29kaW5nIG9iamVjdHMuXG4gICAgICovXG4gICAgc29ydEtleXM6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCBub24taW50ZWdlciBudW1iZXJzIGFyZSBlbmNvZGVkIGluIGZsb2F0MzIsIG5vdCBpbiBmbG9hdDY0ICh0aGUgZGVmYXVsdCkuXG4gICAgICpcbiAgICAgKiBPbmx5IHVzZSBpdCBpZiBwcmVjaXNpb25zIGRvbid0IG1hdHRlci5cbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICovXG4gICAgZm9yY2VGbG9hdDMyOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCBhbiBvYmplY3QgcHJvcGVydHkgd2l0aCBgdW5kZWZpbmVkYCB2YWx1ZSBhcmUgaWdub3JlZC5cbiAgICAgKiBlLmcuIGB7IGZvbzogdW5kZWZpbmVkIH1gIHdpbGwgYmUgZW5jb2RlZCBhcyBge31gLCBhcyBgSlNPTi5zdHJpbmdpZnkoKWAgZG9lcy5cbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRvIGBmYWxzZWAuIElmIGVuYWJsZWQsIGl0IHNwZW5kcyBtb3JlIHRpbWUgaW4gZW5jb2Rpbmcgb2JqZWN0cy5cbiAgICAgKi9cbiAgICBpZ25vcmVVbmRlZmluZWQ6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIGludGVnZXIgbnVtYmVycyBhcmUgZW5jb2RlZCBhcyBmbG9hdGluZyBwb2ludCBudW1iZXJzLFxuICAgICAqIHdpdGggdGhlIGBmb3JjZUZsb2F0MzJgIG9wdGlvbiB0YWtlbiBpbnRvIGFjY291bnQuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZvcmNlSW50ZWdlclRvRmxvYXQ6IGJvb2xlYW47XG4gIH0+XG4+ICZcbiAgQ29udGV4dE9mPENvbnRleHRUeXBlPjtcblxuY29uc3QgZGVmYXVsdEVuY29kZU9wdGlvbnM6IEVuY29kZU9wdGlvbnMgPSB7fTtcblxuLyoqXG4gKiBJdCBlbmNvZGVzIGB2YWx1ZWAgaW4gdGhlIE1lc3NhZ2VQYWNrIGZvcm1hdCBhbmRcbiAqIHJldHVybnMgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgYnVmZmVyIGlzIGEgc2xpY2Ugb2YgYSBsYXJnZXIgYEFycmF5QnVmZmVyYCwgc28geW91IGhhdmUgdG8gdXNlIGl0cyBgI2J5dGVPZmZzZXRgIGFuZCBgI2J5dGVMZW5ndGhgIGluIG9yZGVyIHRvIGNvbnZlcnQgaXQgdG8gYW5vdGhlciB0eXBlZCBhcnJheXMgaW5jbHVkaW5nIE5vZGVKUyBgQnVmZmVyYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZTxDb250ZXh0VHlwZSA9IHVuZGVmaW5lZD4oXG4gIHZhbHVlOiB1bmtub3duLFxuICBvcHRpb25zOiBFbmNvZGVPcHRpb25zPFNwbGl0VW5kZWZpbmVkPENvbnRleHRUeXBlPj4gPSBkZWZhdWx0RW5jb2RlT3B0aW9ucyBhcyBhbnksXG4pOiBVaW50OEFycmF5IHtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBFbmNvZGVyKFxuICAgIG9wdGlvbnMuZXh0ZW5zaW9uQ29kZWMsXG4gICAgKG9wdGlvbnMgYXMgdHlwZW9mIG9wdGlvbnMgJiB7IGNvbnRleHQ6IGFueSB9KS5jb250ZXh0LFxuICAgIG9wdGlvbnMubWF4RGVwdGgsXG4gICAgb3B0aW9ucy5pbml0aWFsQnVmZmVyU2l6ZSxcbiAgICBvcHRpb25zLnNvcnRLZXlzLFxuICAgIG9wdGlvbnMuZm9yY2VGbG9hdDMyLFxuICAgIG9wdGlvbnMuaWdub3JlVW5kZWZpbmVkLFxuICAgIG9wdGlvbnMuZm9yY2VJbnRlZ2VyVG9GbG9hdCxcbiAgKTtcbiAgcmV0dXJuIGVuY29kZXIuZW5jb2RlU2hhcmVkUmVmKHZhbHVlKTtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gcHJldHR5Qnl0ZShieXRlOiBudW1iZXIpOiBzdHJpbmcge1xuICByZXR1cm4gYCR7Ynl0ZSA8IDAgPyBcIi1cIiA6IFwiXCJ9MHgke01hdGguYWJzKGJ5dGUpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIil9YDtcbn1cbiIsICJpbXBvcnQgeyB1dGY4RGVjb2RlSnMgfSBmcm9tIFwiLi91dGlscy91dGY4XCI7XG5cbmNvbnN0IERFRkFVTFRfTUFYX0tFWV9MRU5HVEggPSAxNjtcbmNvbnN0IERFRkFVTFRfTUFYX0xFTkdUSF9QRVJfS0VZID0gMTY7XG5cbmV4cG9ydCBpbnRlcmZhY2UgS2V5RGVjb2RlciB7XG4gIGNhbkJlQ2FjaGVkKGJ5dGVMZW5ndGg6IG51bWJlcik6IGJvb2xlYW47XG4gIGRlY29kZShieXRlczogVWludDhBcnJheSwgaW5wdXRPZmZzZXQ6IG51bWJlciwgYnl0ZUxlbmd0aDogbnVtYmVyKTogc3RyaW5nO1xufVxuaW50ZXJmYWNlIEtleUNhY2hlUmVjb3JkIHtcbiAgcmVhZG9ubHkgYnl0ZXM6IFVpbnQ4QXJyYXk7XG4gIHJlYWRvbmx5IHN0cjogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQ2FjaGVkS2V5RGVjb2RlciBpbXBsZW1lbnRzIEtleURlY29kZXIge1xuICBoaXQgPSAwO1xuICBtaXNzID0gMDtcbiAgcHJpdmF0ZSByZWFkb25seSBjYWNoZXM6IEFycmF5PEFycmF5PEtleUNhY2hlUmVjb3JkPj47XG5cbiAgY29uc3RydWN0b3IocmVhZG9ubHkgbWF4S2V5TGVuZ3RoID0gREVGQVVMVF9NQVhfS0VZX0xFTkdUSCwgcmVhZG9ubHkgbWF4TGVuZ3RoUGVyS2V5ID0gREVGQVVMVF9NQVhfTEVOR1RIX1BFUl9LRVkpIHtcbiAgICAvLyBhdm9pZCBgbmV3IEFycmF5KE4pYCwgd2hpY2ggbWFrZXMgYSBzcGFyc2UgYXJyYXksXG4gICAgLy8gYmVjYXVzZSBhIHNwYXJzZSBhcnJheSBpcyB0eXBpY2FsbHkgc2xvd2VyIHRoYW4gYSBub24tc3BhcnNlIGFycmF5LlxuICAgIHRoaXMuY2FjaGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1heEtleUxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmNhY2hlcy5wdXNoKFtdKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY2FuQmVDYWNoZWQoYnl0ZUxlbmd0aDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGJ5dGVMZW5ndGggPiAwICYmIGJ5dGVMZW5ndGggPD0gdGhpcy5tYXhLZXlMZW5ndGg7XG4gIH1cblxuICBwcml2YXRlIGZpbmQoYnl0ZXM6IFVpbnQ4QXJyYXksIGlucHV0T2Zmc2V0OiBudW1iZXIsIGJ5dGVMZW5ndGg6IG51bWJlcik6IHN0cmluZyB8IG51bGwge1xuICAgIGNvbnN0IHJlY29yZHMgPSB0aGlzLmNhY2hlc1tieXRlTGVuZ3RoIC0gMV0hO1xuXG4gICAgRklORF9DSFVOSzogZm9yIChjb25zdCByZWNvcmQgb2YgcmVjb3Jkcykge1xuICAgICAgY29uc3QgcmVjb3JkQnl0ZXMgPSByZWNvcmQuYnl0ZXM7XG5cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYnl0ZUxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWNvcmRCeXRlc1tqXSAhPT0gYnl0ZXNbaW5wdXRPZmZzZXQgKyBqXSkge1xuICAgICAgICAgIGNvbnRpbnVlIEZJTkRfQ0hVTks7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZWNvcmQuc3RyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgc3RvcmUoYnl0ZXM6IFVpbnQ4QXJyYXksIHZhbHVlOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZWNvcmRzID0gdGhpcy5jYWNoZXNbYnl0ZXMubGVuZ3RoIC0gMV0hO1xuICAgIGNvbnN0IHJlY29yZDogS2V5Q2FjaGVSZWNvcmQgPSB7IGJ5dGVzLCBzdHI6IHZhbHVlIH07XG5cbiAgICBpZiAocmVjb3Jkcy5sZW5ndGggPj0gdGhpcy5tYXhMZW5ndGhQZXJLZXkpIHtcbiAgICAgIC8vIGByZWNvcmRzYCBhcmUgZnVsbCFcbiAgICAgIC8vIFNldCBgcmVjb3JkYCB0byBhbiBhcmJpdHJhcnkgcG9zaXRpb24uXG4gICAgICByZWNvcmRzWyhNYXRoLnJhbmRvbSgpICogcmVjb3Jkcy5sZW5ndGgpIHwgMF0gPSByZWNvcmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY29yZHMucHVzaChyZWNvcmQpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZWNvZGUoYnl0ZXM6IFVpbnQ4QXJyYXksIGlucHV0T2Zmc2V0OiBudW1iZXIsIGJ5dGVMZW5ndGg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgY29uc3QgY2FjaGVkVmFsdWUgPSB0aGlzLmZpbmQoYnl0ZXMsIGlucHV0T2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICBpZiAoY2FjaGVkVmFsdWUgIT0gbnVsbCkge1xuICAgICAgdGhpcy5oaXQrKztcbiAgICAgIHJldHVybiBjYWNoZWRWYWx1ZTtcbiAgICB9XG4gICAgdGhpcy5taXNzKys7XG5cbiAgICBjb25zdCBzdHIgPSB1dGY4RGVjb2RlSnMoYnl0ZXMsIGlucHV0T2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAvLyBFbnN1cmUgdG8gY29weSBhIHNsaWNlIG9mIGJ5dGVzIGJlY2F1c2UgdGhlIGJ5dGUgbWF5IGJlIE5vZGVKUyBCdWZmZXIgYW5kIEJ1ZmZlciNzbGljZSgpIHJldHVybnMgYSByZWZlcmVuY2UgdG8gaXRzIGludGVybmFsIEFycmF5QnVmZmVyLlxuICAgIGNvbnN0IHNsaWNlZENvcHlPZkJ5dGVzID0gVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChieXRlcywgaW5wdXRPZmZzZXQsIGlucHV0T2Zmc2V0ICsgYnl0ZUxlbmd0aCk7XG4gICAgdGhpcy5zdG9yZShzbGljZWRDb3B5T2ZCeXRlcywgc3RyKTtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgcHJldHR5Qnl0ZSB9IGZyb20gXCIuL3V0aWxzL3ByZXR0eUJ5dGVcIjtcbmltcG9ydCB7IEV4dGVuc2lvbkNvZGVjLCBFeHRlbnNpb25Db2RlY1R5cGUgfSBmcm9tIFwiLi9FeHRlbnNpb25Db2RlY1wiO1xuaW1wb3J0IHsgZ2V0SW50NjQsIGdldFVpbnQ2NCwgVUlOVDMyX01BWCB9IGZyb20gXCIuL3V0aWxzL2ludFwiO1xuaW1wb3J0IHsgdXRmOERlY29kZUpzLCBURVhUX0RFQ09ERVJfVEhSRVNIT0xELCB1dGY4RGVjb2RlVEQgfSBmcm9tIFwiLi91dGlscy91dGY4XCI7XG5pbXBvcnQgeyBjcmVhdGVEYXRhVmlldywgZW5zdXJlVWludDhBcnJheSB9IGZyb20gXCIuL3V0aWxzL3R5cGVkQXJyYXlzXCI7XG5pbXBvcnQgeyBDYWNoZWRLZXlEZWNvZGVyLCBLZXlEZWNvZGVyIH0gZnJvbSBcIi4vQ2FjaGVkS2V5RGVjb2RlclwiO1xuaW1wb3J0IHsgRGVjb2RlRXJyb3IgfSBmcm9tIFwiLi9EZWNvZGVFcnJvclwiO1xuXG5jb25zdCBlbnVtIFN0YXRlIHtcbiAgQVJSQVksXG4gIE1BUF9LRVksXG4gIE1BUF9WQUxVRSxcbn1cblxudHlwZSBNYXBLZXlUeXBlID0gc3RyaW5nIHwgbnVtYmVyO1xuXG5jb25zdCBpc1ZhbGlkTWFwS2V5VHlwZSA9IChrZXk6IHVua25vd24pOiBrZXkgaXMgTWFwS2V5VHlwZSA9PiB7XG4gIGNvbnN0IGtleVR5cGUgPSB0eXBlb2Yga2V5O1xuXG4gIHJldHVybiBrZXlUeXBlID09PSBcInN0cmluZ1wiIHx8IGtleVR5cGUgPT09IFwibnVtYmVyXCI7XG59O1xuXG50eXBlIFN0YWNrTWFwU3RhdGUgPSB7XG4gIHR5cGU6IFN0YXRlLk1BUF9LRVkgfCBTdGF0ZS5NQVBfVkFMVUU7XG4gIHNpemU6IG51bWJlcjtcbiAga2V5OiBNYXBLZXlUeXBlIHwgbnVsbDtcbiAgcmVhZENvdW50OiBudW1iZXI7XG4gIG1hcDogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG59O1xuXG50eXBlIFN0YWNrQXJyYXlTdGF0ZSA9IHtcbiAgdHlwZTogU3RhdGUuQVJSQVk7XG4gIHNpemU6IG51bWJlcjtcbiAgYXJyYXk6IEFycmF5PHVua25vd24+O1xuICBwb3NpdGlvbjogbnVtYmVyO1xufTtcblxudHlwZSBTdGFja1N0YXRlID0gU3RhY2tBcnJheVN0YXRlIHwgU3RhY2tNYXBTdGF0ZTtcblxuY29uc3QgSEVBRF9CWVRFX1JFUVVJUkVEID0gLTE7XG5cbmNvbnN0IEVNUFRZX1ZJRVcgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDApKTtcbmNvbnN0IEVNUFRZX0JZVEVTID0gbmV3IFVpbnQ4QXJyYXkoRU1QVFlfVklFVy5idWZmZXIpO1xuXG4vLyBJRTExOiBIYWNrIHRvIHN1cHBvcnQgSUUxMS5cbi8vIElFMTE6IERyb3AgdGhpcyBoYWNrIGFuZCBqdXN0IHVzZSBSYW5nZUVycm9yIHdoZW4gSUUxMSBpcyBvYnNvbGV0ZS5cbmV4cG9ydCBjb25zdCBEYXRhVmlld0luZGV4T3V0T2ZCb3VuZHNFcnJvcjogdHlwZW9mIEVycm9yID0gKCgpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBJRTExOiBUaGUgc3BlYyBzYXlzIGl0IHNob3VsZCB0aHJvdyBSYW5nZUVycm9yLFxuICAgIC8vIElFMTE6IGJ1dCBpbiBJRTExIGl0IHRocm93cyBUeXBlRXJyb3IuXG4gICAgRU1QVFlfVklFVy5nZXRJbnQ4KDApO1xuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICByZXR1cm4gZS5jb25zdHJ1Y3RvcjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJuZXZlciByZWFjaGVkXCIpO1xufSkoKTtcblxuY29uc3QgTU9SRV9EQVRBID0gbmV3IERhdGFWaWV3SW5kZXhPdXRPZkJvdW5kc0Vycm9yKFwiSW5zdWZmaWNpZW50IGRhdGFcIik7XG5cbmNvbnN0IHNoYXJlZENhY2hlZEtleURlY29kZXIgPSBuZXcgQ2FjaGVkS2V5RGVjb2RlcigpO1xuXG5leHBvcnQgY2xhc3MgRGVjb2RlcjxDb250ZXh0VHlwZSA9IHVuZGVmaW5lZD4ge1xuICBwcml2YXRlIHRvdGFsUG9zID0gMDtcbiAgcHJpdmF0ZSBwb3MgPSAwO1xuXG4gIHByaXZhdGUgdmlldyA9IEVNUFRZX1ZJRVc7XG4gIHByaXZhdGUgYnl0ZXMgPSBFTVBUWV9CWVRFUztcbiAgcHJpdmF0ZSBoZWFkQnl0ZSA9IEhFQURfQllURV9SRVFVSVJFRDtcbiAgcHJpdmF0ZSByZWFkb25seSBzdGFjazogQXJyYXk8U3RhY2tTdGF0ZT4gPSBbXTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBleHRlbnNpb25Db2RlYzogRXh0ZW5zaW9uQ29kZWNUeXBlPENvbnRleHRUeXBlPiA9IEV4dGVuc2lvbkNvZGVjLmRlZmF1bHRDb2RlYyBhcyBhbnksXG4gICAgcHJpdmF0ZSByZWFkb25seSBjb250ZXh0OiBDb250ZXh0VHlwZSA9IHVuZGVmaW5lZCBhcyBhbnksXG4gICAgcHJpdmF0ZSByZWFkb25seSBtYXhTdHJMZW5ndGggPSBVSU5UMzJfTUFYLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbWF4QmluTGVuZ3RoID0gVUlOVDMyX01BWCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1heEFycmF5TGVuZ3RoID0gVUlOVDMyX01BWCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1heE1hcExlbmd0aCA9IFVJTlQzMl9NQVgsXG4gICAgcHJpdmF0ZSByZWFkb25seSBtYXhFeHRMZW5ndGggPSBVSU5UMzJfTUFYLFxuICAgIHByaXZhdGUgcmVhZG9ubHkga2V5RGVjb2RlcjogS2V5RGVjb2RlciB8IG51bGwgPSBzaGFyZWRDYWNoZWRLZXlEZWNvZGVyLFxuICApIHt9XG5cbiAgcHJpdmF0ZSByZWluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICB0aGlzLnRvdGFsUG9zID0gMDtcbiAgICB0aGlzLmhlYWRCeXRlID0gSEVBRF9CWVRFX1JFUVVJUkVEO1xuICAgIHRoaXMuc3RhY2subGVuZ3RoID0gMDtcblxuICAgIC8vIHZpZXcsIGJ5dGVzLCBhbmQgcG9zIHdpbGwgYmUgcmUtaW5pdGlhbGl6ZWQgaW4gc2V0QnVmZmVyKClcbiAgfVxuXG4gIHByaXZhdGUgc2V0QnVmZmVyKGJ1ZmZlcjogQXJyYXlMaWtlPG51bWJlcj4gfCBCdWZmZXJTb3VyY2UpOiB2b2lkIHtcbiAgICB0aGlzLmJ5dGVzID0gZW5zdXJlVWludDhBcnJheShidWZmZXIpO1xuICAgIHRoaXMudmlldyA9IGNyZWF0ZURhdGFWaWV3KHRoaXMuYnl0ZXMpO1xuICAgIHRoaXMucG9zID0gMDtcbiAgfVxuXG4gIHByaXZhdGUgYXBwZW5kQnVmZmVyKGJ1ZmZlcjogQXJyYXlMaWtlPG51bWJlcj4gfCBCdWZmZXJTb3VyY2UpIHtcbiAgICBpZiAodGhpcy5oZWFkQnl0ZSA9PT0gSEVBRF9CWVRFX1JFUVVJUkVEICYmICF0aGlzLmhhc1JlbWFpbmluZygxKSkge1xuICAgICAgdGhpcy5zZXRCdWZmZXIoYnVmZmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVtYWluaW5nRGF0YSA9IHRoaXMuYnl0ZXMuc3ViYXJyYXkodGhpcy5wb3MpO1xuICAgICAgY29uc3QgbmV3RGF0YSA9IGVuc3VyZVVpbnQ4QXJyYXkoYnVmZmVyKTtcblxuICAgICAgLy8gY29uY2F0IHJlbWFpbmluZ0RhdGEgKyBuZXdEYXRhXG4gICAgICBjb25zdCBuZXdCdWZmZXIgPSBuZXcgVWludDhBcnJheShyZW1haW5pbmdEYXRhLmxlbmd0aCArIG5ld0RhdGEubGVuZ3RoKTtcbiAgICAgIG5ld0J1ZmZlci5zZXQocmVtYWluaW5nRGF0YSk7XG4gICAgICBuZXdCdWZmZXIuc2V0KG5ld0RhdGEsIHJlbWFpbmluZ0RhdGEubGVuZ3RoKTtcbiAgICAgIHRoaXMuc2V0QnVmZmVyKG5ld0J1ZmZlcik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYXNSZW1haW5pbmcoc2l6ZTogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5ieXRlTGVuZ3RoIC0gdGhpcy5wb3MgPj0gc2l6ZTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRXh0cmFCeXRlRXJyb3IocG9zVG9TaG93OiBudW1iZXIpOiBFcnJvciB7XG4gICAgY29uc3QgeyB2aWV3LCBwb3MgfSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBSYW5nZUVycm9yKGBFeHRyYSAke3ZpZXcuYnl0ZUxlbmd0aCAtIHBvc30gb2YgJHt2aWV3LmJ5dGVMZW5ndGh9IGJ5dGUocykgZm91bmQgYXQgYnVmZmVyWyR7cG9zVG9TaG93fV1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhyb3dzIHtAbGluayBEZWNvZGVFcnJvcn1cbiAgICogQHRocm93cyB7QGxpbmsgUmFuZ2VFcnJvcn1cbiAgICovXG4gIHB1YmxpYyBkZWNvZGUoYnVmZmVyOiBBcnJheUxpa2U8bnVtYmVyPiB8IEJ1ZmZlclNvdXJjZSk6IHVua25vd24ge1xuICAgIHRoaXMucmVpbml0aWFsaXplU3RhdGUoKTtcbiAgICB0aGlzLnNldEJ1ZmZlcihidWZmZXIpO1xuXG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy5kb0RlY29kZVN5bmMoKTtcbiAgICBpZiAodGhpcy5oYXNSZW1haW5pbmcoMSkpIHtcbiAgICAgIHRocm93IHRoaXMuY3JlYXRlRXh0cmFCeXRlRXJyb3IodGhpcy5wb3MpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgcHVibGljICpkZWNvZGVNdWx0aShidWZmZXI6IEFycmF5TGlrZTxudW1iZXI+IHwgQnVmZmVyU291cmNlKTogR2VuZXJhdG9yPHVua25vd24sIHZvaWQsIHVua25vd24+IHtcbiAgICB0aGlzLnJlaW5pdGlhbGl6ZVN0YXRlKCk7XG4gICAgdGhpcy5zZXRCdWZmZXIoYnVmZmVyKTtcblxuICAgIHdoaWxlICh0aGlzLmhhc1JlbWFpbmluZygxKSkge1xuICAgICAgeWllbGQgdGhpcy5kb0RlY29kZVN5bmMoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZGVjb2RlQXN5bmMoc3RyZWFtOiBBc3luY0l0ZXJhYmxlPEFycmF5TGlrZTxudW1iZXI+IHwgQnVmZmVyU291cmNlPik6IFByb21pc2U8dW5rbm93bj4ge1xuICAgIGxldCBkZWNvZGVkID0gZmFsc2U7XG4gICAgbGV0IG9iamVjdDogdW5rbm93bjtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGJ1ZmZlciBvZiBzdHJlYW0pIHtcbiAgICAgIGlmIChkZWNvZGVkKSB7XG4gICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXh0cmFCeXRlRXJyb3IodGhpcy50b3RhbFBvcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwZW5kQnVmZmVyKGJ1ZmZlcik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuZG9EZWNvZGVTeW5jKCk7XG4gICAgICAgIGRlY29kZWQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgRGF0YVZpZXdJbmRleE91dE9mQm91bmRzRXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZTsgLy8gcmV0aHJvd1xuICAgICAgICB9XG4gICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICB9XG4gICAgICB0aGlzLnRvdGFsUG9zICs9IHRoaXMucG9zO1xuICAgIH1cblxuICAgIGlmIChkZWNvZGVkKSB7XG4gICAgICBpZiAodGhpcy5oYXNSZW1haW5pbmcoMSkpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFeHRyYUJ5dGVFcnJvcih0aGlzLnRvdGFsUG9zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgY29uc3QgeyBoZWFkQnl0ZSwgcG9zLCB0b3RhbFBvcyB9ID0gdGhpcztcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgIGBJbnN1ZmZpY2llbnQgZGF0YSBpbiBwYXJzaW5nICR7cHJldHR5Qnl0ZShoZWFkQnl0ZSl9IGF0ICR7dG90YWxQb3N9ICgke3Bvc30gaW4gdGhlIGN1cnJlbnQgYnVmZmVyKWAsXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBkZWNvZGVBcnJheVN0cmVhbShcbiAgICBzdHJlYW06IEFzeW5jSXRlcmFibGU8QXJyYXlMaWtlPG51bWJlcj4gfCBCdWZmZXJTb3VyY2U+LFxuICApOiBBc3luY0dlbmVyYXRvcjx1bmtub3duLCB2b2lkLCB1bmtub3duPiB7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlTXVsdGlBc3luYyhzdHJlYW0sIHRydWUpO1xuICB9XG5cbiAgcHVibGljIGRlY29kZVN0cmVhbShzdHJlYW06IEFzeW5jSXRlcmFibGU8QXJyYXlMaWtlPG51bWJlcj4gfCBCdWZmZXJTb3VyY2U+KTogQXN5bmNHZW5lcmF0b3I8dW5rbm93biwgdm9pZCwgdW5rbm93bj4ge1xuICAgIHJldHVybiB0aGlzLmRlY29kZU11bHRpQXN5bmMoc3RyZWFtLCBmYWxzZSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jICpkZWNvZGVNdWx0aUFzeW5jKHN0cmVhbTogQXN5bmNJdGVyYWJsZTxBcnJheUxpa2U8bnVtYmVyPiB8IEJ1ZmZlclNvdXJjZT4sIGlzQXJyYXk6IGJvb2xlYW4pIHtcbiAgICBsZXQgaXNBcnJheUhlYWRlclJlcXVpcmVkID0gaXNBcnJheTtcbiAgICBsZXQgYXJyYXlJdGVtc0xlZnQgPSAtMTtcblxuICAgIGZvciBhd2FpdCAoY29uc3QgYnVmZmVyIG9mIHN0cmVhbSkge1xuICAgICAgaWYgKGlzQXJyYXkgJiYgYXJyYXlJdGVtc0xlZnQgPT09IDApIHtcbiAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFeHRyYUJ5dGVFcnJvcih0aGlzLnRvdGFsUG9zKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hcHBlbmRCdWZmZXIoYnVmZmVyKTtcblxuICAgICAgaWYgKGlzQXJyYXlIZWFkZXJSZXF1aXJlZCkge1xuICAgICAgICBhcnJheUl0ZW1zTGVmdCA9IHRoaXMucmVhZEFycmF5U2l6ZSgpO1xuICAgICAgICBpc0FycmF5SGVhZGVyUmVxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHlpZWxkIHRoaXMuZG9EZWNvZGVTeW5jKCk7XG4gICAgICAgICAgaWYgKC0tYXJyYXlJdGVtc0xlZnQgPT09IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgRGF0YVZpZXdJbmRleE91dE9mQm91bmRzRXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZTsgLy8gcmV0aHJvd1xuICAgICAgICB9XG4gICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICB9XG4gICAgICB0aGlzLnRvdGFsUG9zICs9IHRoaXMucG9zO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZG9EZWNvZGVTeW5jKCk6IHVua25vd24ge1xuICAgIERFQ09ERTogd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGhlYWRCeXRlID0gdGhpcy5yZWFkSGVhZEJ5dGUoKTtcbiAgICAgIGxldCBvYmplY3Q6IHVua25vd247XG5cbiAgICAgIGlmIChoZWFkQnl0ZSA+PSAweGUwKSB7XG4gICAgICAgIC8vIG5lZ2F0aXZlIGZpeGludCAoMTExeCB4eHh4KSAweGUwIC0gMHhmZlxuICAgICAgICBvYmplY3QgPSBoZWFkQnl0ZSAtIDB4MTAwO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA8IDB4YzApIHtcbiAgICAgICAgaWYgKGhlYWRCeXRlIDwgMHg4MCkge1xuICAgICAgICAgIC8vIHBvc2l0aXZlIGZpeGludCAoMHh4eCB4eHh4KSAweDAwIC0gMHg3ZlxuICAgICAgICAgIG9iamVjdCA9IGhlYWRCeXRlO1xuICAgICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlIDwgMHg5MCkge1xuICAgICAgICAgIC8vIGZpeG1hcCAoMTAwMCB4eHh4KSAweDgwIC0gMHg4ZlxuICAgICAgICAgIGNvbnN0IHNpemUgPSBoZWFkQnl0ZSAtIDB4ODA7XG4gICAgICAgICAgaWYgKHNpemUgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHVzaE1hcFN0YXRlKHNpemUpO1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgY29udGludWUgREVDT0RFO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmplY3QgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPCAweGEwKSB7XG4gICAgICAgICAgLy8gZml4YXJyYXkgKDEwMDEgeHh4eCkgMHg5MCAtIDB4OWZcbiAgICAgICAgICBjb25zdCBzaXplID0gaGVhZEJ5dGUgLSAweDkwO1xuICAgICAgICAgIGlmIChzaXplICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hBcnJheVN0YXRlKHNpemUpO1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgY29udGludWUgREVDT0RFO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmplY3QgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZml4c3RyICgxMDF4IHh4eHgpIDB4YTAgLSAweGJmXG4gICAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IGhlYWRCeXRlIC0gMHhhMDtcbiAgICAgICAgICBvYmplY3QgPSB0aGlzLmRlY29kZVV0ZjhTdHJpbmcoYnl0ZUxlbmd0aCwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4YzApIHtcbiAgICAgICAgLy8gbmlsXG4gICAgICAgIG9iamVjdCA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGMyKSB7XG4gICAgICAgIC8vIGZhbHNlXG4gICAgICAgIG9iamVjdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhjMykge1xuICAgICAgICAvLyB0cnVlXG4gICAgICAgIG9iamVjdCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGNhKSB7XG4gICAgICAgIC8vIGZsb2F0IDMyXG4gICAgICAgIG9iamVjdCA9IHRoaXMucmVhZEYzMigpO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhjYikge1xuICAgICAgICAvLyBmbG9hdCA2NFxuICAgICAgICBvYmplY3QgPSB0aGlzLnJlYWRGNjQoKTtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4Y2MpIHtcbiAgICAgICAgLy8gdWludCA4XG4gICAgICAgIG9iamVjdCA9IHRoaXMucmVhZFU4KCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGNkKSB7XG4gICAgICAgIC8vIHVpbnQgMTZcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5yZWFkVTE2KCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGNlKSB7XG4gICAgICAgIC8vIHVpbnQgMzJcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5yZWFkVTMyKCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGNmKSB7XG4gICAgICAgIC8vIHVpbnQgNjRcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5yZWFkVTY0KCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGQwKSB7XG4gICAgICAgIC8vIGludCA4XG4gICAgICAgIG9iamVjdCA9IHRoaXMucmVhZEk4KCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGQxKSB7XG4gICAgICAgIC8vIGludCAxNlxuICAgICAgICBvYmplY3QgPSB0aGlzLnJlYWRJMTYoKTtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4ZDIpIHtcbiAgICAgICAgLy8gaW50IDMyXG4gICAgICAgIG9iamVjdCA9IHRoaXMucmVhZEkzMigpO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhkMykge1xuICAgICAgICAvLyBpbnQgNjRcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5yZWFkSTY0KCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGQ5KSB7XG4gICAgICAgIC8vIHN0ciA4XG4gICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSB0aGlzLmxvb2tVOCgpO1xuICAgICAgICBvYmplY3QgPSB0aGlzLmRlY29kZVV0ZjhTdHJpbmcoYnl0ZUxlbmd0aCwgMSk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGRhKSB7XG4gICAgICAgIC8vIHN0ciAxNlxuICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gdGhpcy5sb29rVTE2KCk7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuZGVjb2RlVXRmOFN0cmluZyhieXRlTGVuZ3RoLCAyKTtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4ZGIpIHtcbiAgICAgICAgLy8gc3RyIDMyXG4gICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSB0aGlzLmxvb2tVMzIoKTtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5kZWNvZGVVdGY4U3RyaW5nKGJ5dGVMZW5ndGgsIDQpO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhkYykge1xuICAgICAgICAvLyBhcnJheSAxNlxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5yZWFkVTE2KCk7XG4gICAgICAgIGlmIChzaXplICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy5wdXNoQXJyYXlTdGF0ZShzaXplKTtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgY29udGludWUgREVDT0RFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iamVjdCA9IFtdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGRkKSB7XG4gICAgICAgIC8vIGFycmF5IDMyXG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnJlYWRVMzIoKTtcbiAgICAgICAgaWYgKHNpemUgIT09IDApIHtcbiAgICAgICAgICB0aGlzLnB1c2hBcnJheVN0YXRlKHNpemUpO1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgICAgICBjb250aW51ZSBERUNPREU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqZWN0ID0gW107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4ZGUpIHtcbiAgICAgICAgLy8gbWFwIDE2XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnJlYWRVMTYoKTtcbiAgICAgICAgaWYgKHNpemUgIT09IDApIHtcbiAgICAgICAgICB0aGlzLnB1c2hNYXBTdGF0ZShzaXplKTtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgY29udGludWUgREVDT0RFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iamVjdCA9IHt9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGRmKSB7XG4gICAgICAgIC8vIG1hcCAzMlxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5yZWFkVTMyKCk7XG4gICAgICAgIGlmIChzaXplICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy5wdXNoTWFwU3RhdGUoc2l6ZSk7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgICAgIGNvbnRpbnVlIERFQ09ERTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmplY3QgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhjNCkge1xuICAgICAgICAvLyBiaW4gOFxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5sb29rVTgoKTtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5kZWNvZGVCaW5hcnkoc2l6ZSwgMSk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGM1KSB7XG4gICAgICAgIC8vIGJpbiAxNlxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5sb29rVTE2KCk7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuZGVjb2RlQmluYXJ5KHNpemUsIDIpO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhjNikge1xuICAgICAgICAvLyBiaW4gMzJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMubG9va1UzMigpO1xuICAgICAgICBvYmplY3QgPSB0aGlzLmRlY29kZUJpbmFyeShzaXplLCA0KTtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4ZDQpIHtcbiAgICAgICAgLy8gZml4ZXh0IDFcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5kZWNvZGVFeHRlbnNpb24oMSwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGQ1KSB7XG4gICAgICAgIC8vIGZpeGV4dCAyXG4gICAgICAgIG9iamVjdCA9IHRoaXMuZGVjb2RlRXh0ZW5zaW9uKDIsIDApO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhkNikge1xuICAgICAgICAvLyBmaXhleHQgNFxuICAgICAgICBvYmplY3QgPSB0aGlzLmRlY29kZUV4dGVuc2lvbig0LCAwKTtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4ZDcpIHtcbiAgICAgICAgLy8gZml4ZXh0IDhcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5kZWNvZGVFeHRlbnNpb24oOCwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGQ4KSB7XG4gICAgICAgIC8vIGZpeGV4dCAxNlxuICAgICAgICBvYmplY3QgPSB0aGlzLmRlY29kZUV4dGVuc2lvbigxNiwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGM3KSB7XG4gICAgICAgIC8vIGV4dCA4XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmxvb2tVOCgpO1xuICAgICAgICBvYmplY3QgPSB0aGlzLmRlY29kZUV4dGVuc2lvbihzaXplLCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4YzgpIHtcbiAgICAgICAgLy8gZXh0IDE2XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmxvb2tVMTYoKTtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5kZWNvZGVFeHRlbnNpb24oc2l6ZSwgMik7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGM5KSB7XG4gICAgICAgIC8vIGV4dCAzMlxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5sb29rVTMyKCk7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuZGVjb2RlRXh0ZW5zaW9uKHNpemUsIDQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IERlY29kZUVycm9yKGBVbnJlY29nbml6ZWQgdHlwZSBieXRlOiAke3ByZXR0eUJ5dGUoaGVhZEJ5dGUpfWApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbXBsZXRlKCk7XG5cbiAgICAgIGNvbnN0IHN0YWNrID0gdGhpcy5zdGFjaztcbiAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIGFycmF5cyBhbmQgbWFwc1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdITtcbiAgICAgICAgaWYgKHN0YXRlLnR5cGUgPT09IFN0YXRlLkFSUkFZKSB7XG4gICAgICAgICAgc3RhdGUuYXJyYXlbc3RhdGUucG9zaXRpb25dID0gb2JqZWN0O1xuICAgICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICAgICAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5zaXplKSB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIG9iamVjdCA9IHN0YXRlLmFycmF5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250aW51ZSBERUNPREU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLnR5cGUgPT09IFN0YXRlLk1BUF9LRVkpIHtcbiAgICAgICAgICBpZiAoIWlzVmFsaWRNYXBLZXlUeXBlKG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBEZWNvZGVFcnJvcihcIlRoZSB0eXBlIG9mIGtleSBtdXN0IGJlIHN0cmluZyBvciBudW1iZXIgYnV0IFwiICsgdHlwZW9mIG9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QgPT09IFwiX19wcm90b19fXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBEZWNvZGVFcnJvcihcIlRoZSBrZXkgX19wcm90b19fIGlzIG5vdCBhbGxvd2VkXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0YXRlLmtleSA9IG9iamVjdDtcbiAgICAgICAgICBzdGF0ZS50eXBlID0gU3RhdGUuTUFQX1ZBTFVFO1xuICAgICAgICAgIGNvbnRpbnVlIERFQ09ERTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpdCBtdXN0IGJlIGBzdGF0ZS50eXBlID09PSBTdGF0ZS5NQVBfVkFMVUVgIGhlcmVcblxuICAgICAgICAgIHN0YXRlLm1hcFtzdGF0ZS5rZXkhXSA9IG9iamVjdDtcbiAgICAgICAgICBzdGF0ZS5yZWFkQ291bnQrKztcblxuICAgICAgICAgIGlmIChzdGF0ZS5yZWFkQ291bnQgPT09IHN0YXRlLnNpemUpIHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgb2JqZWN0ID0gc3RhdGUubWFwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5rZXkgPSBudWxsO1xuICAgICAgICAgICAgc3RhdGUudHlwZSA9IFN0YXRlLk1BUF9LRVk7XG4gICAgICAgICAgICBjb250aW51ZSBERUNPREU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZWFkSGVhZEJ5dGUoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5oZWFkQnl0ZSA9PT0gSEVBRF9CWVRFX1JFUVVJUkVEKSB7XG4gICAgICB0aGlzLmhlYWRCeXRlID0gdGhpcy5yZWFkVTgoKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiaGVhZEJ5dGVcIiwgcHJldHR5Qnl0ZSh0aGlzLmhlYWRCeXRlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaGVhZEJ5dGU7XG4gIH1cblxuICBwcml2YXRlIGNvbXBsZXRlKCk6IHZvaWQge1xuICAgIHRoaXMuaGVhZEJ5dGUgPSBIRUFEX0JZVEVfUkVRVUlSRUQ7XG4gIH1cblxuICBwcml2YXRlIHJlYWRBcnJheVNpemUoKTogbnVtYmVyIHtcbiAgICBjb25zdCBoZWFkQnl0ZSA9IHRoaXMucmVhZEhlYWRCeXRlKCk7XG5cbiAgICBzd2l0Y2ggKGhlYWRCeXRlKSB7XG4gICAgICBjYXNlIDB4ZGM6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRVMTYoKTtcbiAgICAgIGNhc2UgMHhkZDpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFUzMigpO1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpZiAoaGVhZEJ5dGUgPCAweGEwKSB7XG4gICAgICAgICAgcmV0dXJuIGhlYWRCeXRlIC0gMHg5MDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRGVjb2RlRXJyb3IoYFVucmVjb2duaXplZCBhcnJheSB0eXBlIGJ5dGU6ICR7cHJldHR5Qnl0ZShoZWFkQnl0ZSl9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHB1c2hNYXBTdGF0ZShzaXplOiBudW1iZXIpIHtcbiAgICBpZiAoc2l6ZSA+IHRoaXMubWF4TWFwTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRGVjb2RlRXJyb3IoYE1heCBsZW5ndGggZXhjZWVkZWQ6IG1hcCBsZW5ndGggKCR7c2l6ZX0pID4gbWF4TWFwTGVuZ3RoTGVuZ3RoICgke3RoaXMubWF4TWFwTGVuZ3RofSlgKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgdHlwZTogU3RhdGUuTUFQX0tFWSxcbiAgICAgIHNpemUsXG4gICAgICBrZXk6IG51bGwsXG4gICAgICByZWFkQ291bnQ6IDAsXG4gICAgICBtYXA6IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBwdXNoQXJyYXlTdGF0ZShzaXplOiBudW1iZXIpIHtcbiAgICBpZiAoc2l6ZSA+IHRoaXMubWF4QXJyYXlMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBEZWNvZGVFcnJvcihgTWF4IGxlbmd0aCBleGNlZWRlZDogYXJyYXkgbGVuZ3RoICgke3NpemV9KSA+IG1heEFycmF5TGVuZ3RoICgke3RoaXMubWF4QXJyYXlMZW5ndGh9KWApO1xuICAgIH1cblxuICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICB0eXBlOiBTdGF0ZS5BUlJBWSxcbiAgICAgIHNpemUsXG4gICAgICBhcnJheTogbmV3IEFycmF5PHVua25vd24+KHNpemUpLFxuICAgICAgcG9zaXRpb246IDAsXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGRlY29kZVV0ZjhTdHJpbmcoYnl0ZUxlbmd0aDogbnVtYmVyLCBoZWFkZXJPZmZzZXQ6IG51bWJlcik6IHN0cmluZyB7XG4gICAgaWYgKGJ5dGVMZW5ndGggPiB0aGlzLm1heFN0ckxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IERlY29kZUVycm9yKFxuICAgICAgICBgTWF4IGxlbmd0aCBleGNlZWRlZDogVVRGLTggYnl0ZSBsZW5ndGggKCR7Ynl0ZUxlbmd0aH0pID4gbWF4U3RyTGVuZ3RoICgke3RoaXMubWF4U3RyTGVuZ3RofSlgLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ieXRlcy5ieXRlTGVuZ3RoIDwgdGhpcy5wb3MgKyBoZWFkZXJPZmZzZXQgKyBieXRlTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBNT1JFX0RBVEE7XG4gICAgfVxuXG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5wb3MgKyBoZWFkZXJPZmZzZXQ7XG4gICAgbGV0IG9iamVjdDogc3RyaW5nO1xuICAgIGlmICh0aGlzLnN0YXRlSXNNYXBLZXkoKSAmJiB0aGlzLmtleURlY29kZXI/LmNhbkJlQ2FjaGVkKGJ5dGVMZW5ndGgpKSB7XG4gICAgICBvYmplY3QgPSB0aGlzLmtleURlY29kZXIuZGVjb2RlKHRoaXMuYnl0ZXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChieXRlTGVuZ3RoID4gVEVYVF9ERUNPREVSX1RIUkVTSE9MRCkge1xuICAgICAgb2JqZWN0ID0gdXRmOERlY29kZVREKHRoaXMuYnl0ZXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdCA9IHV0ZjhEZWNvZGVKcyh0aGlzLmJ5dGVzLCBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICB0aGlzLnBvcyArPSBoZWFkZXJPZmZzZXQgKyBieXRlTGVuZ3RoO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICBwcml2YXRlIHN0YXRlSXNNYXBLZXkoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0hO1xuICAgICAgcmV0dXJuIHN0YXRlLnR5cGUgPT09IFN0YXRlLk1BUF9LRVk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgZGVjb2RlQmluYXJ5KGJ5dGVMZW5ndGg6IG51bWJlciwgaGVhZE9mZnNldDogbnVtYmVyKTogVWludDhBcnJheSB7XG4gICAgaWYgKGJ5dGVMZW5ndGggPiB0aGlzLm1heEJpbkxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IERlY29kZUVycm9yKGBNYXggbGVuZ3RoIGV4Y2VlZGVkOiBiaW4gbGVuZ3RoICgke2J5dGVMZW5ndGh9KSA+IG1heEJpbkxlbmd0aCAoJHt0aGlzLm1heEJpbkxlbmd0aH0pYCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmhhc1JlbWFpbmluZyhieXRlTGVuZ3RoICsgaGVhZE9mZnNldCkpIHtcbiAgICAgIHRocm93IE1PUkVfREFUQTtcbiAgICB9XG5cbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLnBvcyArIGhlYWRPZmZzZXQ7XG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy5ieXRlcy5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGJ5dGVMZW5ndGgpO1xuICAgIHRoaXMucG9zICs9IGhlYWRPZmZzZXQgKyBieXRlTGVuZ3RoO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICBwcml2YXRlIGRlY29kZUV4dGVuc2lvbihzaXplOiBudW1iZXIsIGhlYWRPZmZzZXQ6IG51bWJlcik6IHVua25vd24ge1xuICAgIGlmIChzaXplID4gdGhpcy5tYXhFeHRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBEZWNvZGVFcnJvcihgTWF4IGxlbmd0aCBleGNlZWRlZDogZXh0IGxlbmd0aCAoJHtzaXplfSkgPiBtYXhFeHRMZW5ndGggKCR7dGhpcy5tYXhFeHRMZW5ndGh9KWApO1xuICAgIH1cblxuICAgIGNvbnN0IGV4dFR5cGUgPSB0aGlzLnZpZXcuZ2V0SW50OCh0aGlzLnBvcyArIGhlYWRPZmZzZXQpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRlY29kZUJpbmFyeShzaXplLCBoZWFkT2Zmc2V0ICsgMSAvKiBleHRUeXBlICovKTtcbiAgICByZXR1cm4gdGhpcy5leHRlbnNpb25Db2RlYy5kZWNvZGUoZGF0YSwgZXh0VHlwZSwgdGhpcy5jb250ZXh0KTtcbiAgfVxuXG4gIHByaXZhdGUgbG9va1U4KCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3MpO1xuICB9XG5cbiAgcHJpdmF0ZSBsb29rVTE2KCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMucG9zKTtcbiAgfVxuXG4gIHByaXZhdGUgbG9va1UzMigpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLnBvcyk7XG4gIH1cblxuICBwcml2YXRlIHJlYWRVOCgpOiBudW1iZXIge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcysrO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZEk4KCk6IG51bWJlciB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50OCh0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MrKztcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBwcml2YXRlIHJlYWRVMTYoKTogbnVtYmVyIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDI7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkSTE2KCk6IG51bWJlciB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50MTYodGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDI7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkVTMyKCk6IG51bWJlciB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZEkzMigpOiBudW1iZXIge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy52aWV3LmdldEludDMyKHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZFU2NCgpOiBudW1iZXIge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludDY0KHRoaXMudmlldywgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDg7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkSTY0KCk6IG51bWJlciB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRJbnQ2NCh0aGlzLnZpZXcsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZEYzMigpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmlldy5nZXRGbG9hdDMyKHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZEY2NCgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmlldy5nZXRGbG9hdDY0KHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuIiwgImltcG9ydCB7IERlY29kZXIgfSBmcm9tIFwiLi9EZWNvZGVyXCI7XG5pbXBvcnQgdHlwZSB7IEV4dGVuc2lvbkNvZGVjVHlwZSB9IGZyb20gXCIuL0V4dGVuc2lvbkNvZGVjXCI7XG5pbXBvcnQgdHlwZSB7IENvbnRleHRPZiwgU3BsaXRVbmRlZmluZWQgfSBmcm9tIFwiLi9jb250ZXh0XCI7XG5cbmV4cG9ydCB0eXBlIERlY29kZU9wdGlvbnM8Q29udGV4dFR5cGUgPSB1bmRlZmluZWQ+ID0gUmVhZG9ubHk8XG4gIFBhcnRpYWw8e1xuICAgIGV4dGVuc2lvbkNvZGVjOiBFeHRlbnNpb25Db2RlY1R5cGU8Q29udGV4dFR5cGU+O1xuXG4gICAgLyoqXG4gICAgICogTWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqXG4gICAgICogRGVmYXVsdHMgdG8gNF8yOTRfOTY3XzI5NSAoVUlOVDMyX01BWCkuXG4gICAgICovXG4gICAgbWF4U3RyTGVuZ3RoOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogTWF4aW11bSBiaW5hcnkgbGVuZ3RoLlxuICAgICAqXG4gICAgICogRGVmYXVsdHMgdG8gNF8yOTRfOTY3XzI5NSAoVUlOVDMyX01BWCkuXG4gICAgICovXG4gICAgbWF4QmluTGVuZ3RoOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogTWF4aW11bSBhcnJheSBsZW5ndGguXG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0byA0XzI5NF85NjdfMjk1IChVSU5UMzJfTUFYKS5cbiAgICAgKi9cbiAgICBtYXhBcnJheUxlbmd0aDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIE1heGltdW0gbWFwIGxlbmd0aC5cbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRvIDRfMjk0Xzk2N18yOTUgKFVJTlQzMl9NQVgpLlxuICAgICAqL1xuICAgIG1heE1hcExlbmd0aDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIE1heGltdW0gZXh0ZW5zaW9uIGxlbmd0aC5cbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRvIDRfMjk0Xzk2N18yOTUgKFVJTlQzMl9NQVgpLlxuICAgICAqL1xuICAgIG1heEV4dExlbmd0aDogbnVtYmVyO1xuICB9PlxuPiAmXG4gIENvbnRleHRPZjxDb250ZXh0VHlwZT47XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0RGVjb2RlT3B0aW9uczogRGVjb2RlT3B0aW9ucyA9IHt9O1xuXG4vKipcbiAqIEl0IGRlY29kZXMgYSBzaW5nbGUgTWVzc2FnZVBhY2sgb2JqZWN0IGluIGEgYnVmZmVyLlxuICpcbiAqIFRoaXMgaXMgYSBzeW5jaHJvbm91cyBkZWNvZGluZyBmdW5jdGlvbi5cbiAqIFNlZSBvdGhlciB2YXJpYW50cyBmb3IgYXN5bmNocm9ub3VzIGRlY29kaW5nOiB7QGxpbmsgZGVjb2RlQXN5bmMoKX0sIHtAbGluayBkZWNvZGVTdHJlYW0oKX0sIG9yIHtAbGluayBkZWNvZGVBcnJheVN0cmVhbSgpfS5cbiAqXG4gKiBAdGhyb3dzIHtAbGluayBSYW5nZUVycm9yfSBpZiB0aGUgYnVmZmVyIGlzIGluY29tcGxldGUsIGluY2x1ZGluZyB0aGUgY2FzZSB3aGVyZSB0aGUgYnVmZmVyIGlzIGVtcHR5LlxuICogQHRocm93cyB7QGxpbmsgRGVjb2RlRXJyb3J9IGlmIHRoZSBidWZmZXIgY29udGFpbnMgaW52YWxpZCBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlPENvbnRleHRUeXBlID0gdW5kZWZpbmVkPihcbiAgYnVmZmVyOiBBcnJheUxpa2U8bnVtYmVyPiB8IEJ1ZmZlclNvdXJjZSxcbiAgb3B0aW9uczogRGVjb2RlT3B0aW9uczxTcGxpdFVuZGVmaW5lZDxDb250ZXh0VHlwZT4+ID0gZGVmYXVsdERlY29kZU9wdGlvbnMgYXMgYW55LFxuKTogdW5rbm93biB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgRGVjb2RlcihcbiAgICBvcHRpb25zLmV4dGVuc2lvbkNvZGVjLFxuICAgIChvcHRpb25zIGFzIHR5cGVvZiBvcHRpb25zICYgeyBjb250ZXh0OiBhbnkgfSkuY29udGV4dCxcbiAgICBvcHRpb25zLm1heFN0ckxlbmd0aCxcbiAgICBvcHRpb25zLm1heEJpbkxlbmd0aCxcbiAgICBvcHRpb25zLm1heEFycmF5TGVuZ3RoLFxuICAgIG9wdGlvbnMubWF4TWFwTGVuZ3RoLFxuICAgIG9wdGlvbnMubWF4RXh0TGVuZ3RoLFxuICApO1xuICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoYnVmZmVyKTtcbn1cblxuLyoqXG4gKiBJdCBkZWNvZGVzIG11bHRpcGxlIE1lc3NhZ2VQYWNrIG9iamVjdHMgaW4gYSBidWZmZXIuXG4gKiBUaGlzIGlzIGNvcnJlc3BvbmRpbmcgdG8ge0BsaW5rIGRlY29kZU11bHRpU3RyZWFtKCl9LlxuICpcbiAqIEB0aHJvd3Mge0BsaW5rIFJhbmdlRXJyb3J9IGlmIHRoZSBidWZmZXIgaXMgaW5jb21wbGV0ZSwgaW5jbHVkaW5nIHRoZSBjYXNlIHdoZXJlIHRoZSBidWZmZXIgaXMgZW1wdHkuXG4gKiBAdGhyb3dzIHtAbGluayBEZWNvZGVFcnJvcn0gaWYgdGhlIGJ1ZmZlciBjb250YWlucyBpbnZhbGlkIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVNdWx0aTxDb250ZXh0VHlwZSA9IHVuZGVmaW5lZD4oXG4gIGJ1ZmZlcjogQXJyYXlMaWtlPG51bWJlcj4gfCBCdWZmZXJTb3VyY2UsXG4gIG9wdGlvbnM6IERlY29kZU9wdGlvbnM8U3BsaXRVbmRlZmluZWQ8Q29udGV4dFR5cGU+PiA9IGRlZmF1bHREZWNvZGVPcHRpb25zIGFzIGFueSxcbik6IEdlbmVyYXRvcjx1bmtub3duLCB2b2lkLCB1bmtub3duPiB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgRGVjb2RlcihcbiAgICBvcHRpb25zLmV4dGVuc2lvbkNvZGVjLFxuICAgIChvcHRpb25zIGFzIHR5cGVvZiBvcHRpb25zICYgeyBjb250ZXh0OiBhbnkgfSkuY29udGV4dCxcbiAgICBvcHRpb25zLm1heFN0ckxlbmd0aCxcbiAgICBvcHRpb25zLm1heEJpbkxlbmd0aCxcbiAgICBvcHRpb25zLm1heEFycmF5TGVuZ3RoLFxuICAgIG9wdGlvbnMubWF4TWFwTGVuZ3RoLFxuICAgIG9wdGlvbnMubWF4RXh0TGVuZ3RoLFxuICApO1xuICByZXR1cm4gZGVjb2Rlci5kZWNvZGVNdWx0aShidWZmZXIpO1xufVxuIiwgIi8vIHV0aWxpdHkgZm9yIHdoYXR3ZyBzdHJlYW1zXG5cbi8vIFRoZSBsaXZpbmcgc3RhbmRhcmQgb2Ygd2hhdHdnIHN0cmVhbXMgc2F5c1xuLy8gUmVhZGFibGVTdHJlYW0gaXMgYWxzbyBBc3luY0l0ZXJhYmxlLCBidXRcbi8vIGFzIG9mIEp1bmUgMjAxOSwgbm8gYnJvd3NlciBpbXBsZW1lbnRzIGl0LlxuLy8gU2VlIGh0dHBzOi8vc3RyZWFtcy5zcGVjLndoYXR3Zy5vcmcvIGZvciBkZXRhaWxzXG5leHBvcnQgdHlwZSBSZWFkYWJsZVN0cmVhbUxpa2U8VD4gPSBBc3luY0l0ZXJhYmxlPFQ+IHwgUmVhZGFibGVTdHJlYW08VD47XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0FzeW5jSXRlcmFibGU8VD4ob2JqZWN0OiBSZWFkYWJsZVN0cmVhbUxpa2U8VD4pOiBvYmplY3QgaXMgQXN5bmNJdGVyYWJsZTxUPiB7XG4gIHJldHVybiAob2JqZWN0IGFzIGFueSlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE5vbk51bGw8VD4odmFsdWU6IFQgfCBudWxsIHwgdW5kZWZpbmVkKTogYXNzZXJ0cyB2YWx1ZSBpcyBUIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnRpb24gRmFpbHVyZTogdmFsdWUgbXVzdCBub3QgYmUgbnVsbCBub3IgdW5kZWZpbmVkXCIpO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiogYXN5bmNJdGVyYWJsZUZyb21TdHJlYW08VD4oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxUPik6IEFzeW5jSXRlcmFibGU8VD4ge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG5cbiAgdHJ5IHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFzc2VydE5vbk51bGwodmFsdWUpO1xuICAgICAgeWllbGQgdmFsdWU7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVBc3luY0l0ZXJhYmxlPFQ+KHN0cmVhbUxpa2U6IFJlYWRhYmxlU3RyZWFtTGlrZTxUPik6IEFzeW5jSXRlcmFibGU8VD4ge1xuICBpZiAoaXNBc3luY0l0ZXJhYmxlKHN0cmVhbUxpa2UpKSB7XG4gICAgcmV0dXJuIHN0cmVhbUxpa2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFzeW5jSXRlcmFibGVGcm9tU3RyZWFtKHN0cmVhbUxpa2UpO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgRGVjb2RlciB9IGZyb20gXCIuL0RlY29kZXJcIjtcbmltcG9ydCB7IGVuc3VyZUFzeW5jSXRlcmFibGUgfSBmcm9tIFwiLi91dGlscy9zdHJlYW1cIjtcbmltcG9ydCB7IGRlZmF1bHREZWNvZGVPcHRpb25zIH0gZnJvbSBcIi4vZGVjb2RlXCI7XG5pbXBvcnQgdHlwZSB7IFJlYWRhYmxlU3RyZWFtTGlrZSB9IGZyb20gXCIuL3V0aWxzL3N0cmVhbVwiO1xuaW1wb3J0IHR5cGUgeyBEZWNvZGVPcHRpb25zIH0gZnJvbSBcIi4vZGVjb2RlXCI7XG5pbXBvcnQgdHlwZSB7IFNwbGl0VW5kZWZpbmVkIH0gZnJvbSBcIi4vY29udGV4dFwiO1xuXG4vKipcbiAqIEB0aHJvd3Mge0BsaW5rIFJhbmdlRXJyb3J9IGlmIHRoZSBidWZmZXIgaXMgaW5jb21wbGV0ZSwgaW5jbHVkaW5nIHRoZSBjYXNlIHdoZXJlIHRoZSBidWZmZXIgaXMgZW1wdHkuXG4gKiBAdGhyb3dzIHtAbGluayBEZWNvZGVFcnJvcn0gaWYgdGhlIGJ1ZmZlciBjb250YWlucyBpbnZhbGlkIGRhdGEuXG4gKi9cbiBleHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVjb2RlQXN5bmM8Q29udGV4dFR5cGU+KFxuICBzdHJlYW1MaWtlOiBSZWFkYWJsZVN0cmVhbUxpa2U8QXJyYXlMaWtlPG51bWJlcj4gfCBCdWZmZXJTb3VyY2U+LFxuICBvcHRpb25zOiBEZWNvZGVPcHRpb25zPFNwbGl0VW5kZWZpbmVkPENvbnRleHRUeXBlPj4gPSBkZWZhdWx0RGVjb2RlT3B0aW9ucyBhcyBhbnksXG4pOiBQcm9taXNlPHVua25vd24+IHtcbiAgY29uc3Qgc3RyZWFtID0gZW5zdXJlQXN5bmNJdGVyYWJsZShzdHJlYW1MaWtlKTtcblxuICBjb25zdCBkZWNvZGVyID0gbmV3IERlY29kZXIoXG4gICAgb3B0aW9ucy5leHRlbnNpb25Db2RlYyxcbiAgICAob3B0aW9ucyBhcyB0eXBlb2Ygb3B0aW9ucyAmIHsgY29udGV4dDogYW55IH0pLmNvbnRleHQsXG4gICAgb3B0aW9ucy5tYXhTdHJMZW5ndGgsXG4gICAgb3B0aW9ucy5tYXhCaW5MZW5ndGgsXG4gICAgb3B0aW9ucy5tYXhBcnJheUxlbmd0aCxcbiAgICBvcHRpb25zLm1heE1hcExlbmd0aCxcbiAgICBvcHRpb25zLm1heEV4dExlbmd0aCxcbiAgKTtcbiAgcmV0dXJuIGRlY29kZXIuZGVjb2RlQXN5bmMoc3RyZWFtKTtcbn1cblxuLyoqXG4gKiBAdGhyb3dzIHtAbGluayBSYW5nZUVycm9yfSBpZiB0aGUgYnVmZmVyIGlzIGluY29tcGxldGUsIGluY2x1ZGluZyB0aGUgY2FzZSB3aGVyZSB0aGUgYnVmZmVyIGlzIGVtcHR5LlxuICogQHRocm93cyB7QGxpbmsgRGVjb2RlRXJyb3J9IGlmIHRoZSBidWZmZXIgY29udGFpbnMgaW52YWxpZCBkYXRhLlxuICovXG4gZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUFycmF5U3RyZWFtPENvbnRleHRUeXBlPihcbiAgc3RyZWFtTGlrZTogUmVhZGFibGVTdHJlYW1MaWtlPEFycmF5TGlrZTxudW1iZXI+IHwgQnVmZmVyU291cmNlPixcbiAgb3B0aW9uczogRGVjb2RlT3B0aW9uczxTcGxpdFVuZGVmaW5lZDxDb250ZXh0VHlwZT4+ID0gZGVmYXVsdERlY29kZU9wdGlvbnMgYXMgYW55LFxuKTogQXN5bmNHZW5lcmF0b3I8dW5rbm93biwgdm9pZCwgdW5rbm93bj4ge1xuICBjb25zdCBzdHJlYW0gPSBlbnN1cmVBc3luY0l0ZXJhYmxlKHN0cmVhbUxpa2UpO1xuXG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgRGVjb2RlcihcbiAgICBvcHRpb25zLmV4dGVuc2lvbkNvZGVjLFxuICAgIChvcHRpb25zIGFzIHR5cGVvZiBvcHRpb25zICYgeyBjb250ZXh0OiBhbnkgfSkuY29udGV4dCxcbiAgICBvcHRpb25zLm1heFN0ckxlbmd0aCxcbiAgICBvcHRpb25zLm1heEJpbkxlbmd0aCxcbiAgICBvcHRpb25zLm1heEFycmF5TGVuZ3RoLFxuICAgIG9wdGlvbnMubWF4TWFwTGVuZ3RoLFxuICAgIG9wdGlvbnMubWF4RXh0TGVuZ3RoLFxuICApO1xuXG4gIHJldHVybiBkZWNvZGVyLmRlY29kZUFycmF5U3RyZWFtKHN0cmVhbSk7XG59XG5cbi8qKlxuICogQHRocm93cyB7QGxpbmsgUmFuZ2VFcnJvcn0gaWYgdGhlIGJ1ZmZlciBpcyBpbmNvbXBsZXRlLCBpbmNsdWRpbmcgdGhlIGNhc2Ugd2hlcmUgdGhlIGJ1ZmZlciBpcyBlbXB0eS5cbiAqIEB0aHJvd3Mge0BsaW5rIERlY29kZUVycm9yfSBpZiB0aGUgYnVmZmVyIGNvbnRhaW5zIGludmFsaWQgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU11bHRpU3RyZWFtPENvbnRleHRUeXBlPihcbiAgc3RyZWFtTGlrZTogUmVhZGFibGVTdHJlYW1MaWtlPEFycmF5TGlrZTxudW1iZXI+IHwgQnVmZmVyU291cmNlPixcbiAgb3B0aW9uczogRGVjb2RlT3B0aW9uczxTcGxpdFVuZGVmaW5lZDxDb250ZXh0VHlwZT4+ID0gZGVmYXVsdERlY29kZU9wdGlvbnMgYXMgYW55LFxuKTogQXN5bmNHZW5lcmF0b3I8dW5rbm93biwgdm9pZCwgdW5rbm93bj4ge1xuICBjb25zdCBzdHJlYW0gPSBlbnN1cmVBc3luY0l0ZXJhYmxlKHN0cmVhbUxpa2UpO1xuXG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgRGVjb2RlcihcbiAgICBvcHRpb25zLmV4dGVuc2lvbkNvZGVjLFxuICAgIChvcHRpb25zIGFzIHR5cGVvZiBvcHRpb25zICYgeyBjb250ZXh0OiBhbnkgfSkuY29udGV4dCxcbiAgICBvcHRpb25zLm1heFN0ckxlbmd0aCxcbiAgICBvcHRpb25zLm1heEJpbkxlbmd0aCxcbiAgICBvcHRpb25zLm1heEFycmF5TGVuZ3RoLFxuICAgIG9wdGlvbnMubWF4TWFwTGVuZ3RoLFxuICAgIG9wdGlvbnMubWF4RXh0TGVuZ3RoLFxuICApO1xuXG4gIHJldHVybiBkZWNvZGVyLmRlY29kZVN0cmVhbShzdHJlYW0pO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgZGVjb2RlTXVsdGlTdHJlYW0oKX0gaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVN0cmVhbTxDb250ZXh0VHlwZT4oXG4gIHN0cmVhbUxpa2U6IFJlYWRhYmxlU3RyZWFtTGlrZTxBcnJheUxpa2U8bnVtYmVyPiB8IEJ1ZmZlclNvdXJjZT4sXG4gIG9wdGlvbnM6IERlY29kZU9wdGlvbnM8U3BsaXRVbmRlZmluZWQ8Q29udGV4dFR5cGU+PiA9IGRlZmF1bHREZWNvZGVPcHRpb25zIGFzIGFueSxcbik6IEFzeW5jR2VuZXJhdG9yPHVua25vd24sIHZvaWQsIHVua25vd24+IHtcbiAgcmV0dXJuIGRlY29kZU11bHRpU3RyZWFtKHN0cmVhbUxpa2UsIG9wdGlvbnMpO1xufVxuIiwgIi8vIE1haW4gRnVuY3Rpb25zOlxuXG5pbXBvcnQgeyBlbmNvZGUgfSBmcm9tIFwiLi9lbmNvZGVcIjtcbmV4cG9ydCB7IGVuY29kZSB9O1xuaW1wb3J0IHR5cGUgeyBFbmNvZGVPcHRpb25zIH0gZnJvbSBcIi4vZW5jb2RlXCI7XG5leHBvcnQgdHlwZSB7IEVuY29kZU9wdGlvbnMgfTtcblxuaW1wb3J0IHsgZGVjb2RlLCBkZWNvZGVNdWx0aSB9IGZyb20gXCIuL2RlY29kZVwiO1xuZXhwb3J0IHsgZGVjb2RlLCBkZWNvZGVNdWx0aSB9O1xuaW1wb3J0IHR5cGUgeyBEZWNvZGVPcHRpb25zIH0gZnJvbSBcIi4vZGVjb2RlXCI7XG5leHBvcnQgeyBEZWNvZGVPcHRpb25zIH07XG5cbmltcG9ydCB7IGRlY29kZUFzeW5jLCBkZWNvZGVBcnJheVN0cmVhbSwgZGVjb2RlTXVsdGlTdHJlYW0sIGRlY29kZVN0cmVhbSB9IGZyb20gXCIuL2RlY29kZUFzeW5jXCI7XG5leHBvcnQgeyBkZWNvZGVBc3luYywgZGVjb2RlQXJyYXlTdHJlYW0sIGRlY29kZU11bHRpU3RyZWFtLCBkZWNvZGVTdHJlYW0gfTtcblxuaW1wb3J0IHsgRGVjb2RlciwgRGF0YVZpZXdJbmRleE91dE9mQm91bmRzRXJyb3IgfSBmcm9tIFwiLi9EZWNvZGVyXCI7XG5pbXBvcnQgeyBEZWNvZGVFcnJvciB9IGZyb20gXCIuL0RlY29kZUVycm9yXCI7XG5leHBvcnQgeyBEZWNvZGVyLCBEZWNvZGVFcnJvciwgRGF0YVZpZXdJbmRleE91dE9mQm91bmRzRXJyb3IgfTtcblxuaW1wb3J0IHsgRW5jb2RlciB9IGZyb20gXCIuL0VuY29kZXJcIjtcbmV4cG9ydCB7IEVuY29kZXIgfTtcblxuLy8gVXRpbGl0aWllcyBmb3IgRXh0ZW5zaW9uIFR5cGVzOlxuXG5pbXBvcnQgeyBFeHRlbnNpb25Db2RlYyB9IGZyb20gXCIuL0V4dGVuc2lvbkNvZGVjXCI7XG5leHBvcnQgeyBFeHRlbnNpb25Db2RlYyB9O1xuaW1wb3J0IHR5cGUgeyBFeHRlbnNpb25Db2RlY1R5cGUsIEV4dGVuc2lvbkRlY29kZXJUeXBlLCBFeHRlbnNpb25FbmNvZGVyVHlwZSB9IGZyb20gXCIuL0V4dGVuc2lvbkNvZGVjXCI7XG5leHBvcnQgdHlwZSB7IEV4dGVuc2lvbkNvZGVjVHlwZSwgRXh0ZW5zaW9uRGVjb2RlclR5cGUsIEV4dGVuc2lvbkVuY29kZXJUeXBlIH07XG5pbXBvcnQgeyBFeHREYXRhIH0gZnJvbSBcIi4vRXh0RGF0YVwiO1xuZXhwb3J0IHsgRXh0RGF0YSB9O1xuXG5pbXBvcnQge1xuICBFWFRfVElNRVNUQU1QLFxuICBlbmNvZGVEYXRlVG9UaW1lU3BlYyxcbiAgZW5jb2RlVGltZVNwZWNUb1RpbWVzdGFtcCxcbiAgZGVjb2RlVGltZXN0YW1wVG9UaW1lU3BlYyxcbiAgZW5jb2RlVGltZXN0YW1wRXh0ZW5zaW9uLFxuICBkZWNvZGVUaW1lc3RhbXBFeHRlbnNpb24sXG59IGZyb20gXCIuL3RpbWVzdGFtcFwiO1xuZXhwb3J0IHtcbiAgRVhUX1RJTUVTVEFNUCxcbiAgZW5jb2RlRGF0ZVRvVGltZVNwZWMsXG4gIGVuY29kZVRpbWVTcGVjVG9UaW1lc3RhbXAsXG4gIGRlY29kZVRpbWVzdGFtcFRvVGltZVNwZWMsXG4gIGVuY29kZVRpbWVzdGFtcEV4dGVuc2lvbixcbiAgZGVjb2RlVGltZXN0YW1wRXh0ZW5zaW9uLFxufTtcbiIsIG51bGwsICJpbXBvcnQgeyBOb3RpY2UsIFBsdWdpbiwgbm9ybWFsaXplUGF0aCwgRGF0YUFkYXB0ZXIsV29ya3NwYWNlTGVhZiB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IHV1aGltc3lTZXR0aW5nc1RhYiB9IGZyb20gJ3NldHRpbmdzJztcbmltcG9ydCB7IFVVaGltc3lFbnRyYW5jZVN1Z2dlc3QsIFVVaGltc3lFeGl0U3VnZ2VzdCB9IGZyb20gJ3N1Z2dlc3QnO1xuaW1wb3J0IHsgVVVISU1TWV9WSUVXX1RZUEUsIFVVaGltc3lWaWV3IH0gZnJvbSAndmlldyc7XG5cbi8vaW5jbHVkZSBzeXN0ZW0gY29tbWFuZCBcbmNvbnN0IHsgZXhlY1N5bmMgfSA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKTtcblxuLy8gcGF0aFRvUGx1Z2luIGNvbnRhaW5zIFwibXktZm9sZGVyL2ZpbGVcIiBub3QgXCIvL215LWZvbGRlclxcXCJcblxuY29uc3QgeyBDbGllbnQsIFNlcnZlciwgTWVzc2FnZSB9ID0gcmVxdWlyZShcIm5vZGUtb3NjXCIpXG5jb25zdCBPQlNXZWJTb2NrZXQgPSByZXF1aXJlKFwib2JzLXdlYnNvY2tldC1qc1wiKS5kZWZhdWx0O1xuXG5pbnRlcmZhY2UgdXVoaW1zeVBsdWdpblNldHRpbmdze1xuXHR3ZWJzb2NrZXRJUF9UZXh0OiBzdHJpbmc7XG5cdHdlYnNvY2tldFBvcnRfVGV4dDogc3RyaW5nO1xuXHR3ZWJzb2NrZXRQV19UZXh0OiBzdHJpbmc7XG5cdG9ic0FwcE5hbWVfVGV4dDogc3RyaW5nO1xuXHRvYnNBcHBQYXRoX1RleHQ6IHN0cmluZztcblx0b2JzQ29sbGVjdGlvbl9UZXh0OiBzdHJpbmc7XG5cdG9ic0RlYnVnX1RleHQ6IHN0cmluZztcblx0b2JzRGVidWdQb3J0X1RleHQ6IHN0cmluZztcblx0b3NjSVBfVGV4dDogc3RyaW5nO1xuXHRvc2NJblBvcnRfVGV4dDogc3RyaW5nO1xuXHRvc2NPdXRQb3J0X1RleHQ6IHN0cmluZztcbn1cblxuY29uc3QgREVGQVVMVF9TRVRUSU5HUzogUGFydGlhbDx1dWhpbXN5UGx1Z2luU2V0dGluZ3M+ID0ge1xuXHR3ZWJzb2NrZXRJUF9UZXh0OiBcImxvY2FsaG9zdFwiLFxuXHR3ZWJzb2NrZXRQb3J0X1RleHQ6IFwiNDQ1NVwiLFxuXHR3ZWJzb2NrZXRQV19UZXh0OiBcInBhc3N3b3JkXCIsXG5cdG9zY0lQX1RleHQ6IFwibG9jYWxob3N0XCIsXG5cdG9zY0luUG9ydF9UZXh0OiBcIjQ0NjZcIixcblx0b3NjT3V0UG9ydF9UZXh0OiBcIjQ0NzdcIixcblx0b2JzQXBwTmFtZV9UZXh0OiBcIk9CU1wiLFxuXHRvYnNBcHBQYXRoX1RleHQ6IFwiQzpcXFxcXFxcXFByb2dyYW0gRmlsZXNcXFxcXFxcXG9icy1zdHVkaW9cXFxcXFxcXGJpblxcXFxcXFxcNjRiaXRcXFxcXFxcXFwiLFxuXHRvYnNDb2xsZWN0aW9uX1RleHQ6IFwiS2V5X2FuZF9Nb3VzZV9WaXN1YWxzX0NvbGxlY3Rpb25cIiwgIFxuXHRvYnNEZWJ1Z19UZXh0OiBcIllcIixcblx0b2JzRGVidWdQb3J0X1RleHQ6IFwiOTIyMlwiXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB1dWhpbXN5UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcblx0c2V0dGluZ3M6IHV1aGltc3lQbHVnaW5TZXR0aW5ncztcblx0XG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpe1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKFxuXHRcdFx0e30sIFxuXHRcdFx0REVGQVVMVF9TRVRUSU5HUyxcblx0XHRcdGF3YWl0IHRoaXMubG9hZERhdGEoKVxuXHRcdCk7XG5cdH1cblx0XG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpe1xuXHRcdHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG5cdH1cblxuXG5cdFx0XG5cdGFzeW5jIG9ubG9hZCgpIHtcblxuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cdFx0XG5cdFx0dGhpcy5yZWdpc3RlclZpZXcoVVVISU1TWV9WSUVXX1RZUEUsIChsZWFmKSA9PiBuZXcgVVVoaW1zeVZpZXcobGVhZikpXG5cdFx0XG5cblx0XHR0aGlzLmFkZFJpYmJvbkljb24oXCJ3YW5kLXNwYXJrbGVzXCIsIFwiVVVoaW1zeSB0YWdzXCIsICgpID0+IHtcblx0XHRcdHRoaXMub3BlblZpZXcoKTtcblx0XHR9KVxuXHRcdHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgdXVoaW1zeVNldHRpbmdzVGFiKHRoaXMuYXBwLCB0aGlzKSlcblx0XHRcblx0XHRuZXcgTm90aWNlKFwiRW5hYmxlZCBPU0MgcGx1Z2luXCIpXHRcblx0XHRuZXcgTm90aWNlKHRoaXMuc2V0dGluZ3Mud2Vic29ja2V0SVBfVGV4dClcdFxuXHRcdG5ldyBOb3RpY2UodGhpcy5hcHAudmF1bHQuY29uZmlnRGlyKVxuXHRcdFx0IFxuLy9cbi8vXG4vL1x0XHQgXG4vL1x0I3JlZ2lvbiBPU0MgU2VydmVyIGNvbm5lY3Rpb24gZmVhdHVyZVxuLy9cbi8vIFxuLy9cdFx0XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiAnc3RhcnQtb3NjLXRvLXdlYnNvY2tldCcsXG5cdFx0XHRuYW1lOiAnU3RhcnQgT1NDIHRvIE9CUyBXZWJzb2NrZXQgY29ubmVjdGlvbicsXG5cdFx0XHRjYWxsYmFjazooKSA9PiB7XG5cdFx0XHQvL3RoaXMuYWRkUmliYm9uSWNvbihcImFjdGl2aXR5XCIsXCJzdGFydCBPU0MgdG8gV2Vic29ja2V0XCIsICgpID0+e1xuXHRcdFx0bmV3IE5vdGljZShcIlN0YXJ0aW5nIE9TQyBTZXJ2ZXJcIilcblx0XHRcdGxldCB3ZWJzb2NrZXRJUCA9IHRoaXMuc2V0dGluZ3Mud2Vic29ja2V0SVBfVGV4dDtcblx0XHRcdGxldCB3ZWJzb2NrZXRQb3J0ID0gdGhpcy5zZXR0aW5ncy53ZWJzb2NrZXRQb3J0X1RleHQ7XG5cdFx0XHRsZXQgd2Vic29ja2V0UGFzc3dvcmQgPSB0aGlzLnNldHRpbmdzLndlYnNvY2tldFBXX1RleHQ7XG5cdFx0XHRsZXQgb3NjSVAgPSB0aGlzLnNldHRpbmdzLm9zY0lQX1RleHQ7XG5cdFx0XHRsZXQgb3NjSW5QT1JUID0gdGhpcy5zZXR0aW5ncy5vc2NJblBvcnRfVGV4dDtcblx0XHRcdGxldCBvc2NPdXRQT1JUID0gdGhpcy5zZXR0aW5ncy5vc2NPdXRQb3J0X1RleHQ7XG5cdFx0XHRcblx0XHRcdHNldE9TQ2Nvbm5lY3Rpb24oXG5cdFx0XHRcdHdlYnNvY2tldElQLFxuXHRcdFx0XHR3ZWJzb2NrZXRQb3J0LFxuXHRcdFx0XHR3ZWJzb2NrZXRQYXNzd29yZCxcblx0XHRcdFx0b3NjSVAsXG5cdFx0XHRcdG9zY0luUE9SVCxcblx0XHRcdFx0b3NjT3V0UE9SVFxuXHRcdFx0KTtcblx0XHRcdFxuXHRcdFx0YXN5bmMgZnVuY3Rpb24gc2V0T1NDY29ubmVjdGlvbihcblx0XHRcdFx0d2Vic29ja2V0SVAsXG5cdFx0XHRcdHdlYnNvY2tldFBvcnQsXG5cdFx0XHRcdHdlYnNvY2tldFBhc3N3b3JkLFxuXHRcdFx0XHRvc2NJUCxcblx0XHRcdFx0b3NjSW5QT1JULFxuXHRcdFx0XHRvc2NPdXRQT1JUXG5cdFx0XHQpIHtcblx0XHRcdFx0XG5cdFx0XHRcdC8qXG5cdFx0XHRcdCpDb25uZWN0IHRoaXMgYXBwIHRvIE9CU1xuXHRcdFx0XHQqIFxuXHRcdFx0XHQqL1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3Qgb2JzID0gbmV3IE9CU1dlYlNvY2tldCh3ZWJzb2NrZXRJUCwgd2Vic29ja2V0UG9ydCwgd2Vic29ja2V0UGFzc3dvcmQpO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNvbnN0IHsgb2JzV2ViU29ja2V0VmVyc2lvbiwgbmVnb3RpYXRlZFJwY1ZlcnNpb24gfSA9IGF3YWl0IG9icy5jb25uZWN0KFxuXHRcdFx0XHRcdFx0YHdzOi8vJHt3ZWJzb2NrZXRJUH06JHt3ZWJzb2NrZXRQb3J0fWAsXG5cdFx0XHRcdFx0XHR3ZWJzb2NrZXRQYXNzd29yZCxcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cnBjVmVyc2lvbjogMSxcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYENvbm5lY3RlZCB0byBzZXJ2ZXIgJHtvYnNXZWJTb2NrZXRWZXJzaW9ufSAodXNpbmcgUlBDICR7bmVnb3RpYXRlZFJwY1ZlcnNpb259KWApO1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJDb25uZWN0ZWQgdG8gT0JTIFdlYlNvY2tldCBTZXJ2ZXJcIilcblx0XHRcdFx0XHRpbml0V2Vic29ja2V0RnVuY3Rpb25zKCk7XG5cdFx0XHRcdFx0Ly9kb2N1bWVudC50aXRsZSA9IFwiY29ubmVjdGlvbiBzZXRcIjtcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiRmFpbGVkIHRvIGNvbm5lY3QgdG8gT0JTIFdlYlNvY2tldCBTZXJ2ZXJcIilcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNvbm5lY3RcIiwgZXJyb3IuY29kZSwgZXJyb3IubWVzc2FnZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmdW5jdGlvbiBpbml0V2Vic29ja2V0RnVuY3Rpb25zKCl7XG5cblx0XHRcdFx0XHRvYnMub24oXCJlcnJvclwiLCAoZXJyKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFwiU29ja2V0IGVycm9yOlwiLCBlcnIpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGB3czovLyR7d2Vic29ja2V0SVB9OiR7d2Vic29ja2V0UG9ydH1gKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdCpDcmVhdGUgYW4gT1NDIFNlcnZlciBjb25uZWN0aW9uXG5cdFx0XHRcdFx0Kk9TQyBhcHAgLS0gdG8tLT4gT0JTXG5cdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRsZXQgb3NjU2VydmVyID0gbmV3IFNlcnZlcihvc2NJblBPUlQsIG9zY0lQKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRvc2NTZXJ2ZXIub24oXCJsaXN0ZW5pbmdcIiwgKCkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJPU0MgU2VydmVyIGlzIGxpc3RlbmluZy5cIik7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0b3NjU2VydmVyLm9uKFwibWVzc2FnZVwiLCAobXNnKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhgTWVzc2FnZTogJHttc2d9YCk7XG5cdFx0XHRcdFx0XHRzZW5kVG9PQlMobXNnLCBvYnMsIFwib3NjLW1lc3NhZ2VcIik7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0ZnVuY3Rpb24gc2VuZFRvT0JTKG1zZ1BhcmFtLCBvYnNQYXJhbSwgZXZlbnROYW1lKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcInNlbmRpbmcgbWVzc2FnZTpcIiwgSlNPTi5zdHJpbmdpZnkobXNnUGFyYW0pKTtcblx0XHRcdFx0XHRcdGNvbnN0IHdlYlNvY2tldE1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShtc2dQYXJhbSk7XG5cdFx0XHRcdFx0XHQvL3NlbmQgcmVzdWx0cyB0byBPQlMgQnJvd3NlciBTb3VyY2Vcblx0XHRcdFx0XHRcdG9ic1BhcmFtLmNhbGwoXCJDYWxsVmVuZG9yUmVxdWVzdFwiLCB7XG5cdFx0XHRcdFx0XHRcdHZlbmRvck5hbWU6IFwib2JzLWJyb3dzZXJcIixcblx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiZW1pdF9ldmVudFwiLFxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0RGF0YToge1xuXHRcdFx0XHRcdFx0XHRcdGV2ZW50X25hbWU6IGV2ZW50TmFtZSxcblx0XHRcdFx0XHRcdFx0XHRldmVudF9kYXRhOiB7IHdlYlNvY2tldE1lc3NhZ2UgfSxcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdC8qXG5cdFx0XHRcdCpDcmVhdGUgT1NDIENsaWVudCBPdXQgUG9ydFxuXHRcdFx0XHQqbWVzc2FnZSBmcm9tIE9CUyAtLXRvLS0+IE9TQyBhcHBcblx0XHRcdFx0Ki9cblx0XHRcdFx0Y29uc3Qgb3NjQ2xpZW50ID0gbmV3IENsaWVudChvc2NJUCwgb3NjT3V0UE9SVCk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwib3NjQ2xpZW50XCIsIG9zY0NsaWVudCwgb3NjSVAsIG9zY091dFBPUlQsIG9zY0luUE9SVCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRvYnMub24oXCJDdXN0b21FdmVudFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIk1lc3NhZ2UgZnJvbSBPQlNcIixldmVudCk7XG5cdFx0XHRcdFx0aWYgKGV2ZW50LmV2ZW50X25hbWUgPT09IFwiT1NDLW91dFwiKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBtZXNzYWdlID0gbmV3IE1lc3NhZ2UoZXZlbnQuYWRkcmVzcyk7XG5cdFx0XHRcdFx0XHRpZiAoT2JqZWN0Lmhhc093bihldmVudCwgXCJhcmcxXCIpKSB7XG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2UuYXBwZW5kKGV2ZW50LmFyZzEpO1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcImFyZzFcIiwgbWVzc2FnZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoT2JqZWN0Lmhhc093bihldmVudCwgXCJhcmcyXCIpKSB7XG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2UuYXBwZW5kKGV2ZW50LmFyZzIpO1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhtZXNzYWdlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChPYmplY3QuaGFzT3duKGV2ZW50LCBcImFyZzNcIikpIHtcblx0XHRcdFx0XHRcdFx0bWVzc2FnZS5hcHBlbmQoZXZlbnQuYXJnMyk7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKE9iamVjdC5oYXNPd24oZXZlbnQsIFwiYXJnNFwiKSkge1xuXHRcdFx0XHRcdFx0XHRtZXNzYWdlLmFwcGVuZChldmVudC5hcmc0KTtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2cobWVzc2FnZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoT2JqZWN0Lmhhc093bihldmVudCwgXCJhcmc1XCIpKSB7XG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2UuYXBwZW5kKGV2ZW50LmFyZzUpO1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhtZXNzYWdlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChPYmplY3QuaGFzT3duKGV2ZW50LCBcImFyZzZcIikpIHtcblx0XHRcdFx0XHRcdFx0bWVzc2FnZS5hcHBlbmQoZXZlbnQuYXJnNik7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKE9iamVjdC5oYXNPd24oZXZlbnQsIFwiYXJnN1wiKSkge1xuXHRcdFx0XHRcdFx0XHRtZXNzYWdlLmFwcGVuZChldmVudC5hcmc3KTtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2cobWVzc2FnZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIm1lc3NhZ2UgdG8gT1NDIGRldmljZVwiLCBtZXNzYWdlKTtcblx0XHRcdFx0XHRcdG9zY0NsaWVudC5zZW5kKG1lc3NhZ2UsIChlcnIpID0+IHtcblx0XHRcdFx0XHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IobmV3IEVycm9yKGVycikpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdC8vY2xpZW50LnNlbmQoYCR7ZXZlbnQuY29tbWFuZH0gXCIke2V2ZW50LmRhdGF9XCJgKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9fSlcblx0XHRcbi8vICNlbmRyZWdpb25cblxuLy8gXG4vL1xuLy9cdFxuLy9cdCNyZWdpb24gR2V0IFNjZW5lcyBmcm9tIE9CUyBmZWF0dXJlXG4vLyAgMS4gcG9wdWxhdGUgdGhlIF9zbGlkZV9UYWdzIGZvbGRlciB3aXRoIE9CUyBTY2VuZXNcbi8vXHQyLiBBZGQgdGFncyB0byBzbGlkZXNcbi8vXHQzLiBcbi8vXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiAnZ2V0LW9icy1zY2VuZS10YWdzJyxcblx0XHRcdG5hbWU6ICdHZXQgT0JTIHRhZ3MnLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jKCkgPT4ge1xuXHRcdCAvL3RoaXMuYWRkUmliYm9uSWNvbihcImltYWdlLWRvd25cIixcImdldCBPQlMgU2NlbmUgT3B0aW9uc1wiLCBhc3luYyAoKSA9Pntcblx0XHRcdG5ldyBOb3RpY2UoXCJHZXR0aW5nIE9CUyBUYWdzXCIpXG5cdFx0XHRsZXQgd2Vic29ja2V0SVAgPSB0aGlzLnNldHRpbmdzLndlYnNvY2tldElQX1RleHQ7XG5cdFx0XHRsZXQgd2Vic29ja2V0UG9ydCA9IHRoaXMuc2V0dGluZ3Mud2Vic29ja2V0UG9ydF9UZXh0O1xuXHRcdFx0bGV0IHdlYnNvY2tldFBhc3N3b3JkID0gdGhpcy5zZXR0aW5ncy53ZWJzb2NrZXRQV19UZXh0O1xuXHRcdFx0XG5cdFx0XHQvKlxuXHRcdFx0KkNvbm5lY3QgdGhpcyBhcHAgdG8gT0JTXG5cdFx0XHQqL1xuXHRcdFx0Y29uc3Qgb2JzID0gbmV3IE9CU1dlYlNvY2tldCh3ZWJzb2NrZXRJUCwgd2Vic29ja2V0UG9ydCwgd2Vic29ja2V0UGFzc3dvcmQpO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc3QgeyBvYnNXZWJTb2NrZXRWZXJzaW9uLCBuZWdvdGlhdGVkUnBjVmVyc2lvbiB9ID0gYXdhaXQgb2JzLmNvbm5lY3QoXG5cdFx0XHRcdFx0YHdzOi8vJHt3ZWJzb2NrZXRJUH06JHt3ZWJzb2NrZXRQb3J0fWAsXG5cdFx0XHRcdFx0d2Vic29ja2V0UGFzc3dvcmQsXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cnBjVmVyc2lvbjogMSxcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFxuXHRcdFx0XHRcdGBDb25uZWN0ZWQgdG8gc2VydmVyICR7b2JzV2ViU29ja2V0VmVyc2lvbn0gKHVzaW5nIFJQQyAke25lZ290aWF0ZWRScGNWZXJzaW9ufSlgXG5cdFx0XHRcdCk7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJDb25uZWN0ZWQgdG8gT0JTIFdlYlNvY2tldCBTZXJ2ZXJcIilcblx0XHRcdFx0Ly9kb2N1bWVudC50aXRsZSA9IFwiY29ubmVjdGlvbiBzZXRcIjtcblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJGYWlsZWQgdG8gY29ubmVjdCB0byBPQlMgV2ViU29ja2V0IFNlcnZlclwiKVxuXHRcdFx0XHRjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNvbm5lY3RcIiwgZXJyb3IuY29kZSwgZXJyb3IubWVzc2FnZSk7XG5cdFx0XHR9XG5cdFx0XHRvYnMub24oXCJlcnJvclwiLCAoZXJyKSA9PiB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJTb2NrZXQgZXJyb3I6XCIsIGVycik7XG5cdFx0XHR9KTtcblx0XHRcdGNvbnNvbGUubG9nKGB3czovLyR7d2Vic29ja2V0SVB9OiR7d2Vic29ja2V0UG9ydH1gKTtcblx0XHRcdFxuXHRcdFx0Ly9cblx0XHRcdC8vIEdldCBTY2VuZXMgYW5kIGNhbWVyYVxuXHRcdFx0Ly9cblx0XHRcdC8vc2V0VGltZW91dCgoKSA9PiBvYnMuZGlzY29ubmVjdCgpLCAzMDAwKTtcblx0XHRcdFxuXHRcdFx0Ly9jcmVhdGUgU2NlbmUgVGVtcGxhdGUgTm90ZXNcblx0XHRcdFx0Y29uc3Qgc2NlbmVMaXN0ID0gYXdhaXQgb2JzLmNhbGwoXCJHZXRTY2VuZUxpc3RcIik7XG5cdFx0XHRcdGNvbnNvbGUubG9nKHNjZW5lTGlzdClcblx0XHRcdFx0c2NlbmVMaXN0LnNjZW5lcy5mb3JFYWNoKGFzeW5jIChzY2VuZSwgaW5kZXgpID0+IHtcblx0XHRcdFx0XHQvLyBmaW5kIHNjZW5lcyBzdGFydGluZyB3aXRoIFwic2NlbmVcIlxuXHRcdFx0XHRcdGlmIChzY2VuZS5zY2VuZU5hbWUuc3RhcnRzV2l0aChcInNjZW5lfHx8XCIpKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzY2VuZU5hbWUgPSBzY2VuZS5zY2VuZU5hbWUuc3BsaXQoXCJ8fHxcIik7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGxldCBmaWxlTmFtZSA9IGBTY2VuZSAtICR7c2NlbmVOYW1lWzFdfWA7XG5cdFx0XHRcdFx0XHRsZXQgZXhpc3RpbmcgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLmV4aXN0cyhub3JtYWxpemVQYXRoKGBfc2xpZGVfVGFncy8ke2ZpbGVOYW1lfWApKTtcblx0XHRcdFx0XHRcdGlmICghZXhpc3RpbmcpIHtcblx0XHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKGBfc2xpZGVfVGFncy8ke2ZpbGVOYW1lfS5tZGAsIFxuXHRcdFx0XHRcdFx0XHRcdGBgLFxuXHRcdFx0XHRcdFx0XHQpO1x0XHRcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gZmlsZU5hbWUgPSBgRXhpdCBTY2VuZSAtICR7c2NlbmVOYW1lWzFdfWA7XG5cdFx0XHRcdFx0XHQvLyBleGlzdGluZyA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKG5vcm1hbGl6ZVBhdGgoYF9zbGlkZV9UYWdzLyR7ZmlsZU5hbWV9YCkpO1xuXHRcdFx0XHRcdFx0Ly8gaWYgKCFleGlzdGluZykge1xuXHRcdFx0XHRcdFx0Ly8gXHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUoYF9zbGlkZV9UYWdzLyR7ZmlsZU5hbWV9Lm1kYCwgXG5cdFx0XHRcdFx0XHQvLyBcdFx0YDwhLS0gc2xpZGUgZGF0YS1zY2VuZS1leGl0PVwiJHtzY2VuZU5hbWVbMV19XCIgLS0+IGAsXG5cdFx0XHRcdFx0XHQvLyBcdCk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gfVxuXHRcdFx0XHRcdH1cdFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Ly99XG5cdFx0XHRcdFxuXHRcdFx0Ly9jcmVhdGUgQ2FtZXJhIFRlbXBsYXRlIE5vdGVzXG5cdFx0XHRcdGxldCBjYW1lcmFTb3VyY2VzID0gYXdhaXQgb2JzLmNhbGwoXCJHZXRTY2VuZUl0ZW1MaXN0XCIsIHsgc2NlbmVOYW1lOiBcIklucHV0IENhbWVyYVwiIH0pO1xuXHRcdFx0XHRjYW1lcmFTb3VyY2VzLnNjZW5lSXRlbXMuZm9yRWFjaChhc3luYyhzb3VyY2UsIGluZGV4KSA9PiB7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdGxldCBmaWxlTmFtZSA9IGBDYW1lcmEgLSAke3NvdXJjZS5zb3VyY2VOYW1lfWA7XG5cdFx0XHRcdFx0bGV0IGV4aXN0aW5nID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5leGlzdHMobm9ybWFsaXplUGF0aChgX3NsaWRlX1RhZ3MvJHtmaWxlTmFtZX1gKSk7XG5cdFx0XHRcdFx0aWYgKCFleGlzdGluZykge1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKGBfc2xpZGVfVGFncy8ke2ZpbGVOYW1lfS5tZGAsIFxuXHRcdFx0XHRcdFx0XHRgYCxcblx0XHRcdFx0XHRcdCk7XHRcdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBmaWxlTmFtZSA9IGBFeGl0IENhbWVyYSAtICR7c291cmNlLnNvdXJjZU5hbWV9YDtcblx0XHRcdFx0XHQvLyBleGlzdGluZyA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKG5vcm1hbGl6ZVBhdGgoYF9zbGlkZV9UYWdzLyR7ZmlsZU5hbWV9YCkpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIGlmICghZXhpc3RpbmcpIHtcblx0XHRcdFx0XHQvLyBcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShgX3NsaWRlX1RhZ3MvJHtmaWxlTmFtZX0ubWRgLCBcblx0XHRcdFx0XHQvLyBcdFx0YDwhLS0gc2xpZGUgZGF0YS1jYW1lcmEtZXhpdD1cIiR7c291cmNlLnNvdXJjZU5hbWV9XCIgLS0+IGAsXG5cdFx0XHRcdFx0Ly8gXHRcdCk7XHRcdFxuXHRcdFx0XHRcdC8vIH1cblx0XHRcdFx0fSk7XG4gICAgICAgICAgICAgLy9FbmQgb2YgZ2V0IHNjZW5lIGZ1bmN0aW9uXG5cdFx0XHQgb2JzLmRpc2Nvbm5lY3QoKTtcblx0XHRcdH19KVxuXG5cdFx0XHQvLyB0aGlzLmFkZFJpYmJvbkljb24oXCJzY3JvbGxcIiwgXCJlbnRyYW5jZSB0YWdcIiwgKCkgPT4ge1xuXHRcdFx0Ly8gXHRuZXcgVVVoaW1zeUVudHJhbmNlU3VnZ2VzdCh0aGlzLmFwcCkub3BlbigpO1xuXHRcdFx0Ly8gfSlcblxuXHRcdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdFx0aWQ6ICdpbnNlcnQtZW50cmFuY2UtdGFnJyxcblx0XHRcdFx0bmFtZTogJ0luc2VydCBzbGlkZSBlbnRyYW5jZSB0YWcnLFxuXHRcdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0XHRuZXcgVVVoaW1zeUVudHJhbmNlU3VnZ2VzdCh0aGlzLmFwcCkub3BlbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdFx0aWQ6ICdpbnNlcnQtZXhpdC10YWcnLFxuXHRcdFx0XHRuYW1lOiAnSW5zZXJ0IHNsaWRlIGV4aXQgdGFnJyxcblx0XHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdFx0bmV3IFVVaGltc3lFeGl0U3VnZ2VzdCh0aGlzLmFwcCkub3BlbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcbi8vICNlbmRyZWdpb25cblxuLy8gXG4vL1xuLy9cdFx0XG4vLyAjcmVnaW9uIFNlbmQgUFRaIGNhbWVyYSBwb3NpdGlvbiB0byBPQlMgZmVhdHVyZVxuLy8gIE9ubHkgc2hvdyB0aGlzIGNvbW1hbmQgdG8gbWFjT1MgdXNlcnNcbi8vXG4vL1x0U2VuZCBhIFBUWiBjYW1lcmEgcG9zaXRpb24gbWVzc2FnZSBldmVyeSBzZWNvbmRcblx0XHRcblx0XHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRcdGlkOiAnc2VuZC1jYW1lcmEtcG9zaXRpb24tdG8tb2JzJyxcblx0XHRcdFx0bmFtZTogJ1N0YXJ0IHNlbmRpbmcgY2FtZXJhIFBUWiBwb3NpdGlvbiB0byBPQlMnLFxuXHRcdFx0XHRjaGVja0NhbGxiYWNrOiBhc3luYyhjaGVja2luZykgPT4ge1xuXHRcdFx0XHRcdGxldCBpc01hYyA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nO1xuXHRcdFx0XHRcdGlmIChpc01hYyl7XG5cdFx0XHRcdFx0XHRpZighY2hlY2tpbmcpe1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJ0cnVlXCIpXG5cdFx0XHRcdFx0XHRcdGxldCB3ZWJzb2NrZXRJUCA9IHRoaXMuc2V0dGluZ3Mud2Vic29ja2V0SVBfVGV4dDtcblx0XHRcdFx0XHRcdFx0bGV0IHdlYnNvY2tldFBvcnQgPSB0aGlzLnNldHRpbmdzLndlYnNvY2tldFBvcnRfVGV4dDtcblx0XHRcdFx0XHRcdFx0bGV0IHdlYnNvY2tldFBhc3N3b3JkID0gdGhpcy5zZXR0aW5ncy53ZWJzb2NrZXRQV19UZXh0O1xuXHRcdFx0XG5cdFx0XHQvKlxuXHRcdFx0KkNvbm5lY3QgdGhpcyBhcHAgdG8gT0JTXG5cdFx0XHQqL1xuXHRcdFx0Y29uc3Qgb2JzID0gbmV3IE9CU1dlYlNvY2tldCh3ZWJzb2NrZXRJUCwgd2Vic29ja2V0UG9ydCwgd2Vic29ja2V0UGFzc3dvcmQpO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc3QgeyBvYnNXZWJTb2NrZXRWZXJzaW9uLCBuZWdvdGlhdGVkUnBjVmVyc2lvbiB9ID0gYXdhaXQgb2JzLmNvbm5lY3QoXG5cdFx0XHRcdFx0YHdzOi8vJHt3ZWJzb2NrZXRJUH06JHt3ZWJzb2NrZXRQb3J0fWAsXG5cdFx0XHRcdFx0d2Vic29ja2V0UGFzc3dvcmQsXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cnBjVmVyc2lvbjogMSxcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFxuXHRcdFx0XHRcdGBDb25uZWN0ZWQgdG8gc2VydmVyICR7b2JzV2ViU29ja2V0VmVyc2lvbn0gKHVzaW5nIFJQQyAke25lZ290aWF0ZWRScGNWZXJzaW9ufSlgXG5cdFx0XHRcdCk7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJDb25uZWN0ZWQgdG8gT0JTIFdlYlNvY2tldCBTZXJ2ZXJcIilcblx0XHRcdFx0Ly9kb2N1bWVudC50aXRsZSA9IFwiY29ubmVjdGlvbiBzZXRcIjtcblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJGYWlsZWQgdG8gY29ubmVjdCB0byBPQlMgV2ViU29ja2V0IFNlcnZlclwiKVxuXHRcdFx0XHRjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNvbm5lY3RcIiwgZXJyb3IuY29kZSwgZXJyb3IubWVzc2FnZSk7XG5cdFx0XHR9XG5cdFx0XHRvYnMub24oXCJlcnJvclwiLCAoZXJyKSA9PiB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJTb2NrZXQgZXJyb3I6XCIsIGVycik7XG5cdFx0XHR9KTtcblx0XHRcdGNvbnNvbGUubG9nKGB3czovLyR7d2Vic29ja2V0SVB9OiR7d2Vic29ja2V0UG9ydH1gKTtcblxuXHRcdFx0Ly9cblx0XHRcdC8vUFRaIGRldGFpbHNcblx0XHRcdC8vXG5cblx0XHRcdC8vaHR0cHM6Ly9mb3J1bS5vYnNpZGlhbi5tZC90L2hvdy10by1nZXQtdmF1bHQtYWJzb2x1dGUtcGF0aC8yMjk2NVxuXHRcdFx0Ly9AdHMtaWdub3JlXG4vLy8vLy8vLy8vL21ha2UgdmF1bHRQYXRoIGFuIG9uTG9hZCBnbG9iYWwgdmFyaWFibGVcblx0XHRcdGNvbnN0IHZhdWx0UGF0aCA9IG5vcm1hbGl6ZVBhdGgoYCR7dGhpcy5hcHAudmF1bHQuYWRhcHRlci5iYXNlUGF0aH0vJHt0aGlzLmFwcC52YXVsdC5jb25maWdEaXJ9L3BsdWdpbnMvVVVoaW1zeVBsdWdpbmApXG5cdFx0XHRjb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXHRcdFx0Y29uc3QgZXhlYyA9IHV0aWwucHJvbWlzaWZ5KHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjKTtcblx0XHRcdGxldCBwcmV2aW91c1BUWiA9XCJcIjtcblx0XHRcdFxuXHRcdFx0c2V0SW50ZXJ2YWwoIGFzeW5jKCkgPT57XG5cblx0XHRcdFx0bGV0IHB0ID0gYXdhaXQgZ2V0Q2FtZXJhUGFuVGlsdCh2YXVsdFBhdGgsIHV0aWwsIGV4ZWMpO1xuXHRcdFx0XHRsZXQgeiA9IGF3YWl0IGdldENhbWVyYVpvb20odmF1bHRQYXRoLCB1dGlsLCBleGVjKTtcblx0XHRcdFx0bGV0IHB0ek1lc3NhZ2UgPSBgJHtwdH0ke3p9fWBcblx0XHRcdFx0XG5cdFx0XHRcdGlmKHB0ek1lc3NhZ2UgIT0gcHJldmlvdXNQVFope1xuXHRcdFx0XHRcdC8vc2VuZCByZXN1bHRzIHRvIE9CU1xuXHRcdFx0XHRcdHByZXZpb3VzUFRaID0gcHR6TWVzc2FnZVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vc2VuZCByZXN1bHRzIHRvIHRleHQgc291cmNlXG5cdFx0XHRcdFx0YXdhaXQgb2JzLmNhbGwoXCJTZXRJbnB1dFNldHRpbmdzXCIsIHtcblx0XHRcdFx0XHRcdGlucHV0TmFtZTogJ1BUWiB2YWx1ZXMnLFxuXHRcdFx0XHRcdFx0aW5wdXRTZXR0aW5nczoge1xuXHRcdFx0XHRcdFx0XHR0ZXh0OiBgJHtwdHpNZXNzYWdlfWAsXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly9zZW5kIHJlc3VsdHMgdG8gT0JTIEJyb3dzZXIgU291cmNlXG5cdFx0XHRcdFx0b2JzLmNhbGwoXCJDYWxsVmVuZG9yUmVxdWVzdFwiLCB7XG5cdFx0XHRcdFx0XHR2ZW5kb3JOYW1lOiBcIm9icy1icm93c2VyXCIsXG5cdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJlbWl0X2V2ZW50XCIsXG5cdFx0XHRcdFx0XHRyZXF1ZXN0RGF0YToge1xuXHRcdFx0XHRcdFx0XHRldmVudF9uYW1lOiBcInB0ei1tZXNzYWdlXCIsXG5cdFx0XHRcdFx0XHRcdGV2ZW50X2RhdGE6IHsgcHR6TWVzc2FnZSB9LFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgMjAwMCk7XG5cblx0XHRcdGFzeW5jIGZ1bmN0aW9uIGdldENhbWVyYVBhblRpbHQodmF1bHRQYXRoLCB1dGlsLCBleGVjKSB7XHRcdFx0XHRcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc29sZS5sb2codmF1bHRQYXRoKVxuXHRcdFx0XHRjb25zdCB7IHN0ZG91dCwgc3RkZXJyIH0gPSBhd2FpdCBleGVjKGAnJHt2YXVsdFBhdGh9L3V2Yy11dGlsJyAtSSAwIC1vIHBhbi10aWx0LWFic2ApO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdzdGRvdXQ6Jywgc3Rkb3V0KTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnc3RkZXJyOicsIHN0ZGVycik7XG5cdFx0XHRcdGxldCBwdFJlc3VsdCA9IHN0ZG91dC50b1N0cmluZygpO1xuXHRcdFx0XHRwdFJlc3VsdCA9IHB0UmVzdWx0LnJlcGxhY2UoL1xcbi9nLCcnKS5yZXBsYWNlKCdwYW4nLCdcInBhblwiJykucmVwbGFjZSgnfScsJywgXCJ6b29tXCI6ICcpLnJlcGxhY2UoLz0vZywnOiAnKS5yZXBsYWNlKCd0aWx0JywnXCJ0aWx0XCInKVxuXHRcdFx0XHRyZXR1cm4gcHRSZXN1bHQ7XG5cdFx0XHRcdFxuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdCAgY29uc29sZS5lcnJvcihlKTsgLy8gc2hvdWxkIGNvbnRhaW4gY29kZSAoZXhpdCBjb2RlKSBhbmQgc2lnbmFsICh0aGF0IGNhdXNlZCB0aGUgdGVybWluYXRpb24pLlxuXHRcdFx0XHR9XG5cdFx0XHQgIH1cblxuXHRcdFx0YXN5bmMgZnVuY3Rpb24gZ2V0Q2FtZXJhWm9vbSh2YXVsdFBhdGgsIHV0aWwsIGV4ZWMpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc3QgeyBzdGRvdXQsIHN0ZGVyciB9ID0gYXdhaXQgZXhlYyhgJyR7dmF1bHRQYXRofS91dmMtdXRpbCcgLUkgMCAtbyB6b29tLWFic2ApO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdzdGRvdXQ6Jywgc3Rkb3V0KTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnc3RkZXJyOicsIHN0ZGVycik7XG5cdFx0XHRcdHJldHVybiBzdGRvdXQucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuXHRcdFx0XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0ICBjb25zb2xlLmVycm9yKGUpOyAvLyBzaG91bGQgY29udGFpbiBjb2RlIChleGl0IGNvZGUpIGFuZCBzaWduYWwgKHRoYXQgY2F1c2VkIHRoZSB0ZXJtaW5hdGlvbikuXG5cdFx0XHRcdH1cblx0XHRcdCAgfVxuXHRcdFx0XG5cdFx0XHQgIG9icy5vbihcIkN1c3RvbUV2ZW50XCIsIGFzeW5jIGZ1bmN0aW9uIChldmVudCl7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIk1lc3NhZ2UgZnJvbSBPQlNcIixldmVudCk7XG5cdFx0XHRcdGlmIChldmVudC5ldmVudF9uYW1lID09PSBcInNldC1wdHpcIikge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdjb21tYW5kJyxgJ3Nob3J0Y3V0cycgcnVuICR7ZXZlbnQuc2hvcnRjdXRfbmFtZX1gKVxuXHRcdFx0XHRcdGNvbnN0IHN0ZG91dCA9ICBhd2FpdCBleGVjKGAnJHt2YXVsdFBhdGh9L3V2Yy11dGlsJyAtSSAwIC1vIHBhbi10aWx0LWFic2ApO1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKHN0ZG91dClcblx0XHRcdFx0fVxuXHRcdFx0ICB9KVxuXG5cdFx0XHRcdC8vZW5kIGNoZWNraW5nIFxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0Ly9lbmQgZ2V0IFBUWiBjb21tYW5kXHRcblx0XHRcdH0pO1xuXG5cblx0Ly9zdG9wIHNlbmRpbmcgY2FtZXJhIHBvc2l0aW9uXHRcdFxuXHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdGlkOiAnc3RvcC1jYW1lcmEtcG9zaXRpb24tdG8tb2JzJyxcblx0XHRuYW1lOiAnU3RvcCBzZW5kaW5nIGNhbWVyYSBQVFogcG9zaXRpb24gdG8gT0JTJyxcblx0XHRjYWxsYmFjazooKSA9Pntcblx0XHRcdC8vIFNldCBhIGZha2UgdGltZW91dCB0byBnZXQgdGhlIGhpZ2hlc3QgdGltZW91dCBpZFxuXHRcdFx0bGV0IGhpZ2hlc3RUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KFwiO1wiKTtcblx0XHRcdGZvciAobGV0IGkgPSAwIDsgaSA8IGhpZ2hlc3RUaW1lb3V0SWQgOyBpKyspIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KGkpOyBcblx0XHRcdH1cblx0XHR9XG5cblx0fSlcblxuLy8gI2VuZHJlZ2lvblxuXG4vLyBcbi8vXG4vL1x0XHRcbi8vICNyZWdpb24gUnVuIEFwcGxlIFNob3J0Y3V0cyBzY3JpcHQgZmVhdHVyZVxuLy8gIE9ubHkgc2hvdyB0aGlzIGNvbW1hbmQgdG8gbWFjT1MgdXNlcnNcbi8vXG4vL1x0UnVuIFNob3J0Y3V0cyBhbmQgcmV0dXJuIHJlc3VsdHMgXG5cbi8vQ09NTUFORDogR2V0IGxpc3Qgb2YgU2hvcnRjdXQgdGFnc1xudGhpcy5hZGRDb21tYW5kKHtcblx0aWQ6ICdnZXQtc2hvcnRjdXRzLXRhZ3MnLFxuXHRuYW1lOiAnR2V0IEFwcGxlIFNob3J0Y3V0cyB0YWdzJyxcblx0Y2hlY2tDYWxsYmFjazogYXN5bmMoY2hlY2tpbmcpID0+IHtcblx0XHRsZXQgaXNNYWMgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJztcblx0XHRpZiAoaXNNYWMpe1xuXHRcdFx0aWYoIWNoZWNraW5nKXtcblx0XHRcdFx0Ly9UaGlzIGlzIGEgTWFjIGNvbXB1dGVyIHJ1biB0aGUgY29tbWFuZFxuXHRcdFx0XHRjb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXHRcdFx0XHRjb25zdCBleGVjID0gdXRpbC5wcm9taXNpZnkocmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWMpO1x0XG5cdFx0XHRcdGNvbnN0IHsgc3Rkb3V0LCBzdGRlcnIgfSA9IGF3YWl0IGV4ZWMoYCdzaG9ydGN1dHMnIGxpc3RgKTtcblx0XHRcdFx0Ly9sZXQgc2hvcnRjdXRzID0gIEpTT04uc3RyaW5naWZ5KHN0ZG91dClcblx0XHRcdFx0bGV0IHNob3J0Y3V0cyA9ICBzdGRvdXQuc3BsaXQoJ1xcbicpXG5cblx0XHRcdFx0c2hvcnRjdXRzID0gc2hvcnRjdXRzLmZpbHRlcigoc2hvcnRjdXQpID0+IHtyZXR1cm4gc2hvcnRjdXQudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwidXVoaW1zeVwiKX0pXG5cdFx0XHRcdGNvbnNvbGUubG9nKHNob3J0Y3V0cyk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKHR5cGVvZiBzaG9ydGN1dHMpO1xuXHRcdFx0XHRjb25zdCBzaG9ydGN1dENvdW50ID0gT2JqZWN0LmtleXMoc2hvcnRjdXRzKS5sZW5ndGg7XG5cdFx0XHRcdE9iamVjdC5lbnRyaWVzKHNob3J0Y3V0cykuZm9yRWFjaChhc3luYyhba2V5LCBzaG9ydGN1dF0pID0+IHtcblx0XHRcdFx0Ly9zaG9ydGN1dHMuZm9yZWFjaChhc3luYyAoc2hvcnRjdXQsIGluZGV4KSA9PiB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGtleSwgc2hvcnRjdXQsIHNob3J0Y3V0Q291bnQpXG5cdFx0XHRcdFx0bGV0IGZpbGVOYW1lID0gYFNob3J0Y3V0cyAtICR7c2hvcnRjdXR9Lm1kYDtcblx0XHRcdFx0XHRcdGxldCBleGlzdGluZyA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKG5vcm1hbGl6ZVBhdGgoYF9zbGlkZV9UYWdzLyR7ZmlsZU5hbWV9YCkpO1xuXHRcdFx0XHRcdFx0aWYgKCFleGlzdGluZykge1xuXHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUoYF9zbGlkZV9UYWdzLyR7ZmlsZU5hbWV9YCwgXG5cdFx0XHRcdFx0XHRcdFx0YGAsXG5cdFx0XHRcdFx0XHRcdCk7XHRcdFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKE51bWJlcihrZXkpID09IHNob3J0Y3V0Q291bnQgLSAxKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgdGhlIGxhc3QgaXRlbVxuXHRcdFx0XHRcdFx0XHR0aGlzLm9wZW5WaWV3KCk7XG5cdFx0XHRcdFx0XHQgIH1cblx0XHRcdFx0XHRcdC8vIGZpbGVOYW1lID0gYEV4aXQgU2hvcnRjdXRzIC0gJHtzaG9ydGN1dH0ubWRgO1xuXHRcdFx0XHRcdFx0Ly8gZXhpc3RpbmcgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLmV4aXN0cyhub3JtYWxpemVQYXRoKGBfc2xpZGVfVGFncy8ke2ZpbGVOYW1lfWApKTtcblx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKGZpbGVOYW1lKVxuXHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJleGlzdGluZ1wiLGV4aXN0aW5nKVxuXHRcdFx0XHRcdFx0Ly8gaWYgKCFleGlzdGluZykge1xuXHRcdFx0XHRcdFx0Ly8gXHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUoYF9zbGlkZV9UYWdzLyR7ZmlsZU5hbWV9YCwgXG5cdFx0XHRcdFx0XHQvLyBcdFx0YDwhLS0gc2xpZGUgZGF0YS1zaG9ydGN1dC1leGl0PVwiJHtzaG9ydGN1dH1cIiAtLT4gYCxcblx0XHRcdFx0XHRcdC8vIFx0KTtcblx0XHRcdFx0XHRcdC8vIH1cblx0XHRcdFx0fSlcblx0XHRcdH07XG5cdFx0fVxuXHR9IFxufSlcblxuXG4vL0xJU1RFTiBmb3IgU2hvcnRjdXQgUmVxdWVzdFxudGhpcy5hZGRDb21tYW5kKHtcblx0aWQ6ICdydW4tYXBwbGUtc2hvcnRjdXQnLFxuXHRuYW1lOiAnU3RhcnQgQXBwbGUgU2hvcnRjdXQgQ29ubmVjdGlvbicsXG5cdGNhbGxiYWNrOiBhc3luYygpID0+IHtcblx0XHRcblx0XHRcblx0XHQvL2Nvbm5lY3QgdG8gT0JTXG5cdFx0bGV0IHdlYnNvY2tldElQID0gdGhpcy5zZXR0aW5ncy53ZWJzb2NrZXRJUF9UZXh0O1xuXHRcdGxldCB3ZWJzb2NrZXRQb3J0ID0gdGhpcy5zZXR0aW5ncy53ZWJzb2NrZXRQb3J0X1RleHQ7XG5cdFx0bGV0IHdlYnNvY2tldFBhc3N3b3JkID0gdGhpcy5zZXR0aW5ncy53ZWJzb2NrZXRQV19UZXh0O1xuXHRcdFxuXHRcdC8qXG5cdFx0KkNvbm5lY3QgdGhpcyBhcHAgdG8gT0JTXG5cdFx0Ki9cblx0XHRjb25zdCBvYnMgPSBuZXcgT0JTV2ViU29ja2V0KHdlYnNvY2tldElQLCB3ZWJzb2NrZXRQb3J0LCB3ZWJzb2NrZXRQYXNzd29yZCk7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHsgb2JzV2ViU29ja2V0VmVyc2lvbiwgbmVnb3RpYXRlZFJwY1ZlcnNpb24gfSA9IGF3YWl0IG9icy5jb25uZWN0KFxuXHRcdFx0XHRgd3M6Ly8ke3dlYnNvY2tldElQfToke3dlYnNvY2tldFBvcnR9YCxcblx0XHRcdFx0d2Vic29ja2V0UGFzc3dvcmQsXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRycGNWZXJzaW9uOiAxLFxuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdFx0Y29uc29sZS5sb2coXG5cdFx0XHRcdGBDb25uZWN0ZWQgdG8gc2VydmVyICR7b2JzV2ViU29ja2V0VmVyc2lvbn0gKHVzaW5nIFJQQyAke25lZ290aWF0ZWRScGNWZXJzaW9ufSlgXG5cdFx0XHQpO1xuXHRcdFx0bmV3IE5vdGljZShcIkNvbm5lY3RlZCB0byBPQlMgV2ViU29ja2V0IFNlcnZlclwiKVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRuZXcgTm90aWNlKFwiRmFpbGVkIHRvIGNvbm5lY3QgdG8gT0JTIFdlYlNvY2tldCBTZXJ2ZXJcIilcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY29ubmVjdFwiLCBlcnJvci5jb2RlLCBlcnJvci5tZXNzYWdlKTtcblx0XHR9XG5cdFx0b2JzLm9uKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIlNvY2tldCBlcnJvcjpcIiwgZXJyKTtcblx0XHR9KTtcblx0XHRjb25zb2xlLmxvZyhgd3M6Ly8ke3dlYnNvY2tldElQfToke3dlYnNvY2tldFBvcnR9YCk7XG5cdFx0XG5cdFx0Ly9saXN0ZW4gZm9yIFNob3J0Y3V0IFJlcXVlc3Rcblx0XHRvYnMub24oXCJDdXN0b21FdmVudFwiLCBhc3luYyBmdW5jdGlvbiAoZXZlbnQpe1xuXHRcdFx0aWYgKGV2ZW50LmV2ZW50X25hbWUgPT09IFwicnVuLXNob3J0Y3V0XCIpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJtZXNzYWdlIGZyb20gT0JTXCIsZXZlbnQpO1xuXHRcdFx0XHRjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShldmVudC5ldmVudF9kYXRhKSk7XG5cdFx0XHRcdC8vdXBkYXRlIE9CUyBTb3VyY2UgQ29tbWFuZFRleHRcblx0XHRcdFx0YXdhaXQgb2JzLmNhbGwoXCJTZXRJbnB1dFNldHRpbmdzXCIsIHtcblx0XHRcdFx0XHRpbnB1dE5hbWU6IFwiQ29tbWFuZFRleHRcIixcblx0XHRcdFx0XHRpbnB1dFNldHRpbmdzOiB7XG5cdFx0XHRcdFx0XHR0ZXh0OiBgJHtldmVudC5ldmVudF9uYW1lfSAke2V2ZW50LmV2ZW50X2RhdGEuc2hvcnRjdXRfbmFtZX1gXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Y29uc29sZS5sb2coJ2NvbW1hbmQnLGAnc2hvcnRjdXRzJyBydW4gJHtldmVudC5ldmVudF9kYXRhLnNob3J0Y3V0X25hbWV9YClcblx0XHRcdFx0Y29uc29sZS5sb2coXCJwcm9wIGNoZWNrXCIsT2JqZWN0Lmhhc093bihldmVudC5ldmVudF9kYXRhLCBcInNob3J0Y3V0X2lucHV0XCIpKVxuXHRcdFx0XHQvL2lmIGhhcyBpbnB1dFxuXHRcdFx0XHRsZXQgc3Rkb3V0IFxuXHRcdFx0XHRpZiAoT2JqZWN0Lmhhc093bihldmVudC5ldmVudF9kYXRhLCBcInNob3J0Y3V0X2lucHV0XCIpKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJydW5uaW5nIHdpdGggaW5wdXRcIilcblx0XHRcdFx0XHRzdGRvdXQgPSAgZXhlY1N5bmMoYCdzaG9ydGN1dHMnIHJ1biAnJHtldmVudC5ldmVudF9kYXRhLnNob3J0Y3V0X25hbWV9JyA8PDwgJyR7ZXZlbnQuZXZlbnRfZGF0YS5zaG9ydGN1dF9pbnB1dH0nYCx7ZW5jb2Rpbmc6ICd1dGY4Jyx9KTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJydW5uaW5nIHdpdGggT1VUIGlucHV0XCIpXG5cdFx0XHRcdFx0c3Rkb3V0ID0gIGV4ZWNTeW5jKGAnc2hvcnRjdXRzJyBydW4gJyR7ZXZlbnQuZXZlbnRfZGF0YS5zaG9ydGN1dF9uYW1lfSdgLHtlbmNvZGluZzogJ3V0ZjgnLH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwic2hvcnRjdXQgcmVzdWx0IFwiLHN0ZG91dClcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhzdGRlcnIpXG5cdFx0XHRcdC8vSWYgU2hvcnRjdXQgcmV0dXJucyBhIHJlc3VsdCwgdGhlbiBjYWxsIE9CU1xuXHRcdFx0XHQvL1VwZGF0ZSBPQlMgU291cmNlIENvbW1hbmRSZXN1bHRzVGV4dFxuXHRcdFx0XHRhd2FpdCBvYnMuY2FsbChcIlNldElucHV0U2V0dGluZ3NcIiwge1xuXHRcdFx0XHRcdGlucHV0TmFtZTogXCJDb21tYW5kUmVzdWx0c1RleHRcIixcblx0XHRcdFx0XHRpbnB1dFNldHRpbmdzOiB7XG5cdFx0XHRcdFx0ICB0ZXh0OiBgJHtzdGRvdXR9YFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSlcblx0fX0pXG5cbi8vICNlbmRyZWdpb25cblxuXG4vLyBcbi8vXG4vL1x0XHRcbi8vICNyZWdpb24gT3BlbiBPQlMgZmVhdHVyZVxuLy8gXG4vL1xuLy9cdEV4ZWN1dGUgYSBjb21tYW5kIGxpbmUgdG8gT3BlbiBPQlNcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ29wZW4tb2JzJyxcblx0XHRcdG5hbWU6ICdPcGVuIE9CUycsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXHRcdFx0XHRjb25zdCBleGVjID0gdXRpbC5wcm9taXNpZnkocmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWMpO1xuXHRcdFx0XHQvL2J1aWxkIGNvbW1hbmQgc3RyaW5nXG5cdFx0XHRcdFxuXHRcdFx0XHRsZXQgY29tbWFuZFN0cmluZyA9XCJoZWxsb1wiXG5cdFx0XHRcdGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJykge1xuXHRcdFx0XHRcdGNvbW1hbmRTdHJpbmcgPSBgb3BlbiAtbiAtYSBcIiR7dGhpcy5zZXR0aW5ncy5vYnNBcHBOYW1lX1RleHR9XCJgO1xuXHRcdFx0XHRcdGNvbW1hbmRTdHJpbmcgKz0gYCAtLWFyZ3MgLS1jb2xsZWN0aW9uIFwiJHt0aGlzLnNldHRpbmdzLm9ic0NvbGxlY3Rpb25fVGV4dH1cImA7XG5cdFx0XHRcdFx0Y29tbWFuZFN0cmluZyArPSBgIC0tcmVtb3RlLWRlYnVnZ2luZy1wb3J0PSR7dGhpcy5zZXR0aW5ncy5vYnNEZWJ1Z1BvcnRfVGV4dH1gO1xuXHRcdFx0XHRcdGNvbW1hbmRTdHJpbmcgKz0gYCAtLXJlbW90ZS1hbGxvdy1vcmlnaW5zPWh0dHA6Ly9sb2NhbGhvc3Q6JHt0aGlzLnNldHRpbmdzLm9ic0RlYnVnUG9ydF9UZXh0fWA7XG5cdFx0XHRcdFx0Y29tbWFuZFN0cmluZyArPSBgIC0td2Vic29ja2V0X3BvcnQgXCIke3RoaXMuc2V0dGluZ3Mud2Vic29ja2V0UG9ydF9UZXh0fVwiYDtcblx0XHRcdFx0XHRjb21tYW5kU3RyaW5nICs9IGAgLS13ZWJzb2NrZXRfcGFzc3dvcmQgXCIke3RoaXMuc2V0dGluZ3Mud2Vic29ja2V0UFdfVGV4dH1cImA7XG5cdFx0XHRcdFx0Y29tbWFuZFN0cmluZyArPSBgIC0tbXVsdGlgO1xuXHRcdFx0XHRcdGV4ZWMoY29tbWFuZFN0cmluZyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcblx0XHRcdFx0XHRjb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXHRcdFx0XHRcdGNvbnN0IG9ic1BhdGggPSBgJHt0aGlzLnNldHRpbmdzLm9ic0FwcFBhdGhfVGV4dH0ke3RoaXMuc2V0dGluZ3Mub2JzQXBwTmFtZV9UZXh0fWBcblx0XHRcdFx0XHRjb25zdCBvYnNEaXIgPSBwYXRoLmRpcm5hbWUob2JzUGF0aCk7XG5cdFx0XHRcdFx0cHJvY2Vzcy5jaGRpcihvYnNEaXIpXG5cdFx0XG5cdFx0XHRcdFx0Y29tbWFuZFN0cmluZyA9IGAke3RoaXMuc2V0dGluZ3Mub2JzQXBwTmFtZV9UZXh0fWA7XG5cdFx0XHRcdFx0Y29tbWFuZFN0cmluZyArPSBgIC0tYXJncyAtLWNvbGxlY3Rpb24gXCIke3RoaXMuc2V0dGluZ3Mub2JzQ29sbGVjdGlvbl9UZXh0fVwiYDtcblx0XHRcdFx0XHRjb21tYW5kU3RyaW5nICs9IGAgLS1yZW1vdGUtZGVidWdnaW5nLXBvcnQ9JHt0aGlzLnNldHRpbmdzLm9ic0RlYnVnUG9ydF9UZXh0fWA7XG5cdFx0XHRcdFx0Y29tbWFuZFN0cmluZyArPSBgIC0tcmVtb3RlLWFsbG93LW9yaWdpbnM9aHR0cDovL2xvY2FsaG9zdDoke3RoaXMuc2V0dGluZ3Mub2JzRGVidWdQb3J0X1RleHR9YDtcblx0XHRcdFx0XHRjb21tYW5kU3RyaW5nICs9IGAgLS13ZWJzb2NrZXRfcG9ydCBcIiR7dGhpcy5zZXR0aW5ncy53ZWJzb2NrZXRQb3J0X1RleHR9XCJgO1xuXHRcdFx0XHRcdGNvbW1hbmRTdHJpbmcgKz0gYCAtLXdlYnNvY2tldF9wYXNzd29yZCBcIiR7dGhpcy5zZXR0aW5ncy53ZWJzb2NrZXRQV19UZXh0fVwiYDtcblx0XHRcdFx0XHRjb21tYW5kU3RyaW5nICs9IGAgLS1tdWx0aWA7XG5cdFx0XG5cdFx0XHRcdFx0ZXhlYyhjb21tYW5kU3RyaW5nLCAoZXJyb3IsIHN0ZG91dCwgc3RkZXJyKSA9PiB7XG5cdFx0XHRcdFx0ICBpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdCAgY29uc29sZS5lcnJvcihgZXhlYyBlcnJvcjogJHtlcnJvcn1gKTtcblx0XHRcdFx0XHRcdCAgcmV0dXJuO1xuXHRcdFx0XHRcdCAgfVxuXHRcdFx0XHRcdCAgY29uc29sZS5sb2coYHN0ZG91dDogJHtzdGRvdXR9YCk7XG5cdFx0XHRcdFx0ICBjb25zb2xlLmVycm9yKGBzdGRlcnI6ICR7c3RkZXJyfWApO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHQgIH1cblx0XHRcdFx0Y29uc29sZS5sb2coY29tbWFuZFN0cmluZylcblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0KVxuXG4vLyAjZW5kcmVnaW9uXG5cbi8vXG4vL1xuLy9cbi8vICNyZWdpb24gU3RhcnQgT0JTIFdlYnNvY2tldCBjb25uZWN0aW9uXG4vL1xudGhpcy5hZGRDb21tYW5kKHtcblx0aWQ6ICdjb25uZWN0LXRvLW9icycsXG5cdG5hbWU6ICdTdGFydCBPQlMgQ29ubmVjdGlvbicsXG5cdGNhbGxiYWNrOiBhc3luYygpID0+IHtcblx0XHRcblx0XHQvL2Nvbm5lY3QgdG8gT0JTXG5cdFx0bGV0IHdlYnNvY2tldElQID0gdGhpcy5zZXR0aW5ncy53ZWJzb2NrZXRJUF9UZXh0O1xuXHRcdGxldCB3ZWJzb2NrZXRQb3J0ID0gdGhpcy5zZXR0aW5ncy53ZWJzb2NrZXRQb3J0X1RleHQ7XG5cdFx0bGV0IHdlYnNvY2tldFBhc3N3b3JkID0gdGhpcy5zZXR0aW5ncy53ZWJzb2NrZXRQV19UZXh0O1xuXHRcdFxuXHRcdC8vXG5cdFx0Ly8gI3JlZ2lvbiBDb25uZWN0IHRoaXMgYXBwIHRvIE9CU1xuXHRcdC8vXG5cdFx0Y29uc3Qgb2JzID0gbmV3IE9CU1dlYlNvY2tldCh3ZWJzb2NrZXRJUCwgd2Vic29ja2V0UG9ydCwgd2Vic29ja2V0UGFzc3dvcmQpO1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCB7IG9ic1dlYlNvY2tldFZlcnNpb24sIG5lZ290aWF0ZWRScGNWZXJzaW9uIH0gPSBhd2FpdCBvYnMuY29ubmVjdChcblx0XHRcdFx0YHdzOi8vJHt3ZWJzb2NrZXRJUH06JHt3ZWJzb2NrZXRQb3J0fWAsXG5cdFx0XHRcdHdlYnNvY2tldFBhc3N3b3JkLFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cnBjVmVyc2lvbjogMSxcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHRcdGNvbnNvbGUubG9nKFxuXHRcdFx0XHRgQ29ubmVjdGVkIHRvIHNlcnZlciAke29ic1dlYlNvY2tldFZlcnNpb259ICh1c2luZyBSUEMgJHtuZWdvdGlhdGVkUnBjVmVyc2lvbn0pYFxuXHRcdFx0KTtcblx0XHRcdG5ldyBOb3RpY2UoXCJDb25uZWN0ZWQgdG8gT0JTIFdlYlNvY2tldCBTZXJ2ZXJcIilcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0bmV3IE5vdGljZShcIkZhaWxlZCB0byBjb25uZWN0IHRvIE9CUyBXZWJTb2NrZXQgU2VydmVyXCIpXG5cdFx0XHRjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNvbm5lY3RcIiwgZXJyb3IuY29kZSwgZXJyb3IubWVzc2FnZSk7XG5cdFx0fVxuXHRcdG9icy5vbihcImVycm9yXCIsIChlcnIpID0+IHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJTb2NrZXQgZXJyb3I6XCIsIGVycik7XG5cdFx0fSk7XG5cdFx0Y29uc29sZS5sb2coYHdzOi8vJHt3ZWJzb2NrZXRJUH06JHt3ZWJzb2NrZXRQb3J0fWApO1xuXHRcdC8vICNlbmRyZWdpb25cblxuXHRcdC8vbGlzdGVuIGZvciBDdXN0b20gRXZlbnRzXG5cdFx0b2JzLm9uKFwiQ3VzdG9tRXZlbnRcIiwgYXN5bmMgZnVuY3Rpb24gKGV2ZW50KXtcblx0XHRcdGlmIChldmVudC5ldmVudF9uYW1lID09PSBcImFkZC1vYnNpZGlhbi10YWdcIikge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcInRhZyBtZXNzYWdlIGZyb20gT0JTXCIsZXZlbnQpO1xuXHRcdFx0XHRjb25zdCB0YWcgPSBKU09OLnBhcnNlKGV2ZW50LmV2ZW50X2RhdGEudGFnKTtcblx0XHRcdFx0YXBwLndvcmtzcGFjZS5hY3RpdmVFZGl0b3I/LmVkaXRvcj8ucmVwbGFjZVNlbGVjdGlvbih0YWcpXG5cdFx0XHR9XG5cdFx0XHRpZiAoZXZlbnQuZXZlbnRfbmFtZSA9PT0gXCJvcGVuLWd1bS1wYWdlXCIpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJvcGVuIGd1bSBtZXNzYWdlIGZyb20gT0JTXCIsZXZlbnQpO1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcIm9wZW4gZ3VtIG1lc3NhZ2UgZnJvbSBPQlNcIix0aGlzKTtcblx0XHRcdFx0Y29uc3QgcG9ydCA9IGFwcC5wbHVnaW5zLnBsdWdpbnNbJ3NsaWRlcy1leHRlbmRlZCddLnBvcnQ7XG5cdFx0XHRcdHdpbmRvdy5vcGVuKGBodHRwOi8vbG9jYWxob3N0OiR7cG9ydH0vX0dVTWApXG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pXG5cblxuXG4vLyAjZW5kcmVnaW9uXG5cblxuLy9FbmQgb2Ygb25sb2FkKClcbn1cblxuYXN5bmMgb3BlblZpZXcoKXtcblx0Y29uc3QgeyB3b3Jrc3BhY2UgfSA9IHRoaXMuYXBwO1xuXHR0aGlzLmFwcC53b3Jrc3BhY2UuZGV0YWNoTGVhdmVzT2ZUeXBlKFVVSElNU1lfVklFV19UWVBFKVx0XG5cdGxldCBsZWFmOiBXb3Jrc3BhY2VMZWFmIHwgbnVsbCA9IG51bGw7XG4gICAgY29uc3QgbGVhdmVzID0gd29ya3NwYWNlLmdldExlYXZlc09mVHlwZShVVUhJTVNZX1ZJRVdfVFlQRSk7XG5cbiAgICBpZiAobGVhdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIEEgbGVhZiB3aXRoIG91ciB2aWV3IGFscmVhZHkgZXhpc3RzLCB1c2UgdGhhdFxuICAgICAgbGVhZiA9IGxlYXZlc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3VyIHZpZXcgY291bGQgbm90IGJlIGZvdW5kIGluIHRoZSB3b3Jrc3BhY2UsIGNyZWF0ZSBhIG5ldyBsZWFmXG4gICAgICAvLyBpbiB0aGUgcmlnaHQgc2lkZWJhciBmb3IgaXRcbiAgICAgIGxlYWYgPSB3b3Jrc3BhY2UuZ2V0UmlnaHRMZWFmKGZhbHNlKTtcbiAgICAgIGF3YWl0IGxlYWYuc2V0Vmlld1N0YXRlKHsgdHlwZTogVVVISU1TWV9WSUVXX1RZUEUsIGFjdGl2ZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICAvLyBcIlJldmVhbFwiIHRoZSBsZWFmIGluIGNhc2UgaXQgaXMgaW4gYSBjb2xsYXBzZWQgc2lkZWJhclxuICAgIHdvcmtzcGFjZS5yZXZlYWxMZWFmKGxlYWYpO1xuICB9XG5cblx0b251bmxvYWQoKSB7XG5cdFx0dGhpcy5hcHAud29ya3NwYWNlLmRldGFjaExlYXZlc09mVHlwZShVVUhJTVNZX1ZJRVdfVFlQRSlcblx0XHRuZXcgTm90aWNlKFwiRGlzYWJsZWQgVVVoaW1zeSBwbHVnaW5cIilcblxuXHR9XG59IiwgImltcG9ydCB1dWhpbXN5UGx1Z2luIGZyb20gXCJtYWluXCI7XG5pbXBvcnQge0FwcCwgTm90aWNlLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nLCBub3JtYWxpemVQYXRoIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmV4cG9ydCBjbGFzcyB1dWhpbXN5U2V0dGluZ3NUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgICBwbHVnaW46IHV1aGltc3lQbHVnaW47XG5cbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiB1dWhpbXN5UGx1Z2luKXtcbiAgICAgICAgc3VwZXIoYXBwLHBsdWdpbik7XG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgIH1cbiAgICBcbiAgICBkaXNwbGF5KCl7XG4gICAgICAgIGxldCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuICAgICAgICBjb250YWluZXJFbC5lbXB0eSgpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZShcIk9CUyBXZWJTb2NrZXQgU2VydmVyXCIpXG4gICAgICAgIC5zZXRIZWFkaW5nKClcbiAgICAgICAgLnNldERlc2MoXCJTZXQgdGhlIE9CUyBXZWJzb2NrZXQgU2VydmVyIFNldHRpbmdzXCIpXG4gICAgICAgIFxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgLnNldE5hbWUoXCJJUFwiKVxuICAgICAgICAuc2V0RGVzYyhcIkVudGVyIHRoZSBJUCBhZGRyZXNzIG9yICdsb2NhbGhvc3QnXCIpXG4gICAgICAgIC5hZGRUZXh0KChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpdGVtLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLndlYnNvY2tldElQX1RleHQpLm9uQ2hhbmdlKFxuICAgICAgICAgICAgICAgICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy53ZWJzb2NrZXRJUF9UZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hfd2Vic29ja2V0RGV0YWlsc0pTKHRoaXMpXG4gICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgIC5zZXROYW1lKFwiUE9SVFwiKVxuICAgICAgICAuYWRkVGV4dCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaXRlbS5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy53ZWJzb2NrZXRQb3J0X1RleHQpLm9uQ2hhbmdlKFxuICAgICAgICAgICAgICAgICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy53ZWJzb2NrZXRQb3J0X1RleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKClcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaF93ZWJzb2NrZXREZXRhaWxzSlModGhpcylcbiAgICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgLnNldE5hbWUoXCJQYXNzd29yZFwiKVxuICAgICAgICAuYWRkVGV4dCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaXRlbS5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy53ZWJzb2NrZXRQV19UZXh0KS5vbkNoYW5nZShcbiAgICAgICAgICAgICAgICAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mud2Vic29ja2V0UFdfVGV4dCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKVxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoX3dlYnNvY2tldERldGFpbHNKUyh0aGlzKVxuICAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZShcIk9CUyBMYXVuY2ggUGFyYW1ldGVyc1wiKVxuICAgICAgICAuc2V0SGVhZGluZygpXG4gICAgICAgIC5zZXREZXNjKFwiT3BlbiBPQlMgd2l0aCB0aGVzZSBvcHRpb25zLlwiKVxuICAgICAgICBcbiAgICAgICAgaWYocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJkYXJ3aW5cIil7XG4gICAgICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiTmFtZVwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJFbnRlciAnT0JTJyBvciBhIGN1c3RvbSBuYW1lXCIpXG4gICAgICAgICAgICAuYWRkVGV4dCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW0uc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mub2JzQXBwTmFtZV9UZXh0KS5vbkNoYW5nZShcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vYnNBcHBOYW1lX1RleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCIpe1xuICAgICAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZShcIk5hbWVcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiRW50ZXIgJ29iczY0LmV4ZScgb3IgYSBjdXN0b20gbmFtZVwiKVxuICAgICAgICAgICAgLmFkZFRleHQoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm9ic0FwcE5hbWVfVGV4dCkub25DaGFuZ2UoXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub2JzQXBwTmFtZV9UZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiUGF0aCB0byBPQlMgYXBwXCIpXG4gICAgICAgICAgICAuYWRkVGV4dCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW0uc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mub2JzQXBwUGF0aF9UZXh0KS5vbkNoYW5nZShcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vYnNBcHBQYXRoX1RleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgIC5zZXROYW1lKFwiQ29sbGVjdGlvblwiKVxuICAgICAgICAuYWRkVGV4dCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaXRlbS5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5vYnNDb2xsZWN0aW9uX1RleHQpLm9uQ2hhbmdlKFxuICAgICAgICAgICAgICAgICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vYnNDb2xsZWN0aW9uX1RleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZShcIk9CUyBCcm93c2VyIFNvdXJjZSBEZWJ1ZyBQb3J0XCIpXG4gICAgICAgIC5zZXREZXNjKFwiRW50ZXIgYSBQb3J0IGZvciB0aGUgUmVtb3RlIERlYnVnZ2VyLCBvciBsZWF2ZSBibGFuayB0byBza2lwIHRoaXMgb3B0aW9uXCIpXG4gICAgICAgIC5hZGRUZXh0KChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpdGVtLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm9ic0RlYnVnUG9ydF9UZXh0KS5vbkNoYW5nZShcbiAgICAgICAgICAgICAgICAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub2JzRGVidWdQb3J0X1RleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZShcIk9TQyBTZXJ2ZXJcIilcbiAgICAgICAgLnNldEhlYWRpbmcoKVxuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZShcIklQXCIpXG4gICAgICAgIC5zZXREZXNjKFwiRW50ZXIgdGhlIElQIGFkZHJlc3Mgb3IgJ2xvY2FsaG9zdCdcIilcbiAgICAgICAgLmFkZFRleHQoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGl0ZW0uc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mub3NjSVBfVGV4dCkub25DaGFuZ2UoXG4gICAgICAgICAgICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm9zY0lQX1RleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKClcbiAgICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgLnNldE5hbWUoXCJJbmNvbWluZyBNZXNzYWdlIFBPUlRcIilcbiAgICAgICAgLmFkZFRleHQoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGl0ZW0uc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mub3NjSW5Qb3J0X1RleHQpLm9uQ2hhbmdlKFxuICAgICAgICAgICAgICAgICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vc2NJblBvcnRfVGV4dCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKVxuICAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZShcIk91dCBnb2luZyBNZXNzYWdlIFBPUlRcIilcbiAgICAgICAgLmFkZFRleHQoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGl0ZW0uc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mub3NjT3V0UG9ydF9UZXh0KS5vbkNoYW5nZShcbiAgICAgICAgICAgICAgICAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3NjT3V0UG9ydF9UZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZShcIkFkZCBVVWhpbXN5IHNjcmlwdHMgdG8gU2xpZGVzIEV4dGVuZGVkIFRlbXBsYXRlXCIpXG4gICAgICAgIC5zZXRIZWFkaW5nKClcbiAgICAgICAgLnNldERlc2MoXCJVVWhpbXN5IHNjcmlwdHMgd2lsbCBiZSBpbmNsdWRlZCB3aGVuIGV4cG9ydGluZyBTbGlkZXMgRXh0ZW5kZWQgc2xpZGVzXCIpXG4gICAgICAgIC5hZGRCdXR0b24oKGJ1dHRvbikgPT4ge1xuICAgICAgICAgICAgYnV0dG9uXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoXCJBZGQgVVVoaW1zeSBzY3JpcHRzIHRvIFNsaWRlcyBFeHRlbmRlZCBUZW1wbGF0ZVwiKVxuICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKFwiVVVoaW1zeSBzY3JpcHRzIGFyZSBpbmNsdWRlZCB3aGVuIGV4cG9ydGluZyBmcm9tIFNsaWRlcyBFeHRlbmRlZFwiKVxuICAgICAgICAgICAgICAgIC5zZXRDdGEoKVxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gYC5vYnNpZGlhbi9wbHVnaW5zL3NsaWRlcy1leHRlbmRlZC90ZW1wbGF0ZS9yZXZlYWwuaHRtbGA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5leGlzdHMobm9ybWFsaXplUGF0aChgJHtmaWxlTmFtZX1gKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGUgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLnJlYWQobm9ybWFsaXplUGF0aChgJHtmaWxlTmFtZX1gKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZpbGUuaW5jbHVkZXMoYDxzY3JpcHQgc3JjPVwiL19icm93c2VyX1NvdXJjZXMvanMvcmV2ZWFsU2xpZGVDb250cm9scy5qc1wiPjwvc2NyaXB0PmApKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCd0ZW1wbGF0ZSBhbHJlYWR5IGluY2x1ZGVzIHV1aGltc3kgc2NyaXB0cycpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ2FkZGluZyBVVWhpbXN5IHNjcmlwdHMgdG8gU2xpZGVzIEV4dGVuZGVkIFRlbXBsYXRlJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5wcm9jZXNzKG5vcm1hbGl6ZVBhdGgoYCR7ZmlsZU5hbWV9YCksIChkYXRhKSA9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucmVwbGFjZSgnPC9ib2R5PicsYCAgICA8c2NyaXB0IHNyYz1cIi9fYnJvd3Nlcl9Tb3VyY2VzL29ic193ZWJTb2NrZXRfZGV0YWlscy93ZWJzb2NrZXREZXRhaWxzLmpzXCI+PC9zY3JpcHQ+XG4gICAgPHNjcmlwdCBzcmM9XCIvX2Jyb3dzZXJfU291cmNlcy9vYnNfd2ViU29ja2V0X2RldGFpbHMvb2JzLXdzLmpzXCI+PC9zY3JpcHQ+XG4gICAgPHNjcmlwdCBzcmM9XCIvX2Jyb3dzZXJfU291cmNlcy9vYnNfd2ViU29ja2V0X2RldGFpbHMvb2JzQ29ubmVjdC5qc1wiPjwvc2NyaXB0PlxuICAgIDxzY3JpcHQgc3JjPVwiL19icm93c2VyX1NvdXJjZXMvb2JzX3dlYlNvY2tldF9kZXRhaWxzL3N0YXJ0Q29ubmVjdGlvbi5qc1wiPjwvc2NyaXB0PlxuICAgIDxzY3JpcHQgc3JjPVwiL19icm93c2VyX1NvdXJjZXMvanMvcmV2ZWFsU2xpZGVDb250cm9scy5qc1wiPjwvc2NyaXB0PlxuPC9ib2R5PmApXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3NjT3V0UG9ydF9UZXh0KS5vbkNoYW5nZShcbiAgICAgICAgICAgICAgICAvLyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3NjT3V0UG9ydF9UZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpXG4gICAgICAgICAgICAgICAgLy8gIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hfd2Vic29ja2V0RGV0YWlsc0pTKG9ic2lkaWFuKXtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gYF9icm93c2VyX1NvdXJjZXMvb2JzX3dlYlNvY2tldF9kZXRhaWxzL3dlYnNvY2tldERldGFpbHMuanNgO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBhd2FpdCBvYnNpZGlhbi5hcHAudmF1bHQuYWRhcHRlci5leGlzdHMobm9ybWFsaXplUGF0aChgJHtmaWxlTmFtZX1gKSk7XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgb2JzaWRpYW4uYXBwLnZhdWx0LmNyZWF0ZShgJHtmaWxlTmFtZX1gLCBcbiAgICAgICAgICAgICAgICAgICAgYHZhciB3c3NEZXRhaWxzID0ge1xuICAgICAgICAgICAgICAgICAgICBcIklQXCI6XCIke29ic2lkaWFuLnBsdWdpbi5zZXR0aW5ncy53ZWJzb2NrZXRJUF9UZXh0fVwiLFxuICAgICAgICAgICAgICAgICAgICBcIlBPUlRcIjpcIiR7b2JzaWRpYW4ucGx1Z2luLnNldHRpbmdzLndlYnNvY2tldFBvcnRfVGV4dH1cIixcbiAgICAgICAgICAgICAgICAgICAgXCJQV1wiOlwiJHtvYnNpZGlhbi5wbHVnaW4uc2V0dGluZ3Mud2Vic29ja2V0UFdfVGV4dH1cIlxuICAgICAgICAgICAgICAgIH07YCwpO1xuICAgICAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgICAgIGF3YWl0IG9ic2lkaWFuLmFwcC52YXVsdC5kZWxldGUob2JzaWRpYW4uYXBwLnZhdWx0LmdldEZpbGVCeVBhdGgoZmlsZU5hbWUpKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBvYnNpZGlhbi5hcHAudmF1bHQuY3JlYXRlKGAke2ZpbGVOYW1lfWAsIFxuICAgICAgICAgICAgICAgICAgICBgdmFyIHdzc0RldGFpbHMgPSB7XG4gICAgXCJJUFwiOlwiJHtvYnNpZGlhbi5wbHVnaW4uc2V0dGluZ3Mud2Vic29ja2V0SVBfVGV4dH1cIixcbiAgICBcIlBPUlRcIjpcIiR7b2JzaWRpYW4ucGx1Z2luLnNldHRpbmdzLndlYnNvY2tldFBvcnRfVGV4dH1cIixcbiAgICBcIlBXXCI6XCIke29ic2lkaWFuLnBsdWdpbi5zZXR0aW5ncy53ZWJzb2NrZXRQV19UZXh0fVwiXG59O2AsKTsgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5cbi8vIHZhciB3ZWJzb2NrZXRJUCA9IHRoaXMuc2V0dGluZ3Mud2Vic29ja2V0SVBfVGV4dDtcbi8vIHZhciB3ZWJzb2NrZXRQb3J0ID0gdGhpcy5zZXR0aW5ncy53ZWJzb2NrZXRQb3J0X1RleHQ7XG4vLyB2YXIgd2Vic29ja2V0UGFzc3dvcmQgPSB0aGlzLnNldHRpbmdzLndlYnNvY2tldFBXX1RleHQ7IiwgImltcG9ydCB7IEVkaXRvciwgRnV6enlTdWdnZXN0TW9kYWwsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmV4cG9ydCBjbGFzcyBVVWhpbXN5RW50cmFuY2VTdWdnZXN0IGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8VEZpbGU+IHtcbiAgICBnZXRJdGVtcygpOiBURmlsZVtdIHtcbiAgICAgICAgY29uc3QgZmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRGb2xkZXJCeVBhdGgoXCJfc2xpZGVfVGFnc1wiKS5jaGlsZHJlblxuICAgICAgICAvL2NvbnN0IGNob2ljZXMgPSBmaWxlcy5maWx0ZXIoKGZpbGUpID0+IHtyZXR1cm4gZmlsZS5iYXNlbmFtZS5zdGFydHNXaXRoKFwiRW50cmFuY2VcIil9KVxuICAgICAgICBjb25zdCBjaG9pY2VzID0gZmlsZXNcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjaG9pY2VzO1xuICAgIH1cbiAgICBnZXRJdGVtVGV4dChpdGVtOiBURmlsZSk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBpdGVtLmJhc2VuYW1lXG4gICAgfVxuICAgIGFzeW5jIG9uQ2hvb3NlSXRlbShpdGVtOiBURmlsZSwgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCk6IHZvaWQgeyAgXG4gICAgICAgIG5ldyBOb3RpY2UoXCJTZWxlY3RlZCBcIiArIGl0ZW0uYmFzZW5hbWUpO1xuICAgICAgICBjb25zdCB0YWcgPSBpdGVtLmJhc2VuYW1lLnRvTG93ZXJDYXNlKCkuc3BsaXQoJyAtICcpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoaXRlbSkpXG4gICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5hY3RpdmVFZGl0b3I/LmVkaXRvcj8ucmVwbGFjZVNlbGVjdGlvbihgPCEtLSBzbGlkZSBkYXRhLSR7dGFnWzBdfS1lbnRyYW5jZT1cIiR7dGFnWzFdfVwiIC0tPlxuYClcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVVWhpbXN5RXhpdFN1Z2dlc3QgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxURmlsZT4ge1xuICAgIGdldEl0ZW1zKCk6IFRGaWxlW10ge1xuICAgICAgICBjb25zdCBmaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldEZvbGRlckJ5UGF0aChcIl9zbGlkZV9UYWdzXCIpLmNoaWxkcmVuO1xuICAgICAgICBjb25zdCBjaG9pY2VzID0gZmlsZXNcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjaG9pY2VzO1xuICAgIH1cbiAgICBnZXRJdGVtVGV4dChpdGVtOiBURmlsZSk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBpdGVtLmJhc2VuYW1lXG4gICAgfVxuICAgIGFzeW5jIG9uQ2hvb3NlSXRlbShpdGVtOiBURmlsZSwgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCk6IHZvaWQgeyAgXG4gICAgICAgIG5ldyBOb3RpY2UoXCJTZWxlY3RlZCBcIiArIGl0ZW0uYmFzZW5hbWUpO1xuICAgICAgICBjb25zdCB0YWcgPSBpdGVtLmJhc2VuYW1lLnRvTG93ZXJDYXNlKCkuc3BsaXQoJyAtICcpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoaXRlbSkpXG4gICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5hY3RpdmVFZGl0b3I/LmVkaXRvcj8ucmVwbGFjZVNlbGVjdGlvbihgPCEtLSBzbGlkZSBkYXRhLSR7dGFnWzBdfS1leGl0PVwiJHt0YWdbMV19XCIgLS0+XG5gKVxuICAgIH1cbn0iLCAiaW1wb3J0IHsgSXRlbVZpZXcsIFdvcmtzcGFjZUxlYWYsIFNldHRpbmcsIE5vdGljZSwgRWRpdG9yLCBNYXJrZG93blZpZXcsIE1hcmtkb3duRWRpdFZpZXcgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGNvbnN0IFVVSElNU1lfVklFV19UWVBFID0gXCJ1dWhpbXN5LXZpZXdcIlxuXG5leHBvcnQgY2xhc3MgVVVoaW1zeVZpZXcgZXh0ZW5kcyBJdGVtVmlld3tcbiAgICBjb25zdHJ1Y3RvcihsZWFmOiBXb3Jrc3BhY2VMZWFmKSB7XG4gICAgICAgIHN1cGVyKGxlYWYpO1xuICAgICAgfVxuXG4gICAgZ2V0Vmlld1R5cGUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIFVVSElNU1lfVklFV19UWVBFO1xuICAgIH1cblxuICAgIGdldERpc3BsYXlUZXh0KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBcIlVVaGltc3kgVGFnc1wiO1xuICAgIH1cblxuICAgIGFzeW5jIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXJFbC5jaGlsZHJlblsxXTtcbiAgICAgICAgY29udGFpbmVyLmVtcHR5KCk7XG4gICAgICAgIGNvbnRhaW5lci5jcmVhdGVFbCgnaDQnLCB7IHRleHQ6ICdVVWhpbXN5IFRhZ3MnIH0pO1xuXG4gICAgICAgIGNvbnN0IGZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0Rm9sZGVyQnlQYXRoKFwiX3NsaWRlX1RhZ3NcIikuY2hpbGRyZW47XG4gICAgICAgIGNvbnNvbGUubG9nKGZpbGVzKVxuICAgICAgICBmaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJiYXNlbmFtZVwiLGZpbGUuYmFzZW5hbWUpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImZpbGVzXCIsZmlsZXMpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCB0YWcgPSBmaWxlLmJhc2VuYW1lLnNwbGl0KCcgLSAnKVxuICAgICAgICAgICAgdGFnWzBdID0gdGFnWzBdLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lcikuc2V0TmFtZShmaWxlLmJhc2VuYW1lKVxuICAgICAgICAgICAgLmFkZEJ1dHRvbigoaXRlbSkgPT57XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coaXRlbSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInRhZ1wiLHRhZylcbiAgICAgICAgICAgICAgICBpdGVtLnNldEJ1dHRvblRleHQoXCJFbnRyYW5jZVwiKVxuICAgICAgICAgICAgICAgIC5zZXRDdGEoKVxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdExlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TW9zdFJlY2VudExlYWYoKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImxsXCIsbGFzdExlYWYpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RMZWFmV29ya3NwYWNlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYWZCeUlkKGxhc3RMZWFmPy5pZClcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobGFzdExlYWZXb3Jrc3BhY2UpXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2Uuc2V0QWN0aXZlTGVhZihsYXN0TGVhZldvcmtzcGFjZSx0cnVlLHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0TGVhZj8uc2V0RXBoZW1lcmFsU3RhdGUobGFzdExlYWY/LmdldEVwaGVtZXJhbFN0YXRlKCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5hY3RpdmVFZGl0b3I/LmVkaXRvcj8ucmVwbGFjZVNlbGVjdGlvbihgPCEtLSBzbGlkZSBkYXRhLSR7dGFnWzBdfS1lbnRyYW5jZT1cIiR7dGFnWzFdfVwiIC0tPlxuYClcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgSW5zZXJ0ZWQgdGFnJHt0YWdbMV19YClcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hZGRCdXR0b24oIGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGl0ZW0pXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGZpbGUpXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpdGVtLnNldEJ1dHRvblRleHQoXCJFeGl0XCIpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RMZWFmID0gdGhpcy5hcHAud29ya3NwYWNlLmdldE1vc3RSZWNlbnRMZWFmKClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RMZWFmV29ya3NwYWNlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYWZCeUlkKGxhc3RMZWFmPy5pZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5zZXRBY3RpdmVMZWFmKGxhc3RMZWFmV29ya3NwYWNlLHRydWUsdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TGVhZj8uc2V0RXBoZW1lcmFsU3RhdGUobGFzdExlYWY/LmdldEVwaGVtZXJhbFN0YXRlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2UuYWN0aXZlRWRpdG9yPy5lZGl0b3I/LnJlcGxhY2VTZWxlY3Rpb24oYDwhLS0gc2xpZGUgZGF0YS0ke3RhZ1swXX0tZXhpdD1cIiR7dGFnWzFdfVwiIC0tPlxuICAgIGApXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgSW5zZXJ0ZWQgdGFnJHt0YWdbMV19YClcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgLy9jb250YWluZXIuY3JlYXRlRWwoJ3AnLCB7dGV4dDogZmlsZS5iYXNlbmFtZX0pXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjb25zdCBjaG9pY2VzID0gZmlsZXMuZmlsdGVyKChmaWxlKSA9PiB7cmV0dXJuIGZpbGUuYmFzZW5hbWUuc3RhcnRzV2l0aChcIkVudHJhbmNlXCIpfSlcbiAgICAgICAgLy8gY29uc29sZS5sb2coY2hvaWNlcylcbiAgICAgICAgLy8gZm9yIChjb25zdCBjaG9pY2UgaW4gY2hvaWNlcykge1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coY2hvaWNlLilcbiAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKGAke2Nob2ljZX06ICR7Y2hvaWNlWydiYXNlbmFtZSddfWApO1xuICAgICAgICAvLyAgIH1cbiAgICAgIH1cbiAgICBcbiAgICAgIGFzeW5jIG9uQ2xvc2UoKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gY2xlYW4gdXAuXG4gICAgICB9XG59Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQSx1REFBQUEsU0FBQTtBQUFBO0FBRUEsUUFBTSxXQUFXO0FBQUEsTUFDZixHQUFHO0FBQUEsTUFDSCxHQUFHO0FBQUEsTUFDSCxHQUFHO0FBQUEsTUFDSCxHQUFHO0FBQUEsSUFDTDtBQUVBLFFBQU0sV0FBTixNQUFlO0FBQUEsTUFDYixZQUFZLE1BQU0sT0FBTztBQUN2QixhQUFLLE9BQU87QUFDWixhQUFLLFFBQVE7QUFBQSxNQUNmO0FBQUEsSUFDRjtBQUVBLFFBQU1DLFdBQU4sTUFBYztBQUFBLE1BQ1osWUFBWSxZQUFZLE1BQU07QUFDNUIsYUFBSyxVQUFVO0FBQ2YsYUFBSyxVQUFVO0FBQ2YsYUFBSyxPQUFPO0FBQUEsTUFDZDtBQUFBLE1BRUEsT0FBTyxLQUFLO0FBQ1YsWUFBSTtBQUNKLGdCQUFRLE9BQU8sS0FBSztBQUFBLFVBQ3BCLEtBQUs7QUFDSCxnQkFBSSxlQUFlLE9BQU87QUFDeEIsa0JBQUksUUFBUSxPQUFLLEtBQUssT0FBTyxDQUFDLENBQUM7QUFBQSxZQUNqQyxXQUFXLElBQUksTUFBTTtBQUNuQixrQkFBSSxTQUFTLElBQUksSUFBSTtBQUFHLG9CQUFJLE9BQU8sU0FBUyxJQUFJLElBQUk7QUFDcEQsbUJBQUssS0FBSyxLQUFLLEdBQUc7QUFBQSxZQUNwQixPQUFPO0FBQ0wsb0JBQU0sSUFBSSxNQUFNLG1DQUFtQyxLQUFLO0FBQUEsWUFDMUQ7QUFDQTtBQUFBLFVBQ0YsS0FBSztBQUNILGdCQUFJLEtBQUssTUFBTSxHQUFHLE1BQU0sS0FBSztBQUMzQix1QkFBUyxJQUFJLFNBQVMsV0FBVyxHQUFHO0FBQUEsWUFDdEMsT0FBTztBQUNMLHVCQUFTLElBQUksU0FBUyxTQUFTLEdBQUc7QUFBQSxZQUNwQztBQUNBO0FBQUEsVUFD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QTtBQUFBOzs7QUNqZ0JBO0FBQUEsK0NBQUFFLFNBQUE7QUFBQTtBQUVBLFFBQU0sRUFBRSxPQUFPLElBQUksUUFBUSxRQUFRO0FBRW5DLFFBQU0sRUFBRSxRQUFRLElBQUk7QUFjcEIsUUFBTSxhQUFhO0FBQUEsTUFDakI7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQTtBQUFBLE1BQzdDO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUE7QUFBQSxNQUM3QztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBO0FBQUEsTUFDN0M7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQTtBQUFBLE1BQzdDO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7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USxRQUFRLGlCQUFpQixFQUFFO0FBQ3BELG1CQUFPLEtBQUssb0JBQW9CLFdBQVc7QUFBQSxVQUM1QztBQUFBLFFBQ0QsQ0FBQztBQUFBLE1BQ0Y7QUFBQSxJQUNELENBQUM7QUFBQSxFQVFEO0FBQUEsRUFFQSxNQUFNLFdBQVU7QUFDZixVQUFNLEVBQUUsVUFBVSxJQUFJLEtBQUs7QUFDM0IsU0FBSyxJQUFJLFVBQVUsbUJBQW1CLGlCQUFpQjtBQUN2RCxRQUFJLE9BQTZCO0FBQzlCLFVBQU0sU0FBUyxVQUFVLGdCQUFnQixpQkFBaUI7QUFFMUQsUUFBSSxPQUFPLFNBQVMsR0FBRztBQUVyQixhQUFPLE9BQU8sQ0FBQztBQUFBLElBQ2pCLE9BQU87QUFHTCxhQUFPLFVBQVUsYUFBYSxLQUFLO0FBQ25DLFlBQU0sS0FBSyxhQUFhLEVBQUUsTUFBTSxtQkFBbUIsUUFBUSxLQUFLLENBQUM7QUFBQSxJQUNuRTtBQUdBLGNBQVUsV0FBVyxJQUFJO0FBQUEsRUFDM0I7QUFBQSxFQUVELFdBQVc7QUFDVixTQUFLLElBQUksVUFBVSxtQkFBbUIsaUJBQWlCO0FBQ3ZELFFBQUksd0JBQU8seUJBQXlCO0FBQUEsRUFFckM7QUFDRDsiLAogICJuYW1lcyI6IFsibW9kdWxlIiwgIk1lc3NhZ2UiLCAibW9kdWxlIiwgIk1lc3NhZ2UiLCAibW9kdWxlIiwgImIiLCAiYiIsICJidWZmZXIiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJTZXJ2ZXIiLCAibW9kdWxlIiwgIk1lc3NhZ2UiLCAiQ2xpZW50IiwgInJlcXVpcmVfbGliIiwgIk1lc3NhZ2UiLCAiU2VydmVyIiwgIkNsaWVudCIsICJtb2R1bGUiLCAibW9kdWxlIiwgInNlbGYiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgInVzZUNvbG9ycyIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJkYXRhIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgImtleSIsICJtb2R1bGUiLCAiZXJyIiwgIm1vZHVsZSIsICJwcm90b2NvbCIsICJtb2R1bGUiLCAibW9kdWxlIiwgInJlcXVpcmVfbm9kZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIk1hdGgiLCAidW5kZWZpbmVkIiwgIm1vZHVsZSIsICJNYXRoIiwgIm4iLCAiSCIsICJiIiwgIm1vZHVsZSIsICJPQlNXZWJTb2NrZXQiLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgIndlYnNvY2tldElQIiwgIndlYnNvY2tldFBvcnQiLCAid2Vic29ja2V0UGFzc3dvcmQiLCAib3NjSVAiLCAib3NjSW5QT1JUIiwgIm9zY091dFBPUlQiLCAidmF1bHRQYXRoIiwgInV0aWwiLCAiZXhlYyJdCn0K
