
# Dataview in Templater

#dataview 
#templater
### Examples of "burning out" dataview views

https://monotykamary.hashnode.dev/burning-out-dataviews-in-obsidian-with-templater


This is where we keep track of our top 10 latest Brainery notes:
Here we integrate a bit of JavaScript inside `<%* ... %> Templater tags along with dataview queries to scaffold our template.

Example template

```
<%*
const dv = this.app.plugins.plugins["dataview"].api;
const te = await dv.queryMarkdown(`LIST FROM -"_templates" AND -"_reports" AND -"challenge" WHERE date != NULL SORT date DESC LIMIT 10`);
tR += te.value;
%>

## Top Contributors this month
---
<%*
const topDiscordNotes = dv.pages(`-"_templates" AND -"_reports" AND -"challenge"`)
    .where(p => !!p.file.frontmatter.discord_id)
    .where(p => !!p.file.frontmatter.date)
    .where(p => dv.date(p.file.frontmatter.date) !== null)
    .where(p => dv.date(p.file.frontmatter.date).month === dv.date('today').month)
    .sort(p => p.date, "desc")
    .groupBy(p => p.discord_id)

const topAuthoredNotes = dv.pages(`-"_templates" AND -"_reports" AND -"challenge"`)
    .where(p => !!p.file.frontmatter.author)
    .where(p => !!p.file.frontmatter.date)
    .where(p => dv.date(p.file.frontmatter.date) !== null)
    .where(p => dv.date(p.file.frontmatter.date).month === dv.date('today').month)
    .sort(p => p.date, "desc")
    .groupBy(p => p.author);

tR += "| authors | notes |\n"
tR += "| ------- | ----- |\n"

for (let group of topDiscordNotes) {
    tR += `| ${group.key} | `
    for (let row of group.rows) {
        tR += ` [[${row.file.name}]]<br>`
    }
    tR += "|\n"
}

for (let group of topAuthoredNotes) {
    tR += `| ${group.key} | `
    for (let row of group.rows) {
        tR += ` [[${row.file.name}]]<br>`
    }
    tR += "|\n"
}
%>


## Newest Contributors
---
<%*
const discordNotes = dv.pages(`-"_templates" AND -"_reports" AND -"challenge"`)
    .where(p => !!p.file.frontmatter.discord_id)
    .where(p => !!p.file.frontmatter.date)
    .where(p => dv.date(p.file.frontmatter.date) !== null)
    .sort(p => p.date, "desc")
    .groupBy(p => p.discord_id)
    .filter(p => p.rows.length <= 1);

for (let group of discordNotes) {
    tR += `- **${group.key}**: `
    for (let row of group.rows) {
        tR += `${row.file.link}\n`
    }
}
%>
---
<%*
const authoredNotes = dv.pages(`-"_templates" AND -"_reports" AND -"challenge"`)
    .where(p => !!p.file.frontmatter.author)
    .where(p => !!p.file.frontmatter.date)
    .where(p => dv.date(p.file.frontmatter.date) !== null)
    .sort(p => p.date, "desc")
    .groupBy(p => p.author)
    .filter(p => p.rows.length <= 1);

for (let group of authoredNotes) {
    tR += `- **${group.key}**: `
    for (let row of group.rows) {
        tR += `${row.file.link}\n`
    }
}
%>
```
*This page was last modified at <%* tR += new Date().toISOString();%>*.



both our **template** and the **target static file** we want to apply should have the `recurringTemplate` and `recurringTemplateName` keys in their frontmatter. Our action to apply the template will first **delete** the file, **recreate** the file, **then apply the template statically to it**.

Example front matter for template and static file
```
---
recurringTemplate: true
recurringTemplateName: latest-notes
---
```

#### The script to automate all of this
```
<%*
const dv = this.app.plugins.plugins["dataview"].api;
const recurringTemplatesList = dv.pages(`"_templates"`)
    .where(e => e.file.frontmatter.recurringTemplate);
const mappedRecurringTemplateNames = recurringTemplatesList.array().reduce((a, c) => {
    a[c.recurringTemplateName] = c.file.name
    return a;
}, {})

const matchingNotes = dv.pages(`!"_templates"`)
    .where(e => e.file.frontmatter.recurringTemplate);

for (const element of matchingNotes) {
    const { recurringTemplateName } = element
    const filePath = app.vault.getAbstractFileByPath(element.file.path);
    const folder = app.vault.getAbstractFileByPath(element.file.folder)

    // find the template
    const templatePath = mappedRecurringTemplateNames[recurringTemplateName];
    const template = tp.file.find_tfile(templatePath);

    // delete the file
    await app.vault.trash(filePath, true);

    // create a new file with the matching template
    await tp.file.create_new(template, element.file.name, false, folder);
}
%>
```